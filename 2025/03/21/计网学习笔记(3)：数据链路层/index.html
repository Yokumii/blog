
<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>YokumiのBlog</title>
        <link rel="icon" href="/blog/images/favicon.ico" type="image/x-icon">
        <link rel="shortcut icon" href="/blog/images/favicon.ico" type="image/x-icon">
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/blog/js/lib/highlight.js"></script>


<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css" />
<script src="/blog/js/lib/math.js"></script>


<script src="/blog/js/lib/preview.js"></script>









<link rel="stylesheet" href="/blog/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/blog/atom.xml" title="YokumiのBlog" type="application/atom+xml">
</head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/blog/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/blog/">
            <span>YOKUMIのBLOG</span>
        </a>
        
        <a href="/blog/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/blog/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/blog/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/blog/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/blog/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;YOKUMIのBLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/blog/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/blog/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/blog/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/blog/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/blog/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>计网学习笔记(3)：数据链路层</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/3/21
        </span>
        
        <span class="category">
            <a href="/blog/categories/%E4%B8%93%E4%B8%9A%E5%AD%A6%E4%B9%A0/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                专业学习
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/blog/tags/private/" style="color: #ff7d73">
                    private
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/blog/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="color: #00bcd4">
                    计算机网络
                </a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <p>数据链路层对实际在物理层中传输的信号起到差错控制和流量控制的作用，特别是在广播信道中，需要解决多个发送方同时发送信号造成的共享信道冲突，一般由接受方控制发送方。</p>
<h1 id="Technologies"><a href="#Technologies" class="headerlink" title="Technologies"></a>Technologies</h1><h2 id="Framing"><a href="#Framing" class="headerlink" title="Framing"></a>Framing</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Encapsulates network packet into a frame，封装成帧，即将网络层发送的Packet加上Header和Trailer，组成Frame。</p>
<h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><p>由于数据链路层间是虚拟通信，实际信号传输通过物理层传输01比特串，这要求数据链路层从01比特串中能正确识别出帧（<strong><em>帧同步</em></strong>）。</p>
<ul>
<li>Simple，容易实现；</li>
<li>Code Independent，加上的内容与传输的消息内容无关；</li>
<li>Efficient，所用信号带宽尽量小；</li>
<li>Robustness，出错后能重新同步；</li>
</ul>
<h3 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h3><h4 id="Character-Count-字符计数法"><a href="#Character-Count-字符计数法" class="headerlink" title="Character Count 字符计数法"></a>Character Count 字符计数法</h4><p>在每帧之前加上一个字符表示帧的长度，一错后面都错；</p>
<h4 id="Byte-Stuffing-字符填充法"><a href="#Byte-Stuffing-字符填充法" class="headerlink" title="Byte Stuffing 字符填充法"></a>Byte Stuffing 字符填充法</h4><p>用特定的标志表示帧的开始和结束：<img src="计网学习笔记(3" alt>：数据链路层/2.png)</p>
<p>如果帧的其他控制和数据部分含有帧的开始符或结束符怎么办？——<strong><em>Transparent Transmission透明传输</em></strong><br><img src="计网学习笔记(3" alt>：数据链路层/3.png)</p>
<p>即：如果中间含有Flag，在Flag之前插入1个ESC；如果中间含有ESC，在ESC前面插入1个ESC；</p>
<h4 id="Bit-Stuffing-比特填充法"><a href="#Bit-Stuffing-比特填充法" class="headerlink" title="Bit Stuffing 比特填充法"></a>Bit Stuffing 比特填充法</h4><ol>
<li>用连续的6个1表示开始和结束标志：01111110；</li>
<li>中间部分，在从左到右每出现5个1之后插入1个0，可以有效避免中间部分被识别为开始符或结束符，且容易解码；</li>
</ol>
<h4 id="Physical-Layer-Coding-Violations-物理层编码违例法"><a href="#Physical-Layer-Coding-Violations-物理层编码违例法" class="headerlink" title="Physical Layer Coding Violations 物理层编码违例法"></a>Physical Layer Coding Violations 物理层编码违例法</h4><p>适用于比较特殊的编码，比如Manchester编码，用没有出现跳变的信号表示开始符和结束符；</p>
<h2 id="Error-control"><a href="#Error-control" class="headerlink" title="Error control"></a>Error control</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="Error-Types"><a href="#Error-Types" class="headerlink" title="Error Types"></a>Error Types</h4><ul>
<li>Lost Frames；</li>
<li>Damaged Frames；</li>
</ul>
<h4 id="Error-Detection-检错"><a href="#Error-Detection-检错" class="headerlink" title="Error Detection 检错"></a>Error Detection 检错</h4><ul>
<li>Parity Check 奇偶校验：单冗余码；</li>
<li>Cyclic Redundancy Check(CRC) 循环检错；</li>
<li>Checksum：在网络层中；</li>
</ul>
<h4 id="Error-Correction-纠错"><a href="#Error-Correction-纠错" class="headerlink" title="Error Correction 纠错"></a>Error Correction 纠错</h4><p>Error Correction Code(ECC) 纠错码，分为：</p>
<ul>
<li><strong><em>Forward Error Correction(FEC) 前向纠错</em></strong>：例如汉明编码；</li>
<li><strong><em>Automatic Repeat reQuest(ARQ) 自动重传请求</em></strong>：检错+重传；</li>
<li><strong><em>Hybrid Error Correction(HEC) 混合纠错</em></strong>；</li>
</ul>
<h4 id="Single-bit-Error-vs-Burst-Error"><a href="#Single-bit-Error-vs-Burst-Error" class="headerlink" title="Single-bit Error vs. Burst Error"></a>Single-bit Error vs. Burst Error</h4><p><img src="计网学习笔记(3" alt>：数据链路层/4.png)</p>
<p><strong><em>注意下图中突发错误的长度为5：从第一个错误的到最后一个错误的比特数</em></strong>；</p>
<h3 id="ECC纠错码：汉明距离"><a href="#ECC纠错码：汉明距离" class="headerlink" title="ECC纠错码：汉明距离"></a>ECC纠错码：汉明距离</h3><p>在所有合法的码字中：</p>
<ul>
<li>如果需要检测出 t 位比特错误，需要最小汉明距离为 t + 1；</li>
<li>如果需要纠正出 t 位比特错误，需要最小汉明距离位 2t + 1；</li>
</ul>
<h4 id="The-Num-of-Check-Bits-to-Correct-Single-Bit-Error"><a href="#The-Num-of-Check-Bits-to-Correct-Single-Bit-Error" class="headerlink" title="The Num of Check Bits to Correct Single Bit Error"></a>The Num of Check Bits to Correct Single Bit Error</h4><p>只考虑纠正一位错误：</p>
<ul>
<li>$m$：原始信息长度；</li>
<li>$r$：check bits，即需要增加的校验位长度；</li>
<li>$n$：码字长度，即$n = m + r$；</li>
</ul>
<p>根据原始信息长度，推出存在$2^m$个合法信息，每一个合法信息按照$n$的码字传输，能产生和它有一位比特差错的种类有$n$个，所有共有$(n + 1)2^m$个码字；<br>$n$位码字的种类共有$2^n$个，所以要求：</p>
<script type="math/tex; mode=display">
(n + 1)2^m \le 2^n \Leftrightarrow m + r + 1 \le 2^r</script><h4 id="汉明编码：Correction-of-Single-Bit-Error"><a href="#汉明编码：Correction-of-Single-Bit-Error" class="headerlink" title="汉明编码：Correction of Single Bit Error"></a>汉明编码：Correction of Single Bit Error</h4><ul>
<li>只允许在$2^i$位置处放置校验位Check Bits；</li>
<li>剩下的位置填充数据位；</li>
</ul>
<p><img src="计网学习笔记(3" alt>：数据链路层/5.png)<br><img src="计网学习笔记(3" alt>：数据链路层/6.png)</p>
<h3 id="Error-Detection-Code"><a href="#Error-Detection-Code" class="headerlink" title="Error Detection Code"></a>Error Detection Code</h3><h4 id="Even-Parity-Checking-偶校验"><a href="#Even-Parity-Checking-偶校验" class="headerlink" title="Even-Parity Checking 偶校验"></a>Even-Parity Checking 偶校验</h4><h4 id="Polynomial-Code-多项式编码"><a href="#Polynomial-Code-多项式编码" class="headerlink" title="Polynomial Code 多项式编码"></a>Polynomial Code 多项式编码</h4><p>也称为<strong><em>CRC(Cyclic Redundancy Check，循环冗余校验)</em></strong> 或 <strong><em>FCS(Frame Check Sequence，帧校验序列)</em></strong> ；</p>
<ul>
<li>$M(x)$：将要传输的比特看成多项式，比如：$110001 \Rightarrow x^5 + x^4 + x^0$；</li>
<li>运算定义为模2运算，即$x + y = x - y = x\oplus y$；</li>
<li>$G(x)$：生成多项式；</li>
</ul>
<h5 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h5><ol>
<li>$M(x) * x^r$，即在传输的数据右边增加$r$个0；</li>
<li>$M(x) * x^r / G(x) \cdots R(x)$，即作除法后得到余数多项式$R(x)$；</li>
<li>Sender发送方：$T(x) = M(x) <em> x^r + R(x) = M(x) </em> x^r - R(x)$；</li>
<li>Receiver接收方：$T(x) / G(x)$，余数一定为0；</li>
</ol>
<h5 id="检查过程"><a href="#检查过程" class="headerlink" title="检查过程"></a>检查过程</h5><ol>
<li>接收方如果收到错误的信息，即$T(x) + E(x)$；</li>
<li>正常不出错的情况下，$T(x) / G(x)$余数为0；</li>
<li>出错的情况下，结果为$E(x) / G(x)$的余数；</li>
<li>能捕捉到所有的错误；</li>
</ol>
<h2 id="Flow-control"><a href="#Flow-control" class="headerlink" title="Flow control"></a>Flow control</h2><h3 id="Flow-Control-Protocols"><a href="#Flow-Control-Protocols" class="headerlink" title="Flow Control Protocols"></a>Flow Control Protocols</h3><h4 id="Elementary-Protocols"><a href="#Elementary-Protocols" class="headerlink" title="Elementary Protocols"></a>Elementary Protocols</h4><ul>
<li><strong><em>Utopian Simplex Protocol 乌托邦单工协议</em></strong>；<ul>
<li>通信是单通的；</li>
<li>通信是无错的；</li>
<li>接收方缓存空间无限；</li>
<li>无需差错控制和流量控制；</li>
</ul>
</li>
<li><em>*</em>Simplex Stop-and-Wait Protocol for Error-Free Channel 停等协议<ul>
<li>通信是单通的；</li>
<li>通信是无错的；</li>
<li>接收方缓存空间有限；</li>
<li>需要流量控制：Stop-and-Wait<ul>
<li>发送方发送一个Frame，等待；</li>
<li>接收方如果正确收到信息，发送一个<strong><em>ACK(Acknowledgement，应答)</em></strong>；</li>
<li>发送方接收到ACK后，发送下一个Frame；</li>
</ul>
</li>
<li>如果通信不可靠，会产生如下问题：帧错误、帧丢失或ACK丢失<img src="计网学习笔记(3" alt>：数据链路层/7.png)</li>
<li>其中，如果ACK丢失，发送方会在超时后发送第二个相同的帧，但是接收方并不知道！解决方法：<strong><em>Sequence Number</em></strong>；</li>
</ul>
</li>
<li><strong><em>Protocol 3: Positive ACK with Retransmission(PAR) 带有重试的主动确认协议</em></strong><ul>
<li><strong><em>ARQ(Automatic Repeat reQuest) 自动重传请求</em></strong><ul>
<li>在每个Frame之前添加序号，来区分该Frame是重传的还是新的；</li>
<li>链路层只需要1bit，即编号空间大小为2；</li>
<li>传输层需要更大的编号空间；</li>
<li>但是还是有问题：如果ACK传输延迟了，如下图所示，那么当那个重复发送的Frame0收到后返回给发送方时，发送方认为这是Frame1的应答信号，错误地认为Frame1已经正确发送到接收方；<img src="计网学习笔记(3" alt>：数据链路层/8.png)</li>
<li>所以需要给ACK也添加序号：<img src="计网学习笔记(3" alt>：数据链路层/9.png)</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="lang-c">#define MAX_SEQ 1

typedef enum &#123; 
    frame_arrival, 
    cksum_err, 
    timeout 
&#125; event_type;

#include &quot;protocol.h&quot;

void send() &#123;
    seq_nr next_frame_to_send = 0;
    frame s;
    packet buffer;
    event_type event;

    from_network_layer(&amp;buffer);

    while (true) &#123;
        s.info = buffer;
        s.seq = next_frame_to_send;
        to_physical_layer(&amp;s);
        start_timer(s.seq);
        wait_for_event(&amp;event);

        if (event == frame.arrival) &#123;
            from_physical_layer(&amp;s);
            if (s.ack == next_frame_to_send) &#123;
                stop_timer(s.ack);
                from_network_layer(&amp;buffer);
                next_frame_to_send = 1 - next_frame_to_send;
            &#125;
        &#125;
    &#125;
&#125;

void receive() &#123;
    seq_nr frame_expected = 0;
    frame r, s;
    event_type event;

    while (true) &#123;
        wait_for_event(&amp;event);

        if (event == frame.arrival) &#123;
            from_physical_layer(&amp;r);
            if (r.seq == frame_expected) &#123;
                to_network_layer(&amp;r.info);
                frame_expected = 1 - frame_expected;
            &#125;
            s.ack = 1 - frame_expected;
            to_physical_layer(&amp;s);
        &#125;
    &#125;
&#125;
</code></pre>
<ul>
<li><strong><em>Piggybacking 捎带应答</em></strong><ul>
<li>通信是全双工Full-duplex的；</li>
<li>当接收方收到帧后，不立刻发送ACK，而是等待网络层有发送请求时，将ACK添加到需要发送的帧中一起发送；</li>
<li>缺点是在如果长时间没有发送请求，会因等待应答而造成信道阻塞；</li>
</ul>
</li>
</ul>
<h4 id="Sliding-Window-Protocols-滑动窗口协议"><a href="#Sliding-Window-Protocols-滑动窗口协议" class="headerlink" title="Sliding Window Protocols 滑动窗口协议"></a>Sliding Window Protocols 滑动窗口协议</h4><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul>
<li>可靠，面向连接的服务；</li>
<li>信道是全双工的；</li>
<li>通过CRC+重传进行差错控制；</li>
<li>通过滑动窗口进行流量控制；</li>
</ul>
<h5 id="Protocol-4-Sliding-Window-of-Size-1-大小为1的滑动窗口协议"><a href="#Protocol-4-Sliding-Window-of-Size-1-大小为1的滑动窗口协议" class="headerlink" title="Protocol 4: Sliding Window of Size 1 大小为1的滑动窗口协议"></a>Protocol 4: Sliding Window of Size 1 大小为1的滑动窗口协议</h5><ul>
<li>实际上就是停等协议，只不过变成了全双工，既能发又能收；</li>
<li>在两端同时发送数据时会出现帧重复；</li>
<li>信道效率低，特别是带宽时延积较大的信道，比如卫星通信；</li>
</ul>
<h5 id="Protocol-5-GBN-Go-Back-N-回退N步"><a href="#Protocol-5-GBN-Go-Back-N-回退N步" class="headerlink" title="Protocol 5: GBN(Go Back N 回退N步)"></a>Protocol 5: GBN(Go Back N 回退N步)</h5><ul>
<li>默认情况下接收窗口$W_r = 1$；</li>
<li>$W_t + W_r \le 2^n$，所以发送窗口需要满足$W_t \le 2^{n} - 1$；</li>
<li>如果收到的帧出错，之后接受到的帧都丢弃，直到出错的帧重新发送后被正确接收，在此期间接收方保持沉默，并不会应答；</li>
<li>如果收到的帧与预期收到的不符，丢弃该帧，并回送ACK为当前最后一个已经收到的正确的帧的序号；发送方收到后需要从该ACK序号之后的帧开始重传；</li>
<li>发送方在接收到ACK或帧计时器超时后，需要回退到发错的那一帧并重传；</li>
<li>注意ACK的应答可以采用<strong><em>Cumulative ACK</em></strong>（累计ACK）：不需要每一帧都回送一个ACK，当接收方发送ACK = n时，表示n以及n之前的数据帧都已经正确收到；</li>
<li>对于 $n$ bits的序列号码，$MAX_SEQ = 2^n - 1$；</li>
<li>默认接受方的Buffer缓存空间 $= MAX_SEQ + 1$；</li>
</ul>
<p><strong><em>Protocol 4 vs. Protocol 5</em></strong>：<br><img src="计网学习笔记(3" alt>：数据链路层/10.png)</p>
<h5 id="Protocol-6-SR-ARQ-Selective-Repeat-选择重传"><a href="#Protocol-6-SR-ARQ-Selective-Repeat-选择重传" class="headerlink" title="Protocol 6: SR ARQ(Selective Repeat 选择重传)"></a>Protocol 6: SR ARQ(Selective Repeat 选择重传)</h5><ul>
<li>只有被拒绝的帧才需要重传；</li>
<li>一般默认$W_t = W_r = 2^{n-1}$，注意与Protocol 5区分；</li>
<li>一般，认为接收方需要的Buffer空间 $= W_r$，帧缓存的位置 = $frame.seq \% W_r$，这样能否有效保证任意位置接受窗口内的帧不在同一位置；</li>
<li><strong><em>Frame Timer</em></strong>：发送方每一个缓存的帧都需要一个Timer；</li>
<li><strong><em>ACK Timer</em></strong>：只需要一个，以第一个为准；</li>
<li><strong><em>NCK</em></strong>：以下两种情况，接收方会发送NCK用于加速重传：<ul>
<li>收到的数据帧校验出错；</li>
<li>收到的数据帧和预期的不符合；</li>
<li>NCK的序号就是出错帧（指的是预期的帧）的序号；</li>
</ul>
</li>
<li>向网络层提交数据是一个循环的过程：从接收窗口下沿开始依次提交收到的帧并向前滑动接收窗口直到空闲Buffer出现；</li>
</ul>
<h5 id="协议456的比较"><a href="#协议456的比较" class="headerlink" title="协议456的比较"></a>协议456的比较</h5><p><img src="计网学习笔记(3" alt>：数据链路层/11.png)</p>
<h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><script type="math/tex; mode=display">
\alpha = \frac{T_{prop}}{T_{trans}}</script><h4 id="Error-free-Stop-and-Wait"><a href="#Error-free-Stop-and-Wait" class="headerlink" title="Error-free Stop-and-Wait"></a>Error-free Stop-and-Wait</h4><script type="math/tex; mode=display">
efficiency = \frac{1}{1+2\alpha}</script><h4 id="Stop-and-Wait-with-error"><a href="#Stop-and-Wait-with-error" class="headerlink" title="Stop-and-Wait with error"></a>Stop-and-Wait with error</h4><script type="math/tex; mode=display">
efficiency = \frac{1 - p}{1 + 2\alpha}</script><h4 id="Error-free-Sliding-Window"><a href="#Error-free-Sliding-Window" class="headerlink" title="Error-free Sliding-Window"></a>Error-free Sliding-Window</h4><script type="math/tex; mode=display">
efficiency = \left\{\begin{matrix} 
\frac{W_T}{1 + 2\alpha},W_T < 1 + 2\alpha \\
1, W_T \ge 1 + 2\alpha
\end{matrix}\right.</script><h4 id="Error-free-Sliding-Window-with-Piggybacking"><a href="#Error-free-Sliding-Window-with-Piggybacking" class="headerlink" title="Error-free Sliding-Window with Piggybacking"></a>Error-free Sliding-Window with Piggybacking</h4><script type="math/tex; mode=display">
efficiency = \frac{W_T}{2 + 2\alpha}</script><h2 id="Media-Access-Control"><a href="#Media-Access-Control" class="headerlink" title="Media Access Control"></a>Media Access Control</h2><p>见计网学习笔记(4)：介质访问控制；</p>
<h1 id="Services-to-Network-Layer"><a href="#Services-to-Network-Layer" class="headerlink" title="Services(to Network Layer)"></a>Services(to Network Layer)</h1><ul>
<li>Connectionless services<ul>
<li>Unacknowledged connectionless services：大多数局域网LAN使用无确认；</li>
<li>Acknowledged connectionless services：wireless system；</li>
</ul>
</li>
<li>Acknowledged connection-oriented services：</li>
</ul>
<h1 id="Implement"><a href="#Implement" class="headerlink" title="Implement"></a>Implement</h1><p><img src="计网学习笔记(3" alt>：数据链路层/1.png)</p>
<p>方框内表示一整个Router路由器，一般有3个接口，其中1和2组成路由器的网卡(NIC，Network interface cart)；</p>
<h1 id="Examples-of-Point-to-Point-DataLink-Protocols"><a href="#Examples-of-Point-to-Point-DataLink-Protocols" class="headerlink" title="Examples of Point-to-Point DataLink Protocols"></a>Examples of Point-to-Point DataLink Protocols</h1><h4 id="HDLC-High-Level-DataLink-Control-高级数据链路控制"><a href="#HDLC-High-Level-DataLink-Control-高级数据链路控制" class="headerlink" title="HDLC(High-Level DataLink Control, 高级数据链路控制)"></a>HDLC(High-Level DataLink Control, 高级数据链路控制)</h4><h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><ul>
<li>可靠，面向连接<ul>
<li>流量控制，差错控制；</li>
<li>GoBackN ARQ，Selective Repeat ARQ；</li>
</ul>
</li>
<li>Synchronous serial transmission 同步串行链路传输；</li>
<li>error detection：CRC；</li>
<li>不支持相关链路和网络参数协商；</li>
<li>不支持认证；</li>
</ul>
<h5 id="Frame-Type"><a href="#Frame-Type" class="headerlink" title="Frame Type"></a>Frame Type</h5><p>采用零比特填充。<br><img src="计网学习笔记(3" alt>：数据链路层/12.png)</p>
<h5 id="Station-Type"><a href="#Station-Type" class="headerlink" title="Station Type"></a>Station Type</h5><p><img src="计网学习笔记(3" alt>：数据链路层/13.png)</p>
<h4 id="Point-to-Point-Protocol-PPP-点对点协议"><a href="#Point-to-Point-Protocol-PPP-点对点协议" class="headerlink" title="Point-to-Point Protocol(PPP, 点对点协议)"></a>Point-to-Point Protocol(PPP, 点对点协议)</h4><h5 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h5><ul>
<li>只支持点到点；</li>
<li>Connectionless unacknowledged service；</li>
<li>采用字节填充；</li>
<li>适配多种网络层协议；</li>
<li>支持身份认证；</li>
<li>物理层可以采用异步和同步传输；</li>
</ul>
<h5 id="Frame-Format"><a href="#Frame-Format" class="headerlink" title="Frame Format"></a>Frame Format</h5><p><img src="计网学习笔记(3" alt>：数据链路层/14.png)</p>
<ul>
<li>Address = 0xFF，表示支持所有站点；</li>
<li>Control = 0x03，表示无编号模式；</li>
<li>以上两个字段非必需，可以不要；</li>
</ul>
<h4 id="协议对比"><a href="#协议对比" class="headerlink" title="协议对比"></a>协议对比</h4><p><img src="计网学习笔记(3" alt>：数据链路层/15.png)</p>
<script>

window.addEventListener('hexo-blog-decrypt', function() {

console.log('文章已成功解密！');

// 可以在这里添加额外的回调函数

});

</script>
    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2023 - 2025 YokumiのBlog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;Yokumi
        </div>
        
    </div>
</footer>

<script>
  var event = new Event('hexo-blog-decrypt');
  window.dispatchEvent(event);
</script>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/blog/js/main.js"></script>
    
    




    
</body>
</html>
