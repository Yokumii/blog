<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计组学习笔记(2)：运算方法与运算器II</title>
      <link href="/blog/2025/03/22/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8II/"/>
      <url>/blog/2025/03/22/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8II/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="f6443ab8c448d04d2f0e4945f05ee49bf7f337c126e13e00d1e50b1d39d65e96">6df07e4654b2f23296fe416e73f530c9428362a66fa65e1609e0288a16eb3b092500a150c07fd4b00f3bf6dd992b3f926a7f59d01936de53a8bfcc8c0184a2b233bb0bff9614d7ef26983ab64777904a2696db4655698f6213f499542692d0c23aeb3ca3c433c3e3ef49ba78e30cee3d12930ad8de9e527e122c2e821bbf8b7bde97c7dd20fbe4771ecb22191d4c28055068508c95ab123d9bb9e3d4ad4312ec</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">当前文章暂不对外可见，请输入密码后查看！</span>      </label>    </div>  </div></div><script data-pjax src="/blog/lib/hbe.js"></script><link href="/blog/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> private </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网学习笔记(3)：数据链路层</title>
      <link href="/blog/2025/03/21/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
      <url>/blog/2025/03/21/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="444a7ee06b51baf31ee33b716d0956f01de12572a9ab8c014a2469dc69682426">6df07e4654b2f23296fe416e73f530c9abeabff136125562f2d3e21f19767ff5171eb93c7cb6e2b904cf4079b048411ad6e82de6f8b4902dedb2cf6c6a8e77c8d8014ccf4f73c66d5169bb7bcd56f9d79a48f34da067a100a7a66541ae2b181df6e9c42d271f279532c218cb325d2c39e4696737d805a06b604466bb1e59772b32cb7f3fd330c9f69914813002f9d9404d022a15b95f84e2af06d8a7815c1a3e8808700f1d747bb008f531b6d8f427aa2e99b1b35c2668e822a5c32eaeefa166c403904ea4582f35fc4f5dc4412650374b8389d4ea85a842a1909be69debdfbedc61ad5c3aa399c3e5d995dce938c967c1e08899bf000d01c878e424404a917a58244b0603052925612682cded241751e40608967e09dcfb8a824302bd6cbf14ed3588cd3770ba1e7a6070d9c867d5811977ad6f80fa9f6b4b09d56372294972ad83d9b4f0e4d7966a8177e6485b26ff4403b2ea8a5e891aa5344b4c0225272cbba98738857d4c0d9b2451c0f95e4b6d0299f2cec55e826fc03d1ed3cc72cb7374c03f9e36fb0a9fa9d87efdcb70bdbc26318c6bb9e855870511cc7afaf721ea1a24f76ad2fab06b6870c1abc39874ac037d957f2a69894bbd1cc52bab0ef0b50ed524cdad38faa77b57ffe79be8039f4ec2bbd65fadf30829bc6f3c2371331c309e0ff526d6fdf2ca25d77f6e0a201260512c923c570b13912300520066baea8e9b6764502b335b0e2ddf7b5c0f3c1c544d99306814f275fd5c448ce04be5167932949ddd98b660cb236c5e1882ae1f78cce71c164c2b5416b922cfdf9ebf456970569e55bef2ab43a3f198a18eb0c4c53118e41d7e5aac406e06a5cc4f0719a3f872e1a48dc7a4b4d9d76a7832ce6bccdce92bb22b6774ea56aef3f85202a424d4ce34dbecc0d6304a0deecf093b5588144c5a176a660f42bc57c713af2d40ef5bd35f21136672e3b382a134d45885f5fedce0a150b9e4f651b956993f995f54c75e43b5675585f072bd2454f4c5142e40f36bf31c116d4f81fc4afb7e21a200af73681ba7ba9bd8de08b1bda226c621fafea2996e8c8d186e2868ac92d14efe36a02742331263c20ac2ecf2d55c65edbaf09bb1767c77522da545d2d7e17d8bcf5af74f5a33402df0cd18b7207e49ee93f173f0d5ea59fd6d9a626e03b3e2e4a631f730564e2615b3da46b96e12771a945d6106afd78c87d6a2e1e0b124981fdfcbec5f15d45a109227aa01dc2b2f629adce0d37279d7fb228252506320d81fd7bbc3ad9891b4791eef38617e7daa078674b68a29aabed462b07fd77c24c47555e56ebe2a0c73c6b817326f6597d42174fa1b1c3f04659d48a5a34f7152b748a374c0411ce08cfe85c3deee220059d71d31301804da4ffae4c2f0153df84da7d1e584e717c6477c5d4dde1fb7680a596992b7ea6778812759960acb8c8ddfeb4eb8186e8e3f8e445080976c4190e8cc7bcf1f8b3a1e84f3dd2010e36d81f0f8bb9b0a00ae48e6efbcdb1ea4cad990c1518211893bef258374bcf9616c52dae515ba5795edbe1928e51f3bde5402c8470170ad78293a466ba0201d23be33bae0624abf157e4a98f68b2a5cc7db7720a4a04cd408ba4420ebc7b1aac114556666233a4205da77b9b925dd9e0fd4a8542dfca9f4ac791d2f967f638c97dfaffbdf9d2af33d816af7c52be5bc4ccb930a7bbd55fb957ce166df58cd0db1810a6b84b16bd0c6f1f777184a2233a7897b0ebe732f058a2c9edf06419779777f73b1d1dbdd3350f9cbe452fe75fdde0e22bd05c6db6563437cd862d23cc30d68738025edcc0a63057aeb51c4042d02bf59a65c47e8d7435a48f4f2ff4f74da105904dc2dd2ced4256b49d2071d0bb246081408a4eccd38df6a336eb734c36d202b8830a859221b1961d5e6743464f8ffbff66467ef9afc31278f91615c9bb830c6ed267c7d4dd2decdfe253b64448d548323ad6b82c7a01f9ab1f64d880e065c84525b827389331dbdef8ea93863d5048d521a3780696b93b717fb3736c9a7377740b8ec8040dc18bcd0324c2b6da50c12b772fb7b9cfeb20e11180ebbcf846c98774933b1830d1eda1a76656949861789abe5149e0d764ff395c7c823b0016bcdd8a658644ce1184d776d70abfb70c79f611af31ca92d9aeed30a9298e6518eb8c7f91e29813ec4f18820dbc41c9935951300d901bdb6d313cc04909fd6d51add7b4de27ff52cc5fc95cfccac619dae3937bbfdf5206e3e30e42a85172f2375aed1aecc612e3b37b11e9f4c4264a63a10d229c217c80e52dca10b0dde24d2acae046395bb5601aac6ee725b3666d1b80a36002516e000ef41f86367f4b4631634d9c2a00a0a9336e8d75f2430927418b617035905c58e46bf1724bbb7735617e4856a2eb3134615994431a03640c69823bf5af7505a3cbcc350d17373ae9c4154217e1eb9063ab9080d4ed65deac901a6bca42c28c5631fb478e0c0e5a52e0047b7dee6db12130d6f8a4ce880e9c7adb488be4224213e69591c9ac07d071d21e9bb63b93e19704dc69ab438ac98ed5221374036e7247eed6bf3305375acd4b720aef8ef9f77c7ac12649c04a0f26f0522d8f54f0aa1c02ed2ca160da125e5fda2827589261db505145ba3a8be6e4048fdc3acf5dd016ec829d735e2b9e2734a04d9459f497085ee603d302e40783e8f62eaceebeca4e185fc01750e3b3bf9fc6bf1a83db5e1064febcb504dbc5a1119feecc61f17f1ab0757165419b29b5ee0526dfd2787ac19b86336cc4b0fa0e67774b81360c72eab01e858e8983d5cddb2f3d6bda954492c4fe3ba14d77f37110ac5a0100200ceb36e906014fa0dcda8c0608f8f6138aac55e2fa4ddd6cd826c66eb963068756e3172806531dd04e11021fdc027075e169406a7a2dd136c697aa4c9e93e2f060f3eb02bd798ea4bfb663fd22675eac6b148062214de72360d1d48a01a096f1596e02706e96000e031439da507d70380ba8bcc3eebdd733cdcf90c8a6cadc25704f5b9ca972398fec68dcd549b07587a0efee23ea8f09d9b5718e7800ded4af6e6fb707af655ee173de11ed71ee7104bfc9c902209620a2e3c14fe87e3d6877290386255ce317867eb522d8ec7b2debe7a346f60541ea9f7894009d6a426606f78b544b4d2e37d4a4397e1bb10a853b4133a5556cc710bda8bcb38d4d4ceee10ee2649f1deb260d3383b80a2a81dfe1d54db1c63644bccff3336f0c15810ad7d67a06c8b1bd519827433033c2e5e90cc88c6939d3973de67e7930c631eafcad386e004286bb71d9e6132816d0dcd4da0467795cdc3c5dc7797e9e378f3d08bca3fd77651f3bf47f65e3108946b7ee5c00b316a5c7a6cd69fd1fa28f84c67a8870e9b787b9d573b832ada21f9bf0aa0862b2f915ea797f90f65e1e80029101e5a069d0e734b55f13df3c56f2760ad9eba8430b8985dd7a39701593541784f9b6fcd40ada395af54897f6a16b21d4c23579a32ff0fba99de2f2eda15e50af2e17deb2b29061705c67db37c3efa702497fb23f03aad9d2cb868ae5070a7c4f551b91e0ad4741fb2364f3a2a69fe6403a19228de38f667379b5db94628536965217f7ae1fedd38a16198bae7b462a12da92609b06edd41c629bf9690e8f5dbb118a7c32b6709a5a8010b60fc4105930da0ed8fdbecd96758e0523ef35df6f90b4e0415aa497ec6ff4b16c439e98c266861d998f31ebed8d04a2af052fd14ff0a316996443e7f580d4eb59938114850948de228e9a94640db61b45d236510b3e2194053d52548aaceb41992551f71d9d7dad613ecd098728873fbcbd11a0b48e87f0345a696ff33de9ed7fe08365aac581f6497db52bf16e1e5d8ce59e1f54190174fce08e2fbb98c9ad1af840674adac8e85d80f53c5c211460504ae1f1c26682cd05a1410f22bcb9fd1621c2507e3579356480289a3ac352d7dc4a0ee52654868cf7b2e80266697e1fb8044104d976ffaed4c3cd453644a6eee87fb0289fb0926b59e1009d9952c29775462f67214153ae52b492f55b2b5808068411e9bd9b09070d85333af42ea36ccdde3b67354f8c0f13c431d080998345d31f0a37e13450d076b28eaa9fd9d04be1a6a0c446f527d23b4d4cdaec477f01ed98ece488dc0691d5ff5da677b0f166ff641b8fd9a70f2521a4dc5148bec47582197dd44abc7661fe48180e61320bf2592a6145a65996f68ad596f9250fe856b97829688315632e69753fafc508534865e9207d76f1da2a808383bc36a447da1ac065f35aab76fa5d8f7f30484f981aa0789f80183accdcba3aa00c149d7784ad669a66226308254b6ff172fb88c8a3bbbba1f789a7fb86cf2ed31dc95aee5c2fdf382c6a2717643f643c8a9b804c30cb565083898e95733fd9344cd65b813260468657b40795992fd045badb5948161adc23d6e9602993956dbf3084cd350b2427a7b56cef4abb81b5b22dde1443d931e888c79d282a08f75de9ec9845469fda5b1656298c29caadeba2b58ce67fab1be04d721876445b6bf1dc32fb2e7fad18da44c536b19d91b0a1dee5c0fc28f4a71d5d783544ca0c32c9102e9712c964031a2656855f3f43379ce331c6faaa8976021c3165063af3adffc32bf54ab7f5a3c1b970cbac14fdaaa7556232ad49152197f3867a1f45e0f1fdd559d022bee6fbcc28fc1cd7023b8de79b18ffe84c7fed94a60562fd90e0c8a247f923e5d4013f3680faefc0bf3d6cf2209fba138529a3f10b9da0d08c010734718076eac81af1dab8ba1bbc79fdf3bd6a79906a6e9c3e405196ebf485b1612780853dda91140e1d7a0140f2043105c5b6816cb2b9f8edf538691b9c5a0d5a35d0e86928d2316dfd59a873b53cb0688fc91bcc6e3a610b5960112ce54c3eac222d03677e466ef4f81d8a4d41733e2650d0eaa08a573df93176a09447e1946fd329dcb9945ef14722fc7819e5bf8deb08d421a929bff3890c9cacddf885ebf491e3bbc5c4f2359b77213422d82283721e0fdbf7749458a9becc336da4fc66120263b6a6a075d6d6a392aad43473ecb4b0be30546a6c0de4e9bb01397906dcb7bc838386be94b59781a642bf49885e23c417679bfd7c81a6db98d04641841d3bfc28cf43f4746099aac19b7f0b8a8094fbf4e0b557abe22fe6f8a5b4188ff8316b141fe8ffa43b0b180fb82e6508acd3df50810df9686031212b184a8eef358d4b717456756718e3d48ce7de5de4cf626224f8efacfb77f2841991b00333602ac26bc86036ba3ec22d4d1c5659314d9a670937c2f476486ffc9559478d7d17e7885e60514f696a79f2c833d964c9c5db9cb0fe8eb55a8fa5c7c6663e9af4e1f91b502fdfdb4997a473ef41647d930922b4ec3f47b982a034f94cf31910f98919715fd9e791772be2042e2547fe212b9d3ab847a93c8791b49d542d28052564835ccd71946c173977576980b015480445a9c58444df2536a65be21c890ffb8fc8f8123a8193f0c278e5f051527bc9c1449d06d517e183b08a4f18acc8985b8713bec377e7ef42aa26807b11f92856e1b609e38625d492352f276db3003b8ae2ed919e08bb252419e8c383d02c7a142004ab1a33cda672b2a9ee3aaab54c7685218856d1138f46c57fb3c137cb65b0e91b36c2140b8dc69c231a144b655d4da661cd52f30190ebbe6331486e91471783751a690f2cafac356785d8c54c9171c06ef7cb3fc08eafd38ad6d70ca044b71722232b338c4974be4bbd233d51a1c9cbcc79ce76b68806cc36577e4ab54664ced8ab3ad7c16125060f21acd4439f8c59bc8a90da9e69085e5a59306de1212c8cb78c7ade0ca79fb9e9b81f0cf33bc28652a6d3505abe6eab0ef74df330932a9d944fd9d3875607cbe0c7b14a892422a0b30703e9b5106e68112170a5364bda1cc123ca2066db5eace6880970c49072c793f0c5cad3f44fa9dfb187960ba4c79e8123e05aac8676fd2bbbf028148e79be2a26390a0657753fb6f49b44b16df0f396b93b64d571bfff2b5e2df60f219d6269a5081dc397bab693282cae6bd0409ed05b5fc8e1e7ec935bea2a645bb80df5b34fd03a40bc73dbd074522bd68b4002e41c7a7fa7d9296a3c999b345373406dd82e25b222bb70d7ffbca489965b618e6b5376cca2bc307e2d9c3555dc5c36f6b8187e4bc64325143b4859c48b2624174ba1ea07425aa31a5d92983d0be586b181f29af9abb6a748c1d851d11d6bfc6f72a3734cd50f6070f9dcd922a0231dd0982f805d3fb583726f85d0e4a5ae840df79ceb21ab359cce0783fa8fa1482529a8c3c0c815abace00a179c32c7f85b18ef3f70077a2d655d84e9311355845ab798c67ac4c7e6d3f83bfc6ab3c4351091745b5b300fbeedccdea80b06c585f693463f69012ea4795cb7ddd5fe1337dd693aaddcdfcc0ab97a3ec730603781cddec926ed323ef116ee56743f3c2cd9e85e074d59c8719915a0028e957d568aaa614888e42daf74b076f7c250b975ab094da32caa64ba3d1ff62c6e4ab94ce3262e4118999c73b7172fa96867526ba4ccab6fbbed78c230ebb35b81c7e622373f2c2232641a277c2c1e9be0b177cc79332e1d97521ffb2baaa26185519c96dce854d0a1e4d833f7463a71457dc43de074d0fca7f31dc7f5a0d46ed4fcbd5f7b400d245dd4db4bda049119d733a745d2654c5436a15b46d0f3256c45b029fadf887468ce6afb1452d2e2d13760123e81a2690b2dcca1a5cef5c1656c2eedabf30dfa2fc5f3659f967bef931f91ac419ceec1d4fce1c007b9a6a85f6dad100ad92bed28b53d6223895219e7fc49c0252decfd6cf7ce0e94e5ebf2a8cae9efaebc8a242d567c03b3ee9eb02403cdca03127d25a9855c2241ea37be3a9dc5d06feaafce9e1178dac4550eaaff5841481e7366fabfdadb2b3ac57ccb99465d17ae5d042fd4c287e483830abc227ab93598feea629f8890865ba31306460d091e504bb600925b2f1751d575a40e51304674a4ce46c010798c8442ac259fb5f76dfe32ce4993fcf0cb3f213b496b255832b149953658b7bddb9fcdc869f0f17fd98d29ce78ba5acb671805616c51411746f4ec9b1dce029806487e8ffb3dbe33eaf2158169a9dac88b736d6e51032c219e171e352f8a60b5e135853d101fe7ad47cf681d65537ea03c73e80d68c0c444d5c8b322cc3d4d6b9e5d3867394154ddba1b3e0bac1144c2aa26f9f4c9f76ae2a408b4ce362af75093b396a5912a801c091c4dcb52e85d933ca939cfbf417dbcaccf7bad1726f8ae367ebc074f4731f7eab7b4c7829bc43582cc0128b8e352bb53b5a8b34a1b2b91bf39ad2ac25b05615bf73fe4a4a1d6386d108b83d9ac9141770d808ff527eddb6fddaf31149261f34276f3dc9d3afcb0fd898a128934fc839b6eb32a70a889021bf6c8bcc806c6b9155c185afa656995d70dd318e83ba8819a6a4c4709aeb86c3ff02459f0d891f00f80e24be69e24a16a2794530e50d8bad914ef79cfeeec3ee950fd11e4bb6164e60f3dcb1608c60b88cf62e4957d72ba47a66a50219322d78db9b895a0f70ff53c815a9fea7d93c331a2ccd12118a26cc931b9813e4536adb0ad86966c02831c4b1c3c87d4603f10488e79c600e51376382c9e72edfcc364033f2bff9c2a2bf44d4dff616ede72da051a40668b1c2dd4a24d63d8a1706b29137b12f0c1b40b17f4caeaa74637c7d998866727549b3297272b8cef86d2c3dfb82b58a6f96899a924fdc978313c30a4cce26bd13f44b7f8af77c04cbd9c4de7603ea0f0686dfe124e45326d06acb9fd73308062510b715c1e58aeaa5c8a82da0ab3d479c63315a1c767ef76f711f6a90d72cee4bbf102a5ab47203d3d86454b88db9b616a82a467a52db286f4e7574e931a05cce12a03f964e82d861533e6f34de0f9726efbab99fa06a198524974d8e6c140ddbddbe809b4efdce1c4a7e86ff7e5d85d66ab477841a088c000f621b24ce485b7d5c84a3e40c63e2ca228e7c3696f98e0fba896b70cce003d74775736ddb44a09063a4afa31291774dfde24aea37e07a546b0420eb86347403bd5565c44e1c41bd3f278a7a5612224855de3fc7a234589efec7d4a54c2d59e40614ae1dd23187a21dad61e201e31cfd977f153b60dddde6e9a2c6d7afe13264d8d3d671c455f8ae7f2b173984f8a8e159258014c8a9a60b69b04625f104b3a8f33af67762f415d647d4c81d442beac10a093b76fe18b04bb570fbbbee217e0714f9023107cd5046752b937e3e86116bf62a1e9c2995df04f096a3736d24ee9936465152696acf8e93f87a3a07267771ee45bcc153fcfbff5089a1446fef78e16716a096b058d4c8ae9fa07dca7bb69937df30ffdcfdf320b5c69b253013c0a071d82b34f68da6809e364d90f7921babaf64f60ff79a58ce20dc1f81a3f02c1466d45f428cd2d6dce2266651635e0c8607a17d6b33d473ab3675b94443315df85045dc6ab28abb4432bf71e993f8af8f9d2736138b1284dd5496685c84f39613eb95aa4145bfe4e6f7b065296fbf3690ef15577b7930a60313b5e6d2fc6a55e633bb139751158655305ee1d2d3639579e9fe044c8372676d196bae40ad075b44f8b3e2afff7b7971c72d42618560adf29df3e64b9a8bb90a2e937d21094f97d3755c52ec1a8e3f038b0e0d43c893007e45daed23a65d04314fb2748b52e8911dc4c421cff9aaad50425626ef4d45e7786930f1dd9e2a7aea04b5f9c071a24a98c882ba4ae42cbd90141af21ea64e9b250338f4e64bd244be0a56abd364c969e7fda761396c0c960dfe2d9c50bc5b4352b33092b033eb3e1a429d4f0469497c2317edb50eb870aea391ab9c22443aab17f5f4410a19e4c9586fca0506ac8b5eeeebc467490168ca04087733c62947064ed3f42ac51340c35160941cd4ce648352966f8d98eae422e38d783cb9ad8d00e415716ccbeff89f8a771184d28bfd6496c43132f9726a0ae4115511af38d4cc840027e3f2699844e859d9c9ece9f609ec4283154d972d34713c6211008fcb1face0cafcd0d1c61a390afd81d2f465dc99a131c4b5520d837b85156bbd89499e9b475b5f68d8c88db46403130c92920a2baf039bc0b64bcd2cf6442b8423f78ec23fd08a042ddc718dc5545fc668d296c36c9ec370c5999622d7fd48128b577a3485844809a95692f9c9a31ce1bc83c76c9435f19f424c11960e2d408325aae3a0fed53740bd9e38a0fcb797a79e9bbec3a87dd3b2c526890e5db39441e401c646fe6876ade5dadf944e3d20c1823dbbfc91265bcc5fca8206586bebb32c8ab301955f908df13480c0f6cb06b96d316ee3c198dc4dea205c4ff09d97e7828913f7a3d75e25b074c872588397127aed35cc15e6fc62e7b5a75fa868b715e04afdcc031e3dfc23fe253737d3b942396437d7209fcf9f715a3cd4452a7fe1387fcbc4041adcf684592d3e5739c9cb2ccb28534794def2ae01c271eb3b62061485faa16326cbde89f6aedc6cc76399f93b2a97c92916a6b3f9051e16881d32c40d2543c214933233dd1d9d2f2e6ff44c67ecd4ffa35c40ea5c4cf808f63a83bd7884b6f09a9d1ac014ab73018ddf89b11a52a15119de33b00b82b8f5cf90583059130fcb8c398acdc17fa53295f35444a6b404c65c91bb7c2effef865d9a08750ec228a5b1bb16e2a7a6762fdc0d7234eb3b9e7a6119593e0c70b06adcc15d9f60a447d4e1e160c68132d7556ae283cb0c2fea9cd83a66c3aeb64efc5b27744de23f016afb2d9ef70fa4f44deb259f75f84ab2a34d867616a74cc5449dda4ea4497cd6ca86ddf1e1a09ea06e4101961117cd10e576897770a9ae2179af59b794e95dc9948f3c8924c257252e612d3fb4ae60d90a3c9572e8f04b0b96cfc25ca40c5ce4b9bdbd9ad13c1bbfbf15356b93ad280282eeb1592cc8453691b4643bd14c55bfce0d10e296183e885244ddb4484f53cb5f1cd8fed208d841c889a25e2b8b09d9f6e814d1b3dd61770b60e66056d72191bd3f751c24a628513755b2e365b46aa37532e012c21806bc642ba2c3aa41e44eeee54f1ba73ae7d404afedfa1c4f5ce86505c5e3db31022f413b3ec5ad62f0c4d9229c5ac9478202f6045af81c3fa624f8e550f83706e5ed1fff880decd825db63effce3747d856317609866e21708dcdf6eecd3d6c7f7ccbff8728a2e41aee1412b5547680fb2bc6a8838e8e0fdf0101a81f5cf2cc039c57e981b5ac308878131a904fd2db472aedda777da451f0160aba3d45307d6b00499c0e0eed8398fe18271cab08fb6e282cea6d02c8e898e88bd38e5e3bd4e04cd8176083770addb53c61fb716fba6aff37a9830db18233791c24a7a9b7dd141f43d1266c195f0e5f6b6f2b5e94a2c09ace40d4a79b7ddab4bd2b809902154504c4dbdaa5c5c7cdbdde5d1ed12044aca1e9cd6da5402f5af22b8ffd4a41c32cbf2e8d1731d26e610d0b50b55eba81cc1f5a75501db998798a831a73cb866284394c232ff6dc31df410b51cc6e569ef5be7d0626e2603d9836720a745c18fdba029e2a20f1477780fae66ce4f69ad6c2b7eb047f0dfc3b26ee19969c5abdd533367553673f7df27ea97e105f5e6ea221f9820efed74a8711d2ce4b8f566f2f3ac8277118ef9bc026b446fb40eba28185b5ce686f3b6ca4ffe954b180973a3ba8cd92108532c5954f55a293f6dba7d0bacffd2d62ca3beb7ab47e25e3076bdbb2578b9097d1e5f9ed3de036d87cc503cc43b195162ee832fb3c356b2d7b95ac37cdaa96dc2e2912eeb8aa3b7a2c1b84a10b1d7a888d906d95839580bf06888019dc2756341bfa86ad25deb0849ac3b1aad12782189aae79e03adc2e202f16c98010c8074bc20d6882d33b0030c22b4e5441a8d54ec7ba98a1065af60512a2ac132e7fa20d022c5a8375d07eadcd8166bfc9879c070db1807b7358755fdc59a0f40f68fdcd231134f88cc7e73942249ca28d7919f574306afedd0859c7766ca460b31bd052da99e3a181ba9c896685d7675786477473ef83c3c5b90cdb97cf2bbc26f2466ccafa97d198b18fd1bc149a4ca2836cdde75189d53f5f19cd8f5e59e84e1e42ad0e53aea8205d6e1e25d13f819d7f325aaedbb0d0cb9d071263abdb0fb131957210739c8d9fb68028205190ad214eeb43dec675297320d6ef7b2c848296357a9cc11a95244e1471e5b02d80d9640d64b21c7585c3bb409d096c427e828cfff863c8d402d2ed55d0b0f46a8fb00eade543d7b79dae23f7b61aa371bf27d1218f5715994c2b7bd4cbadd2d90f9d1e30428f62595dda408fcd8332ab6a6f9379edae86221912995192c20c4e54f7b8470ed2c3e4013ac5addb08bf2ca48c97f4cdefa816cb0f90bdf7d5dcb8b8144053f45b0bddec5dd58a7b5ab18d476968a6d73888ed37d6c51c6f60253c1cce2908b3130dd1502d7a6a2695f5bcdcac71039958f89f9cc814682d5ec4b20acdebaa44e7852cf3562d0909f8f7d3e4b42a83d38b975ced08fc56e1e6422e032605c40cf1a0d93fd9e47f49f1499619dce3b1cdb48790cb2d91880e81dd025d27d075aef3a4fced38bd15752c2341266b406e3dd38f4aad3067367258b887012526ace197901060057af23f8a264ea99c342d2ed1048764ac7428b2df44fab4a7c5846928935227d643ae5539d814673b7ba5455db2a681adc036e2461b95aeea634f7ea27f0e9536c9baf7df4205fd17d1f91fc461e1f1c45a7ed0a1e7eb9675357c0734098f7be6592e4edf21ef1cc4e47e508c58a4e3e39f9a0f79e99fa382daf7484c80da3d9c3afacc6cd1e392ad89e96336259bd51f9bf67c7e82ac4109b9e46fef39c87cf94a4276f74fbd6c27bfc75a2fbe1b5f893e1bf91288d4149b26ce0c969e5fca5a17057fa729dd733a48756773973ff49caa01225528a6f0ea55cc61e4c003a4cb0ff94c21ac3113acca8ff4e91847cf33238c402745aceb6b8cb16496b4d9c5a6cda7153ebeffd1d1c12d5044fe9f17372be07f2f681ae054963b5141b85e5c835aebd34852ddbeb22661d99ce5e03babd3f66b408831389ee11fe28004b79696a46a28df54427ae036c907b83e21e5ab1019b463d2e1eb6aab2f2af4a1175ad47ece5b439cbdfbf52e3e7afa135df5cc6e3ee7bac22cb7f7976909145d3aa3cc10f9915744f8cf83182de0a8825252eb23a6768ca89343a43cd9e68b37b6ec90f363c99a6533fb7818b83755806be32dc3537ef3c673923c2c869fc20a61c73d92e1c9d2d64a383d579a679f3b24ee3d4e884620696d3a4a51d2802628e9da81bed1e3af87b7a276e8353ba38f8560f08e857f7552913e92983d93de5306fe5601b21dedcbbee40ac99dcfb496a51e240ef369410c51e0f3e7aa622c00992ac5413603086ac84ae5fa5e42a054acb915545463a741f51cc9917343e9b01c2c09e8efd99383a2ca1a74474bd95a5270561a0312e9a859db2a90eeb52f942c4eab6221852c3109d11dd3d8ee2a779093c59f4aec7ec6d7cfadd7204d1eb22e3d3e54f258d40241afd24e158fca298399a9ae5d2a5b445d3fb0dfddd6c91d18e18176353c840c34f6079663b451e2a4f4b4bdd89c11b111bc3f2a3cd14dd92e25fbd1dee80556553c48c9e6a1c917eb029009c23bb6f66c377117a743cf223d9f6dfbcdcf4556302f2aaaedc3908567f6882866f80d6e8b8000d5d113c61218ddd0f2ec88828dd616cdc071fdebf0b82cff06eae54b42222ffe58bd0cf5f901fb698df7b09c331dcec8919de7bffaf01b284cb506b3a9308c91c9597c38f6ff15fcba234582ad7588671e65461666b32d1bfa6e99789c4e1c2601514ce98f0ab6dc005861a46e7ab4d718cf0f921f60726d1cf6df2942cedce9dd73fcc26724b0822bb0083eaaa5f4685fe318cb56b9d8f3300984dc5939527a2a6e87d9cb597727a4e95b54250486133989867fe520100601f30868eb3b9f834d604eb2f85910146d777045783a6e0324e7cf4c8d2516c5fe6b29365dd09f12d2ff5a06594504da7d8c6be0fd35dc7e8880eeaef9a499e7cf618621e6b4de9d25804484000b033b3f8f039ee99a6d6e40e325673a3c4630ad042d981d09e8a90f35d0b38251f0b1ae3f3003e303b32c2510b9551805b9040f052a68a2b17f70db0be6404613aa47b0d4ea2b683c7857d4cb35f599db703518422eb7090e13d197c83b7e5fd58b2e7aa13b30f57e92699297a5e59cf289a614763b86e0e410d63ee3055aa793ed15d28128ff53ffb5df8b20184a2098d95aa9dc46a1d7a9b3be750e5fbc3d16bee84e82ec0447a66248e46705209ce4a93f90eb8c7901ad38e74f8c4b6dfb370f94c59b17d3ff811b32362813c461d1a035ef892481dc87f5d6488db79335ee6784ad8da3ac4c8fb8cebed3b2e96e817660350d0bdaf98001c23596106e14b0ca4a9f22d24eddda54ee02d2d646f3772dda818482735a8be78a60b927e240194efa8da4127e991852798195fe8b0cecc8d43fa16c1b5cc737dedf98731cd63139ea59b2141b4fb4fb628385fe8d169e365afd7c6edbe933e3b925c806e102d967258187b546dc61a118c46c41fe8dd847dec1baf58ba4a1eee016c6eb3a7b4d7784931f24700a8b1e429bd93fdd037e39dcad306e8a44624a7cfedb230418f10a6ebb1b6d30bedeb16e71f33d103f4309d5d0eb2c1186404105cdc45e40b01e1f6fd1e7e4b6e8bef9f8a21243de67fc5529f79e8abd121fa263d8221f9fb0ece0ea9de122e11f956c6e61fd0dbd3a039c7da44cd4e0970bb3804e479034b283ca2fd90b904a7e2e8a9835659b8bf20fbc8d77402e9a54198dda6304352f0edccbcdb18d8042844cdd7aab98043600386ef34cb4fe8299876fbc604cb0d2058e54abd826aeba50e7ac21e75717fcc38bb0c2e187bf09a8c5797bd8ed395ff01d24ac7c78bc444e994f97254692f6130ec8af786a508ff2b215f76e78e164ec3654177b3d77e80d7bdf9aba822123a0af703f4a9f82d93511b5151f792a77da4073c2e2ab3a75a52f0de6d59c4baafdfe5f4af62f922fc98db4d7bbfeb12a650a356a63b0995ba30af31018aaee9f59519410c43faa7be2dce26d21ffd837155ad1428bdda4f17d81c6152a0212a743572f734aa6bd8d36696b8b16fe90e9ed30b93326154d051303b30023cc79cfb9a47f908ffabc6cd71110a590ceff3b5d50443dd08e18995c0c723cdc9ea0538ea113aa255f6bffecc06d581625dfeedbe3a504cf9449a1c6fb6078ffc4010e44c21ed3be653132a42ad317db83195f745ebdaca1c848404e368a774288398fa4709cdee128102021d510c6d2bf08b2b0cce22f47ce02f66ff54ffc3d0fe77317e773e57a808307ff6fe7b5da782750ab5b63996309081dd90e2290762b7d1141b24bd6fb44af258f6318cb6bea0037580804d852664d4c94da77549d0d62cea3b409dd9e34a450d1b1701db345dd102d231e5ff53f0acde51b8f9355b1a27016b9d0e145063843bd92c7c3909d11c4b06450532ad24a0fa45aba27389b3dd432531f2517f707bb5e9ddf87e2be8814e643f7a581a3df4a7444ba19f8ce8c47d954176c7d38d61bbb6c191738d85d29694a5c5db6fb12737b8325822be935aa736b8528c9dafd4213b741d4df484202586f886adf1b0689c6d3bdaa3712646fce1f5bc5c30896d81408808fc6cdbd98732a3af12948aa901c80fc164e9dceaa9c8eade2dda599da3f1abb84547b2487b4e08af97ee70a4437bc3013006e89d262c2a4fc8ff3e8c916e1581f5153f88cb090260a3c070124cd94f513aee666f89338d7581b644d4d4212cc490d5d5406c470cc3d67f3991c38b91a7c0664034344771c033b56122c632fb54bf12207ac6d6265c2fb3596748d1e999e0fac0f431ffe1031a6d57b94bbe474bff7d34e77931b8181fe25a3b540d4f94b5918bcac291d77bb2386340ed30bafcc74ea5c1aee1420dce7d60c2e85e463be0562b202502a5d885918d6b384f469d306ef7d6e697f3e3a3b53384e7925ea99bfee5760c23aebae9ae8a0891589be1d8fde26e441a6660164acc59a2fd2595b0e2c5cfd738f6c9df600c91dabed83ec49165f8605094eaaec892c505267782378c910b71c8a13d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">当前文章暂不对外可见，请输入密码后查看！</span>      </label>    </div>  </div></div><script data-pjax src="/blog/lib/hbe.js"></script><link href="/blog/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> private </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计组学习笔记(2)：运算方法与运算器Ⅰ</title>
      <link href="/blog/2025/03/13/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8%E2%85%A0/"/>
      <url>/blog/2025/03/13/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8%E2%85%A0/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="5d8d5daef4f2eec85af30c8997927951fde6cb50b6bf3bb30107fe4ae56be81c">6df07e4654b2f23296fe416e73f530c96bf04cf67b3d4ddcef59c681cd714fa3226f7618aacf669b22c1353d988b457a2de800de3cee026b1204322a8dcefa527b95d28332fc671a2de990a8b12d64dde13f251e6aa15af8d7f61fec73bc47ef363131a03c8b2e736890335c77b731c54c4ef8c40b092dec872980376c750cb80b505f3dd74028020adf20a40ea27928266e56d8375383786ebc684c0e8446c032705dedb87ee7296f7d18c22f158e0ce46c4277b85e5c5d11ca1d1d0518d44fe2825adc3255acc0ac34c187e53d46ec1d9116e6d65f83b99a5d7537f8617e263b3707a58b248b8999f9a0dfa2c4ef3401590e07083e01129fde6324b872407008b981dfef7364025bcf367b7ed8fade2e59817bbbd78053c9b75962da3d90489afa79417dc5479af480cf1a771c01bf9293e78130c55bad60021d1ce254ded9f826dda827f68ffc549c4e3259fbdcbf8081dbbef785069511d45ab7df62a7c68e1557b4d7db7475409189854639d5aa753bc215972f5488e452ca8bbcc8cb30bef818c1338ff5f05bf49ce743a4f585a98eba8042a7adb787b55e893bc2b0e6ebf9383e80d1deb6728a1731d2d1e289d00797204a87280ea35f573b62786188332f6a48a98f03b7214986208276e90cb36fa98b747f67cd4b11ddb52c8ec216792dc816689794d776452dff659256bdfef0c0de59cce5459e066d276c498cf475a239d79cecfeddbe7cc93628357e6a62b3b38c25f3bbd51c3398b3afd5dd5326996ae7c988f650f6462effe372cd41c1ab3ae60cebc4c2b392ff5153f2a752c41ec31c13325cd640ad8f3438ffca99e118112d577711dbe577c3277348e7cc54425e2d66987583e5094c16c91e9c767bd4e6c2f5b9366d4a7307738df24d69334efe7eef42872cd6a4b0e10432054ada6920595662a30b23635f24e5c30483247a5dfa4666173b238827c64d202f6377972a23bd42cb8bc021bdaac0fb6b57116b2d8d6d27f62c135935ecf537c3e3084a0fd9cbf615a8f3d30a456e14c85a4a5f09c3623c6e7050650bbe2a3d767b147799afdd91df63c81b53dfd177ca86c9c16fb9cc44333794cc06b343fd6bb4d416e72b6f1d80e4e708a82f3d46c89bfa5b5811b936e7f321bd73096c87af4dbf0a8c09c4196794cc1860b62868ab0dd73a1fb5ad4573fffc35cf3f3bf57692f6e0ade8d9fa4f372617582f936502d030172b163a560f99f0048098a016627774e53262a85a35888868f2c509fee190b349ca02db1dfb401b2b414f1dbd09646f2d8ce155d18178a1326b24afcd237847d33fc4b1f2228b95fc0348e0208735456119ce89beefb74668121691254f6988aeae012082526e9aa8f3fc4cd0c46a0acf6db2392af2cd8c201e39c82f967e9417199f50f4ec8fe4c85b7187fde0bec02f4f7fe0b4d1b0cebf8a8ad0b99fbd0a41ed4be3721776b4735bcf00ea43a36451b2df6626efb9ca6240740acf72e146c761cfbca5a62101d359831125ae12e349137835c31730bb985e16530d5eb952ea71a21744f05a4c48f5e1594f0acbb194bcb3c9f5617a51a7ba712a874bad79f24c023a05e421e8f97311b1176e6909f392c3653b0d66c444e4f04322736ffcd2212fae4a9e750b700595970579dea8e453a6d81dbecb9c2092e8206ebe73b8684164633e761e6d60023e6438c8b0a27f700562b7763f21a0ccf74b29880e1705050a09b722374635596b193c22b61dd61aa26f5c11693d85312fa1be8bc811dc60651f637a57bc519b5c823e37acbc31c6d22cddee05d17406c0bd0116471348baec68243533aab8a9baa7d7dcc2488384247aaa2de6e1f5b49cf05a2b4f83fbf38da23167bad49e552222fb3c20848492d38966a0c09138c8d6b9452522b48b2ce2fe73ae77e94e6a65b3f607a0faf8462e52a7a4ca91ecce24a3835be3f65864e384dbdb6ab82d83fe2e339b5ccd48f27468a3842eebdde9d98ce1d43b5d0052a25f4e023c11783c4516cb4ffac0b6ad943a86958dfbe073fda9ac06a53f9bd11eea7ce66df1aeced5d7d3eb975c15bee6189651e6b2ddb079d1e5c501722654d20172900d3202b4b67f0d5bb3af595fe95b6686c45ba8994c36fdbcd2266f76aa1104404ccd35e0a51f7d75f895664208163971795bfa96c31200c089f6aac1d06ca5fe23e4e16eaa8b4e1548a1cf735ea815f801403fd36d41c7c3e18f205466160a6c545ef78769993f0e7c2320789194f56752a69f3d8222a572af159ff539a62db4ed59942125ba7b1c88ca23a223d043e38c0137b1307cf7f330bbe97e5a24b4f8505c023acf8feae55d1edbf38d550afa1fda023defe0a5c258bb9930a46f8ba663aa3c5da98091e0b54734c2d46ab43dfb2f4874adbd4a431e622a04a362edbf4445beeba7bfc828071a440c2c2e6b11debcae033fda2c53881b3acc71bf59e1965081b41956ccf20b7af71ca8eea70eb76dd4f8d4a61a1368a10613010880254b29eb5e69fc6c6c299ae8b435923aa4b01f1aefa4522e10ff53421168125510f0cd4cb9f264c3380217a0148dc8c8f4a5a3b57bd147ac8626e3c26dfb4a15a860b870a54fa755ddb6f0c363b1e26d9c6b063712b2e088eeef</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">当前文章暂不对外可见，请输入密码后查看！</span>      </label>    </div>  </div></div><script data-pjax src="/blog/lib/hbe.js"></script><link href="/blog/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> private </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网学习笔记(2)：物理层</title>
      <link href="/blog/2025/03/07/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/"/>
      <url>/blog/2025/03/07/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="5af6dc3c56f12aa010f987c89bfcfa29979baf88e383f9893b6bbfe9fcc73800">6df07e4654b2f23296fe416e73f530c96bf04cf67b3d4ddcef59c681cd714fa38cb0a79eef6682675ecb2d4ed9d3011d6940c16490020a3160225230af525ef9f42d7221f825c486a1481b296b89994425bab4636b56ef3efcb46666ffbec05245ec8ce72bc3f4c2f6e06ad49e018d7122a77db90ef4a456d8254fde8893d67f43be24e9d0741d3e5acf95298e87c64978377b5224f236e6a924ac869eb01952dad49fc78154a15657f9a614cdc57edfeb70b19c14ca8b793a365b346485028ea005ba37a0845d3721ae0ebeae3550daf8ed8ed378c071de9f794741eb9a764558a2f167009b36dc3bcf8757ffd08a227949d8d0221bef908171b5f815faf7d74edbad803334a2dd3084b70fdaff6446ee00a1ce91677605aa0f03db449155cbf08e1585ecfbe41c7228d0edb49963e8c5237db5899f5e2bd0f45d48cb2f6e7e677929a1b7408135f2d1595a2fdf103809545621e25784c63975a82a308a2c278c68260464b1aedd22b4abcd956033cb135ff2e3f5e76460fc51f0628393a1e53a051ebbef192572b2e58db735d65c0cf1c04362c5bd1543420c369e940be97ad036fa0a058fd3b9e82990d5feb4310719c89766769ac71844744db50d1b66f6aa4574cfd2bc9c3a01b6d8c70fede9d52dd5bb6c2d1099c69d5a75d43ef2d7d11b023842b6e7b7d9e2ac20a57909dd21a7864cf05768947c45cac9400b7db587152499894953b89b928334cc51f920961beece4d369ebdf561739db6ec35933ba43afd27046f37aff5cad08090cc18f90f170374005856b18d3fb978d8672b4fabdbd05a52c2a6c97bc66db3301a1f0386a94358124ed731f183eee9d191734a13f2c98ef0622d21c7a1f3dccabb2f30121a228709d74cb3586978a319f9469bf364e81ab69e8ef05bf8aaa1d86c5c0808edd6f01168d410e1625cedb93213083cf432e81e023884277a6d83aaa872e6fbea435e880306c1705fe19aee8d38dc3cec812623f31c655b34ec5a0a4dfa28700a35bf170d280b13b30b5a46fddb3eccb307c4447f28f804caca2b8352dffd76d4e0c2641227ff94a4e96daeda579f52735eab618dcf2f2cb73e8c9b051326bb10afe11156cb6f469acf2ab04f925a712ddcffe9c0f3f38bee1ef67c802688cf6cfba9f32c66e8abed405015c32228c8536b7fcc62a2cd60ee10017463515e8b8b0a58932c64ed5d0662fbf76002a001a040deeb0d2a6d4a52e3fdd46f4c4d1d6efad5a5ae929f1fb475e0d0e1c6772d4164e9e824adbce07112ca71524223924355035b82e11c9b87270cc9519a4965f24e7afe46d034ad32d28be1b928e6715d680b5a4d88586606dfb83489046c689acbc151a4576e14939f3ac8ea81f17605391c9b2ba75119acc7d45647b41b141116584e0018168d6a32ae07fafe1d7fbbc3860408eb4267666d6a2e27585ba0e90253763f958b41b5e300c8080282e3a30eadf90c46c4942f3fb0bfabb86fcbe8bfef19435e0ba4de51b18bfd48aa27ff46d5c4cdf06c53cd5654e108a7f64922327256e2c9f2b3de5101163cc74561f87a75c8dcc475d01c3eb1ea3819b1b2b08cae65b12cc6b958cfff0d35155643fc91bd33f1db17c7ee6730b1e9ea8dd7cbf280299aa95f696f43751ab3563180a1131c8ba391854f21d7e9975f3ccd3c06cabde4ccca17e813dc43d545a48081c2e8435bb011f68a2299e990e684be43d51c290435fcf611a3030c9b1293e64d264b3a3ee20252b583e484a4f0dc7e77529cc74615ce3e53c40e73d129073226d4d5ea9c2a197997a4fdac51a0284c025c972274a98cd03c709dcc0aa5bdadf2802050abfc59602dd243fe2ca281f7d9c621f35fac8ff6d4634011a802b95121b65139ff5aae9e82546114dfe44f0aa6f486062045851e0746fafb9b45d0d1f83e9816102a35aa4af5253bf07cd964dd2b86f3d555581c96e397453ad264ca0291c78bf9c3fb20d2495fd47f3384df45a49c45a68e33ae47df9475d8ed603c5cb69d26190b2160c1ee5b26df3e8966d2e431741b521777ac8df5ca0da0258d4645e4c22c530022018358e102515a1f45152820ef8e0e138606799af44637562620c9b6d4af270da3c08f342cecefbfc27d0bcc7300a1b6bca91e2b1ffabf439af38a8ef3e4ce13acc4cc4ffdd8a2949536d26eb046ff9255525f42ca0729443e7618f9be6633990bd239931bce75fa85e3b8e9106275c7bdc8a484e0f39ab7d0103ff35f4bb23a1b2d375dcffd84d33dc05cdf1811a5a8bdb97a9b2784ae2b155e14adac3890b2dd3647115b0fe4d792d2b100cae1d517738832b9323036f18cddf14c63678b4761fba060b640a9030112eac05a82374397207d15934d6f69255798eef83614352d1f8e88c3f5836e10016eb0a065dbc55bad7d7fc5cbdaac738075328b92c622cb9227f0f29056b08b6b1b1b1cd246b5db56242e6f21e7a36cab5857fa2975c080c516c769d08293919ec2f07cee32d97f9778bbcfa13cfda12ba51ff9c1ab4cf4bfea7362b60dcf6107526e73a9e3a793767a1c4614f49e5f7e99eab7fab0208460f16e11bdd19ea8540d7dc0d92cbb8196c6f148532313e2d40053fcd55039c2724398f8f84f98d6ad11162aac130a3e9e3084322121a3a205ae0a1de390ab93165a807282064453558cc69af0780c2dd4d2e51224a12af8ba8d034c1951249a083ea4c67bc8d6adfd5d84e1679fd9cd7bdd43e6f457827798ef9ac50f5b9fe1363331a9860e1f5e6863d82a807c5710af776d31c67537256123b79805f8e74f913e8d08901ea454950534e1b94004d574966a0b0056e79527b5d96847fde4241feb732a32a39a060a6cdf4402096153310ca1b06472d71b424aa31a457d09769da7207a6e1a81683702682d008c1ea0dee8ff3f19b5c9808096503568cbf286e152da965ec0cb8fc684ae34b1bd7393237e73de55a4e5d5d275cdd5a460cefdcacae5442a7ce655f0469c771b389a82e5bbd6a0ab193fdbc32cc1a19c1faf9f1ff838e7736742e79313b90525b600a03d4c064d4289cd257c32ef5de32e694fc0f05415a24c67d68659c7a5625f3954b1cbd928ff9a8b746413e6b5038684df8b9c63c28b31849816ac73c89754e531eaa79787d189fd8f4e5f544388a2a7058edcb4f1df9a977179408b57f94551d8d5a24898a6773b40667741ee85755c176e7ab66247cef4ea0d181fa49aacff4d2a487f0f6cd2169089d685f9bc6b4a3e28ce5213dce17856d331496354233791b7a97ff8f2462abe0a26dcf653e7759ab7c188e4b721dc9f44555d8655ad7d0066f85b455d6506ef261c065d87f6f4b60fcb4928bfa8c86488fe756788d88cb2553fbd2cef743cfb99bcdc33261e6284cb12067dde82dc614dedaab58801412f589e25c4f98196c857564e0e53b75aa27b1a2bfeb706e04561ed279366eb4f38392e3ff646778b0db8a3f98cda440e91a49cb39a578c2515fe3f7883a22fe4c4320708ad444bfc08c280904427174132542de693be78168db37b9124f7c4e64e31a1cde55a9f3aa66cebe2aff8de74e941746c360ac009cad62ed198d45537afb9282aef6b23101407ddd8283a091b7d165f6349f15720f39160dc06d5991df697c0f75a263d92cea5480d8b217e1b99681e516ee0f5e7d1726ae3bf8dd5f5be45f1c71fd324381a0bb354a205ee7f503a76b9de717243c1f86364e02f36dbc3d172660e743a0a2475d0b92973d4dc06cbedd6d096b316ee4b22b2f60431314315e6ab6744229944dac09152d2878ed27b898ed4b673a60de8bbff7ccd531c1540175d394d8b1184de43faeb5166e43edf3c3cda491fc731512971ce8799f55c1aede4d219ebc1e195ecaedaff37db69796f31709c26c0348fc44017bc9dcd290066f38e754525ce5cb6c8941fd870d0b533c36ef266ef8fe40928a5c50f15a14c76731c97bc742b72a33d7bf05098a0b8211d2954d13b013e192c6004a159821fc1bc12479c1ae51a1fa57e66f0d2f003639e15cde02276264e774f7825ffb2ec0ea82448d36fc30b795cbb82538c145a1904fef24c76fbc8ee84fe95c1db749ee1aa03b6852acbe221acc45fd341e7312f67fd6fe3249a721c0148f05a294df0e4f40394c4773ed794f8934bf0d7a55a85ac411043dafecaec86c6ca3c32f861a193fb6d396b55624127503e1db27eba73645c810b9b8c2be7c95fb3f2525daa67d76565e85cf74144a7df8b5731aab454ed9b6f47109ce4bb656aebf669cdc72c673439939c84d9c24466f53556aeada22147090db7b7d92d6893a2edef714c9ba633af6bd57e8fbb0a054853a510533ffec47b19d54758436d0b5b948180d1da97f8890c34f5d53e2f35020c2a70c095819a235751d0656bf7ec0619e16a4fbc66c3dedb209b5b3329f73f36cf6ece7c1070bf31418a73e35351f6280c080d69708f7824a3f6d762f0c2dee14746d6c19f98199a5791b26677f14bfbcd942d437ffbe9aca9f96ec2f1dbcf8df39f43663d7da8f63059c096249518f88f690faaca4fd502b902c728e1100d7b5535ac1ec69081180ccde20b90589f3829e37a36965c2c5fdab08c3582f9b440e7e14cdbcfa4defd9d6a8ecb25fa6224f0b6204059b4ae82a0837e4c21566d50b89009653b942c4df7d2b725b4a82ed5aa1b80afda15172556a8969e36b04b10a05405e5f2e864519e4d1ea7bac6db34253df06a0a2cd07988ef51ea0dea3210be1e7d881d7c1d071d1c70c5c75301d5746c60b0f2d8c592d97157d1e1eb6ec5ff3f44fca956e14a83857da86176f29fa7b6cb09bf7698bf3021668c4e923f3501c6037d4c1b41b076a4f11130beaba590f00d6341a78e6dc16dee9098a0b1bd4ddb4e128048dbc2ac0d331a9bbb9cc2d4575943481ee564cf3ff76f9b1c9e8d532d389e16fea0207af25fd3a8079e28f9208df3b76f27151db3d40f5610d905f215456e6549d4c535ca985940eb77188c88337bd4f533903203bb9a55e0ef7f566aec1dcb3368eac69cffae5f5414befbc3601d2c5b6ff966e191d79f57e4cbc43f0ae17228486ab05906106a808a3c26c33e6509f397bda8f9e7241e0422d51c9aa323371eb7a79633685e7dbf8b785b3115c0d07e5066a317b0ea93c2a97421f2873dc6a80cf4ef32742f794a7371484b02f000e00a15fa9755246e4943f5503f28d6995374a07b6dfe15d289c0ac54c8bf548250c1e63e9dfd62c0a20eee99270b03bee305a51e540aa6404b3eeb0e1d2ce8df3beb669db4835e2d70499032280aa6cfd5b4d6ac4ee70e22f305698b3e2a9fb7560146a6a8731b345ebff334228fc8057f96153bd70193bcaf35acbd70eab5abe9e3252edb9952d464306fd07cc0967eed64c3065a8972c63d2dd07927d157f6a408381e992a950eb23e06b6e934c83a84cee034b016a1c4af6473c4e04ef3093b54a2f735df98d282bd529af85c03868afb76e900e494afd04d8a3cce2be7944cbc863cc36d5df9701e5d3043b10f0bc12fc08c72e9c9f8b7d0578848cd5af7ec6edce171c5b48fb21477cc155dc8ad455f5b19878dcdc6ae138b70e778245ba0580bb2f1130493800901f2eb2e3d1c471266b1436798a3b48d717051208544da78e305315d1a7c871719d19ae1262d9f837d12a5399c4adb4163b0ea9426c4266467da228423a712a5e23fa60d46b496567a0746d5efaf09845f59eca6f28ee0d46630711439447a12faf7e3f97c2180b613e4169c024caabc2cd7ffdaf918076d03e4cbbe1c4e83b9e75da7c3346f649c67775b1b4956d2a5652b5c52a8fe72a9d46cd2172ec55f2f855900c3e1b869bedce24bd55d9ceef00f4b53a67407709ca175bd8d4ba9a7d1c6d0071d4aed0973ec08836225a114e0b2f3282945348879d48df2469bdcd1fa976d708399c8d16ad8ca468c8a7ffcd3aef8d7c612380f653af331bf866aae77dd7152e7fadeb5b062c64d93b3b8144b192cf8c0374285f7775ccac8a3ed463c221ebcd8e07717461ff75c0b04081ff970c8424f9843925bbc350a64ff694b8794a9cf9cb557ec35e86665f48fae42edaae142833c900baa2442819f3ac9358c3f4c8260b40d37cd7161eee3a3ad75d60362a9a8dec5bb73ac2c979fc9a401361087f3b177419431bde9884786cd8aba0dfef1bf6af72129af40b1fa68f516c7618dba65b7d6e44304900b3a7ec9d8a8b83d9ae6dab12ee42bfb408112a0c18328e05d8858f1e933b090faf0b9442a4d3b25a5eec121167cdafdb9c3d2361443b829122bd6627867256be927f68cf26b20c27c21c09304cf36687551084c05349408707c2c9ce866d70a6582363a58f598b8b6d53e630c66996a6c7f351455d4ed75928240ebc29c7e4b20e530533533bd74531a07a676b49cfc7bbcbbf96a04c4a7fef92f824ba4052e90ac459c32f3039513ffd01f3f376248f7d304f199ceefb8dec0eda17e8ffb44ee8984f11311c2294201df56fd5e27341c8918db966882231bed4ae78ab4eb21a8209588c4ed4dbde5dc8c19ba15bbffb253ed397bebadffa1ef79b524812ea14d57d8c1d084adfb1c0a4e8a7739e0a63316b546ec333ab04d35fc9a9d20130344592410ec4c04d9d28ec66c257c00fb5f426b5e44718ef11360ebae4068ad0702df5f68d1aae4eb146daaec4a67d7a96df583e16544d12bdd89e8e3fda13b556b2bd851e2227b7d162a29c2a7aaf322019106026face1e3cb10a34a961998089c0fb894cd33d2ca359cd966d07c24df0134cba95259843747f77b99d20ed89d5586fab46d9e750ec6d545faf0ca7bae69a555290d1d2f5ed94b61eae064a9fce9c4ad394437885f536b14a62f71690ae5709d80791c31e4b954df16a5cd3d9bff7813229b0d198f52d5917013da1d41dbe3acf4374a13d696e8260eb607b2afda0660c59cc0f74c372eb7b29aa31c323377eea32f194e4c609bef0d4b0c456cd90c4c7fa78bd59b19907a7de805c621197722d33fdcb27bbe2aaf3b0301d8815889cce62499b3970c888d11bd954e48287d46d9bc36671b4204cfb706a621a8f61284be30e39f7b580db8fba5dadbc2b50532f15df9abdf511a50bf6fa50a88eacc344e4f9497f318fe19474179a93f17daca7797acbc0605becce110505176cb3fbd346d28d5397c11032cadeed700ca1e504cf812c1acb9980ad079be8a129be2ce941b6af25e4e969dc68252419ebd90a304febd0fdfc97b1cef5d9111b40f95281c3d420b2a26046e72228116c3af17156be0a3291b9c83cd267ca97c4e2180f55a4880aec16113ecd50c246944149dc1761b35001b359d58c8c79913970c076937e8b820da30154b3e0da976f27eefa4c50299d5428e712bdfb7a368601afdb058533ccce136f8fd57b46d79c7e0c999930eb5c12e53a55cb4d54b0fee25fff42a6ab1a3c89f91790a00f82170669a502a7088edff7651e49e44bb394ad9ddb276b640a22feca064513eb2b15a30b04a9c10816a17169f6260e60a85fb169040ffbb142e944b1e9b8712d16af3e42d33166f3d60af96e687bda44d291c5d45de96b1106eeae310099be0869a4b54c7aaa42eadcdeaab37cfc548baa1b29c40a05ac3c6df6f281d7f78104ad3b7ae01feb62711a7b8b355285cf73ffd783b957fed8d1f07aee1bf684db41edea0886727e4bc74b694ecd5187f282146c5cfe8dc2bf945b3bc03f13ded5587063afc73ed8aeef5eec31509d467fab9f38fd111abad78a5c013f83ce6544530704cc0a56403d88ec28d270eb86bbe1c31da3a87b59eb4ec3c81d5aa56718716f8c96e0cc120d50d0ddde1e5af1903778de823f2baa2fde9e173b1b5712c80323a2b83d0e8d06d0cb2a1aa4acf4e5871dbbb59226108e84860ad9b32238bed3547944d6ec0a637756c64b826b8457d940b5e7928aa09d6efa55e546f2aa6f4fea9631e0ef93b78c0dba3f775a91b6ed4db1c154bc69273d4557b6dfba8b4abbfb4e5f96fdc331dc601afd11f46257663d34ea1bf21ce35838eaba0f243af89bd10384df136b5ee5c501054cf276f6a11ac173c041e23fc86fb0c12dce111fa0dbfcdeb08d0f82cc53eb267244417b4a3af795bf71e72f1e1e8494bcd9ec991fa98f78a0910873ad152cbad8b13c043de7194d30f1298239577099abb478ce63e450683d6bcdbecc17558d7187c6d8140f4bc0cb4c17ef5ac2530f8624301d50c79ea38d4482d1a7a2d3673aa4985b171ff207881fa930d598884514bf39528cb703bb4732004c7faf2eece658b211ded89cb4fbedeac1a01c3c8eb35ea1400233cdea08af8070a6e9a2e69da134beea5f0addda2f8f07f41e2533fed4029e7e48d1118c737e958e4401b39cd67aefcc9bb3b66d069d3342be7b92ab74cd99da325087eb5a2509b8e25696139bb4fc9fa7b849e656e4d66742e06e37d7606fb8af7e4b42178b255e71ea563fed67228986985e52ae7e311d02e2f2b0966ee7d0537f703c7530a5587e29d265e11beb395351b4cab56e7abfe87a86af05278f7518d0969d0a1620359ce8ca59ded992e5f92fffe3e8ea017800f7c4c9fcd93afaa2c53e33b3674906b5262797e2f6f22f3f3bf2dd4fde91ca00674126eb7777115947bd6903463f613859d8bfe4ea32b80be81b82fcc598c1a701071273f9fb3c5acdd6cd9d2e98028cbea6a814b4406c09920dea4f78c11c367415c54242ac27b623c5cc2bdbf5b7feebfb4ec27efea26f90231d707c99c5078332dbf3a18e1068198aeaf02c0e0d27da501379e5e987bb5e948d95e3e7086b8a65f5f73c2fcf4e2d38cb4b4377037e3a31ee15b6223773dab25c60c4be2a9f45dd7cf7fdd253df15d6e9c77e4774a0cd00b9c06129197130e4f5d5c9197c86100a4fe92d658a10ee01e7cbaf318b1c4a300531a18a64832d02cc3f826c8bd4164dd13fe6ba103e6e2004f37b30c61651193e6d0edfc31da16d0b3bfe98a6eef5f6b1f36f77666153f7ec5908417c2fe5e948fbe3ad9e7ab8ffc8450ebd2ea3565e7c9f75d66c252e0b17925cc5cdcaf80211c2515c56ccb1f3c2b5ed77bdbdc914b3d66acec55a4fc34737f35aaee1fd528ba3355a948f04d4c3ca8f2dde38e0df2150149f3fbe7fd63869649b9f809137139a4cb8f8dd75eebeec4d43cf128fba86f21dcb8d11906d0e3851d00d6165795e3a528aedb27e81ab9391c8fe0e57f434b66fec5c000a76b09397054c6aab57e6f31280a58169ea1464f053e737a8cc07acfa0f730aac57bbaf8e664999a084fc7e88efb46635744e72efb038b7112cbe283058573f9f2742dfb03703e88108af6e7f53fe50fda6700d4c727e4651995ee760b979ea2d0fa300550a0a8ebbf70a960ca5b52d2a2f21c16cfabbb67d80dc9d2fc537dfa6b9179dd97edb9ae0d96f2f213f1bb6feb61380c2664e27d44abea77ff8550b23397c1ef504d570ced2d828739d4e78050b70d0d277c50c1d5e95e3a292a38d23b4b01bc8b113724f70cce665f9f9a0e221450fee95f400d8a007065de3efbe12b7dcdfcc4b6bad5e8858cddcea14ee5ae4f7bd6a870287c285f7daaa6dcacff3ba68a6b35822ef01f01ca7896687a5cb1f0577625fbf6468db50c15f5b5c2f704a7c0f9724c78f6c3a8eab28ec0180f5f765ffd67b2c3b3d108e4ea433b1660f6a2eb60eaccbc025ab1cb86adef3f3d56e309aa7d512701c49867c99a54b89521beb2f1d6c1f6961db74357a037e98ce66cffdbf5e2d0cacbe55a7bdfd5f3d428f8ff46d2680cccad4c4fedc92f6f78719833b0380a76c65d0813fff3794e684a385d8fae366c7be36454d8add33b334e410c1b458eb8210af198496ea2a9cc06d00365e0a1098e51e0772300989f21b0b89a305935f88b50cedfd2de681c9f297c0da5fb1d53ba6b5693592b5db9a816a1f204fd169a7ca4a3435b89a2d59608bb0457ec8ca3cb090ebc0bf7e0aad138e09f006f3ed42d89d90516c24ed69e7de56a48a9a77f059e99f50078fd803c184fe3e9c26f845b1c38cde63cdf76255596f69b5752324093068e94b92b34b7c8e6ede061e71a6bceaa2aea5f7ccbafae1ff373b7338f6ce09176b93c75412db6dc022f5167e4f22944d412aead0b7902955ddcc642faf2103f10687f49c43ebcaf1d61c6f5a212f314323406f091b0b01adec5b37b4acc287d0d0b5e56cc31e160d57841533c8b066b05419e9318fdbe312f63aefa09c012bfde81617ce1111514e088de3988be919ca1b12682252aec5a253885940deb752a1b54d9f1385b9fd5e27670c169646bd39a8e6d07894a6c1f0e4299acea42ebebf05a26fb49f3e7d49d841ff00c777bce6aa910cd8e86565e871424f71906e23fceafc988ddc7f28db0a88b1832c4ae287b60daa5a7e205bd4a4caae05013f1b250a083e272aaab83d090ab3073bb777e2b1b86e3ff85bfea8fd428b63070a5acb0331401a5ae6468fcc89ddba1614735b9670e33af150f1e339f3e2e01b5d1750daf080a890769afdf04bda0e619823a0624e6e0098d154816417b12f3b9d07f41b49e1a317b0c647df6599bc4dc5208a18715018312a7bfa2aa7f3a10d7d3799e7b9186840702f4feecfa732f39199abac58f810c852a9966039ae29dcafffaae97527d0667db77d4a261865b0ae85f8359cfc1235251629a95ec225d06f617bd42b79ba5c3fe6b3fe94bce20ead1a39b4b07595e30c6a985ca3effd94f84d602324c8e4378bc3fb4b3b0fc3caca92a44f6011c3331dd4433a01eaf018f10ee9d907ea34ac8f947fcabe0bc5f21cb9caa2ed38a2267560c3d8c66567e1f015906d278b22efdba720b10d8911164b070da3e4d89870ab7c1240cbecc219e97ee0ddc63a8bcf87ba8d915f5ee1a51c3160f0a8ffcea6f9e912af45baa9a837ad6a85a112f744d7293e319f897613153bc69089ebf8f5092312bf674191ba4996abd5e4aab86357be55b4b2978e0a4acd4938f99ae1dcb0ec383a731ddbb827dac795fd6afd668534f383525e25b8a4224836a1fccf6ebf1a2be4bc64440cf70516ac1aeea117f145c06c32dcb976f9695a3b02f9aca6da522f933d44b6f9c875345ecb8f495ddf58d166656583a893261ab0d5c2c504eac3d68368f12ac861c7d986695374b68c180adca20517471ce0bd3a475548341f3013079c8887c0ab808b99e626fb5e90ee470007babc9d1fc00ee340518cc63432591277918912e2d69958941db73e14b07cbbd7c995692a0e4edc04d6f1a37b0e075d97309c91739640b9e7678b5c21fcc2805137ab9b16fe44f63eab28e19db39aad7c04a0b10c8ce29c77e1e2c86fde35bbb55fddae297e765ad464e340dbb97156948738282476430ab6053dd6cc6fe97623a4e11b592465b077b6aaa9025d2e967cdc10d89e6e64bfa30c3384a7eb4cfad003f6d9532407a53374f25813b3f93cd248c5f0c1b7f233d6b284f76503f98f1587d103df8f7c1aae6b01bda6f09c908fb7b5a6eb610aba351e97093942ec1ab7090a1995467aae77b06e03a19143fdd3f1f5b298644f80ac6766f98c46c670d131c9de15c2e76bb9307f32a6a5aba64f573d626a35b4e5b5e2481a166ae5bce355faaa048337a7ae394bc61395e84209c92c9e1de7ba58f0d30cc1e16aa832802ef130ebe66db403e3da7a0813a15b591a10c1a034c27ecacada11a5cdc966127cfc232c9533cced94bddc1d290d895f48ecf3f21dffa0569b4083083799ca9ec36cfdb21e766dfc5c81df2e8e58a43a4bff1c08afd6bed3dbffa5bc530240ca2076947a1e15bcc02be10aa50737f0d7d0457d6cc62857e5f3981b6960f18c3243878999472d5ad8b94aee3fcc7a1589bf373350ae5bda4aab8605405adad2580b3e0bbf8bdbf4153c345f7c298648f4611f6e8c6838994749720ade65deb51e2eb0564fec4e9320d7105eade51f5c54031f54e461dc9acc533aedf1ea8ba89fe31d674fdf894363a6d200efe7f30530ffdb6f76d0c70a93981c6f68ada5ea6810beac4da96a22ffd25aaae1a20b67a1a80c7d7ecacc448ca2ceb8ee855ea98db9fba4b500ba8985a1acd37685ba2f1c8146eb372dbb105b489889923bbf9ec7e771c7505d434472e92a70b52377458f04c17aa36ec37077b6304820c1da9cae93ddaeaf3b1c3c33ce53785ca8fe208a73e30199204e326c7dd58f77086f7163705edb27d9d5584e7bbbb2ec133491db967c3d611e2dd4f33d9ae8fc3af8c6a2f99fcb7075f08bd0868db5cf3d65bd07cc5232ea9880cf2b43fae801e0e3ddbc3fd7371cb1215a1c48fd9959b1f2892e2e48fa9096322d6ccd86e5421a58ea416018ecc9ab04df89f19bd6f8b9f1c69806b8d1c0deaaff201749d815dc93eed9d6c761e227c39e41d3d569b42336876874a04e0b3ec9563c96f4ea8d7efd1994534381f689b3e512349e58c3b9cb56b4931ea759a0fcaedf20b0af2e8370729e662667439d5d211c881795ac4ef6d31a94ed2e62b7539a944a354edfa2449bb138d4a4f2cf28591c0b1526579d8222195db7aaeecaa4c0a9c1fa244ba14976ac11e6e4815e564296136756b289e7c0f73847e2a8dc02656b168c65d06f8c5d6e94b4418ca3151ad92bc8adf3377584306793b9abb46c6fbe6eb15b8bbc73b0d7c0f3bad0a27d7be333871a2d8e05e9916079888eaf7942776a00108796ef68d5be5f31c702c516f4397db4f1da7bd56175812af3e81323239e4d017c970b4353afd799da3d86696d85e74a3047f567bb3868510acc90473fa640213d9d60d88d30aae702c36d208c2d471a5f17512929fe0e72fcb208cc5f422fa33e5e947f21a03dff80af2caa9dca91ac9f2dbf070b7188647c2307b6c90f2d48098948d474359baee41f9d25e293c297283a0425fd0901d6aff7fdd7552dfb214a83921dc16d33a572add50a41eb9d86b39a15e1af1c7b86e1b773f8d7a512eef03f8a6026754dcbb69032c3193204eac689d54899befb6fcfc3ce2873528fab0ea640ad3c7412d559d4a91daafe6253bc6e62fcaf74ff039686f61e361435cd89f794fdc472caf556088c41cdb54f7435ee6236296a040e6d0301d9e578fd91fb3e42c1761f0ef63c981984dace1248c4c52745ceec2f859e31f01906dc15904a765639f0489a3095ac7cbb444975d9e5a73a7a53256172bf427b97bb87dc211096d48f2192208ef3160162353cf6424f98896ee3a26ec809eeef1f38eb23bba1c540e32463c4d17aeb16276dbbd5ebd774181735de73147e28fc85ad74b7d940fa7436a586db50813e3668a10dc1cf8f7a02eed0f5bdf1db3ba9d8f55ed8297698ab9a21013427fce84ec6e58e1a4de78e02a991668c740be04e440845cc705bed6237cc6ed287c9e6914539834de1e804650060d550ef83ff2b62d12110601c26b23f37cbf99d9c1c6a4f126f81489a088a4135d8f48d70b36a18523da2365d728ff0b5b0aeb0a0d6c2b1bcd6cb830ab400ceb9629c6a42bc1261708dfb142bef45a4252a837f523cc7092da2327b94512da88a0c570b670282583d17988605ab6193c1db53622b0c0ddc6ef83f697632ec5fc653410bf747a3a214d5563d55dc876c7ef854b54fcc5736e8a4b1ff955cd5f71f7b5925fa849aaa784812dfab0af430046f906decf0f330bd2ffb79a6053e2eaed2ee9906a5dc1d9f17173c52fa60c64dd605c22766095a576d66d5f4a4a5424376cbd20dee2e97f0f6bdc47879ecfe283dde84b2af1174e095202d5a28c254adebfe83d8bc5cd71fe1b266df70b8fe0e8745483b65b0b47cea6e4d038914fc1b76e4386eaf9cf3d25765a9c02f4d5c4991b4d13ec421a88d7eaa594beef0a537687d62a227fe952d2c3763e4b28a6c114dfacd32f2cbaabb9110f6d00e2e8c1de82761403cefd9d1c8c49319329b6b2f68737a0b4edd28ce948614df2885e93642c46781dcba295f84736d504a01888b432527de58d6678d66d4b2c5a933cd54a7e53c0fcfe082258eb46b5222b035d5bd48153ae999603d5d4f8ea3c65266dd42630c1f63c8c72c0933f758c444c60470de71a8e7c5a41295aa7aa2e65449b8e8865c5b130e39b62304f995b3e7c36e8f17face759d6fb68cb1106432c0f63ddd483f705ec6f77e65a8eb9843b74d9fe1b646cc1776e13cf9ecec315228a2ff10c9e0cb7e09ff7fd483656f5e8047a8fe9d0366ee0394af889482c13f206d6ffd4894d92487d6622a9ac060a949dd6fefcc63a5580c5f26030d075f67ef90283735a938adf06f00a931273f10416feaa3f2e3322fa9f72331bbdfdec723bcdd27f46272044136468308aaa79aa23a14fe188adbd3101d26dcdea2734d89e856c478a0d4cf27b78c4a3cdb450736d2e2ef4bf4383409aebdc6678f4e7662e769542cc7f35739146fa2e60c3f511c5ad2657e8cfd1eceb99d97acf4a4d51fef1ee504d3f76e522f13b115d4a1c91910f31b9531e79f8cf4db5dcdb1f81c15167c01ed2bda47c4159d21b4c2f0ad32a2a49977a94e11705393bd8b576fa9e550e7aa112e6909e5193d9d2864e4000534d9dfa46bb9123a9de2935ebd32b00ffb53062fdba39207b71c36a1c1aec29a1d8d925d8e610f58b04ff2fc870ba3cc4716219ca8ba51f2b35690dc066155ed6fb17d09b49f5caa88d7f67e9c256d831d51059ef0301e6ce14be67e9611f2ddb8c8c1da166108cea5bc1eef0dcc75433228030a43ad57b8bedfbb39803b084e1e849ee88d56a65582c0c27de16032dc8ad5972b09cbcc743561e23bcb8ef913463153a0abd29e4eb1c878c494761125ab949f6a9dfd567a290b073b000f400da3809a2b5119328926e5d243c28573eea8d1d8e669bf24710cfcce5b2d4e7436e9e53084e40193dc5d90486ad96b2e8b67db0c80974d05d513ab3f090ea86a19609ca7c40a153d41054b7a0d561bfd86667a24bb766ee880fac94ef539d8754ec4b186c1605e654c6644c4317487b12541db0afb7e069d638d4e8152b4354227eb3d9f8f7f4f0f358c44feca4cb561f11131e6661a7e677eedb627a4624b15629cd7635bbdd480d696a15b1dd416a81a3dad63db2c952ce3e8daa2efc4a50c9645b364bd84da7b4b94c38ae90c7af6931a051d3dec7710919ebad0ddd6edd27c4a93a5108a49c74af8ddc15b4a1dafc77477194b579287ce02eba6d10432233f49f42ff65c75e47528df89bdec9dafb749dc581d3904a655f8abbc8fcbe4778dd4cb64873a1087a2d6844595adae1fa4172a664944153dc441a91ece86d45bfbd5c0d67aace4602f334a96f0a8bf083fa4ff9f9aa1585d087521e8dea9e2d4efb58c82fb34e8c4eeccb54d9bc5126fd42ba87f47d32145730fc2dcc6ab429e0397d29571597d4b5aaa40f129cd579f66c36c6a90182949217bc8191c8ac3cd688397317ef3e0fe84149646ff5e0dbc2030e19100f55151c0c732ce24a6175dd8aa955ff3cda3016421c1dfa0894c31eb7d65ad4acf21a789c824968768d841aab3777539ce034337f08d92f869df839a70a1734dd51b410505ad02426a2df8b875beb439c70f3761d0b370681dca5180f76a8148205ae79e42538d3b7363cda4a5fb741a34d8a29d2c53a769f6822306c28e26b1aafbbffd337839d440c70d26578160ba9070da65397af5211333e8755656a622fc70e307e30982dbb72f0ae63275746c86424de385fb66b9fe3998fdd0f290dee3955a3ed6dfe1fee5c98d08dd7e10e2cd637b2408513ed1a3bcf3962bd882f24ba271bdb64e9f9bad2abd08c3531ce2a461a7a74ebad124cc155c9fc5e86d344cdcaff55cc83f999156f253cc98c802ddb5b761e88649815fab9c605f1da9077313e494ff327bb6d5a66045b70ae8c7bced2d156d3a63f324be96e6c1c1599ae1001e9a3b0cf688aa903705346e9bbbea1df2c531279687349ad0b7c6240bdc89f92cfd163cc94d42960a6a3d82ec6c5041077dc64655b65964095590c99586356b9982b22504946a0e370301bf5a9caac6024ecd5832a4d11586585bf18852630354c1292f89e8ae020e4c92f1d8547ea8b85af5dbd46b2b89a2c43d71473b93c9ffe4af5d042e6d86b3c88da01f39cf6adaecd1e6361d12acc1a580612c5e5585f3c7173bfee01d96708a93f98a504e84fa2359f666e1c08c2328c42b0840cb1f51abc59f91c2212928c5347b60a556fb6f21782871a8761da0a6b7e6b95e910b6070eb43f278bdc60e8c7829dcddb596147c0e2b308e5be9aad226c0653cf959df41f3bb6c259b8c8e5d646655d129cf648a4974a36cb8ab657c3f55793e268c09804db7a60e41ca8248860341f8bf92812683782254b1bdb13c4ab0a3729afb6e97db569bd793ee67bafe67a3d6ba161a8582310254e9208cbed75428118d181ced2fdbf9b41c37c2a8120613a03de83a5774890907f3af3dbddeea791b1795d58dafd8814c7de3175c6afe35f75a8dcd47302cac8efade1f48d78c385fcb66bb8fa75ae34002760752c58d439ebf58fedcf06995cebdec19a9d7251b4a74918b296f89495f7a26524aaf49ad5352cdce3e2e8df0bc296f76caf7b5d1811af4380fa80e159b53d6394f6ccd39a192c3bc615f25b2cad2bc0c3c5b251e777c2038adc0e8254279e9dd871b77f3b67f830f0732da7767a2619c3d06782470cf7338512dfeec7f7c74801839c0f7a1d88c496d29ef0a69cd43399ca78d762916a21bdef27ed8e33ddb8de0244fa75a619d1a3ba21e861c7325fbd7f40169b10c952ea46f2359e01776905b3781a0d54df01631ae86c46c68bc66e98b6e23a8d2c9ff673e2f6dfd9f18eed6369a56c166128ebde63ff5728bbf997603fe0c2bdce6f30b830bbb673e1440789e1acb28f9b34ff92d855f76bd3e9ec514d939ffbdd8aa1b06cc41dc7c456d5027bd4531f16671dfc9d76f8eec9bcbd91e463c28076b57bdf33c4b7f12e03a90f1c8ddb4e804c7be8b45f2617f1ab717f25834ed2d6d99e75539ff01335ea66f1bd37d9369707df9f088a80529f8f7861110dfb96ea58e7afa54dee32a588a8750b82e6295a1a4fbfd94d134cf090d75393b59159f2552e289b59d473a0d4eb2b2c0f449b7cacf91c06a89ff19416a2d152913f8b10cbbaf486c90cfa52d4bf33253bb5d114151e4e220c2250598cd1c73e709e14ac9aecab034f75b3a7d84042e0529ce5c6e5b71fc7710680e443cde4837a8c524072b8cd927146b810c5d708688efde90357a4875acda4e68f5019ee58e9086498f25c11dda882a54865d61273211ed4748b413aabeb704c6b00bf60a9839df8f607d7c3c534a0eaf8b3874ca7df0ad91ef3a6006c59fe47f050a85224372cff36b355179bf44328e7b453964acf120b179218a1778ff49c27b0d531b21972c1403ec3582d8c288b3441e233c60294a1a3f83b6d44471a401027821fde3200cf16104d07f2e8f22bda7711b20d1de3b741908a586e4093af58b12900cdb357a66527fa824c37699bf8881937d983a36cb1dd61749254689f33e0ed5d10470cbbd1c547f42345a1cf97fbd9a243e73d7ba38bff3d834411e075aae3cb505ed4140efd8f578d500182c2c63afd97afb19df874d7e15f33ec15ff16ccbacaa0c892f41e2c4814042b79953800ea4e8f4fa6475c9df273ba2b443e83bd6b46364089c5c774cd1ee62050aebdbb008fd445e81ffc8cbf8147f3975e1daf466b9466b0cc106edede0d8eead1ea7270547a9ee0e4fdc8748f5ce62210e433a056f3293831db3e357b1208a5f38e25bc0692d6967dd7b58ddb324cb6f9e8f38b630bb1888cc6dfc8bd351c244fe186b4c689a4b6e417c3edcbbee1939a5304c788b68ae9534558dbfc8e1341a1130d183de4191dc882556ab6c6f53a298fd471535f73838c2e3dcdafb1fb5fb3ea5193c39f0a8f7b841423c3a4175fce227840545293175039a49a856eb77656f57f584e63115b56f0deaa747950b57005f3ed4cc1a5714996b994f2b3039ac827e297a093696693835c5e748b24400ae5fc72bebea146cc6bfdf63cb0f0c43a0011ca9df7505284361189e61914c8c1975fd419f00336d74ae3cdafd4300c0f7fd399c338f25556789b130624afc9a97009d4ffd8e9296e225414820d76b1d9f93c2e8ae059e19889b7cde24f0f0f9cb8a22d72098333fd7c048461bfc48de7c2526a35bea9f8dcb7f0b5fbe648b0db7a074d473c927299625334a0e5f47937ab5e03a132ab6a9d4b19a19715457203369d9d4dc51757c346c010b8360435abe890628d0b53046f852cbcf71d379e2e79ec2b5f40709556fba3d05c36b0060c230068d36faca55918bc66ced69d8a50cbe1498be4073f058d9705fdb5b9b82c7159303f801f071d0202b766dce24b099cfdf2f94e84b03fda684de792db44f7493e8cbc7253daba8a36cfe3c0428ed61a4a843e111d18b62eb4c1f868a6bd791b849c84c7ac698059b6675f44893225000f5c3005a31ee5d6e2b9a866e0409eb4b1cd7afcb916dee689e763e45bb1ac91dc83da7015fa5d8bfb3480a3c58931889609802db6f8a96f289d9acbe44b4f013a6d609593b32d7fa3f763142cde4626bcfa544f2c5029a4aa27c8766dc6a4984cabb06dc62a130d5f7579a048931ff6bbcf013f53b4683c60f8d8132c86d7b396c7d770c52c9a8396b70f816ab66f20ee85f5f009b89fd19acffc7722b3388cb55d71954fa79d0a725ac5decac60fb60e2ac8b9033766768c1ec8a4fdfa21a147f517a03a1e7997f73a41129749cdd56be05827c814109889f4f11e9210d108f08ed432d1eb75849dd71dd2310039a72dc9faa749cdffc20a52977da398118afd1d2923bf3b8438b25f4c2296b9c72730e19632f994f1d4a0453a9740c70705211364efbd4509693c65776e87196774cef8932c4e4941a58d4ecdf6c81f147a33c2b7c2c35648d53d75433bad09d93457390d20ad65044da977a304839e54d2c2375572d6864865652c0bcc950cbfa701a66ca3f271a30ca52197b05288f1aef718e92a6237599fd5353d6a886a5491870747b8fa0aa832ef0a55c0b89d333243d2ed48eacdf3a903c348b79c80000ff34a3b3c658f592e546fda4c3af697fc3bb04ea4424aae99c4d5ea12dee18f6728a42b9f9c66f19b6f161d6cd3cc80a0438776f7327297fc1415d28c9be71049e5e332476c412a63e7bf0641427bb780c6d45891d5a4b7da752d1cab0e4b6364cf66f35903597106d60d9f19bf3d6ad91453d4481841e1127c94d1a246fb68aef5091af4ad758c985280f60247bac9541c46296c89e3d870d29705aab6dbe3bebb449870205708515b78bd15ba61db3fc7eb38aa508bf0fbfe6f8b2204b6c3f264de6e1413efe1391cccfbb40853490bdfd69d33f21eb74a1e8bda7f5baab1aa26eac23dbe3c67dce3d4f268f5273aad623641a14f7e131257d9339f626def1f85d6f6ef0b79effefc01ba418f9ee8472f1880ae093d346e2d7f5a2d6b818ba5f378d6e1e79b1eafd69c66586682b0fd6ec6982c209a557c900b4b260408b9048a948464f8d7e45859a8536c699d5ef1c18811f921dafef391f70dd16045d7c367fd6819c1f005ca5e72070e5862f277670778ad17df5a9c27d26109beef9fe47d9525ae989af1ebe648b396e713aba3901560cb3644d665f9bde7c9659822c33ca7b132d04cb57c9511844c5495b814b2f38811b3bd3b0c7b1559f09a2734ecd2c41d2a3e596b3ea64aa950cdacc363c2a8b5889645210098509136ca5b3429b3934015d5c51bc7220ea65d1cd19cf1e4adbbfe3b63bbea200f20465c12bcb5ac62cd7f7e3b055470dcb5f8e892946a03bfba3c9496e56101c188effa7c7046376698fb7c424d2f8b72df16d2c63e134626ff0c52b1515e0c886d4f5793444fd8967376d2734f5db7aa67fca4851a749f34692491c5f1e63a026e387deb356ceaef2bc7401b7d7db96f5a0cf8badffbaf766dcbb1d72da39b8a2e3fc5e704b72ea873cb76986c832097d233230e74f37d8537bc5b17fbcfc50b8d71482ce2756f0ecaacc116ac280ac5cdaedc2d61ca0a1adff7fa82733ca1a5239a6321d5358eb238bb0627d4ec3c93445d39f094e53e143b048bcecb57922cce8345f6287942e49bff58cd0d2d06cb1587aaa0407391bc394aaa81f53d6ed51dc9531c587261a5ba8c404213857227ecb45867692ab2e1bbd36f4e0a870aaa8a6331ef8c97e58804bbfaf55d3abc54c2569feb05e637ce857efe66028c60965b3f142b2746c4c65c88f7913ffab1194c7db81e0452575d6637c685df984fb77d9873763605371a88f7b517cb1996a9678f8dbe1585625d5d5fef425116e9a1bbd69bcf7a4f83f5cbf2a58e7864a0afd348a98835eaf5f82538377e2fcd44701155cf21d3be21e9fd97ec73f8ab69af1f7bab0a6021efa6a16bcde50443b1903441f4103f549fa6944657630ae1cbb3c3046f6ac93a06c635f5c7c0658154fb84af98782b2b0b8d127647f3dcc4751260bf003dde37ff3de0f216c945422b02e4c51318fe79815733ea1a553fea1352ce428a87b41bd0a26bc5944c7ef14808b46340f3ab4dd1929a970592598d640680e74144c9e81f4489fb10345eb08ef2ec4a6bb9cdec3e20eee0b3207ac083000801c4dcc4e9e2d4b72267de21b503ab41fdb103c93eb3ef31a3202b830d4390375d2484d91e32fddfeafa61e28afde5bc84f51c8550578b40be36db15559e10cc36261d8e44a5cebed098dc2664a3bd08cafcd0868b421d9899994d438122a230518d4209f2d5ab023dccaecbd5f7f07920a66268697e4d96ca4e2cd524237b15c3db3633ddd2be7d00df30ea049027cfcdb6def204ee9be87d3e35f2a49d1a9b0e1f0ca875c96caac136ff57a9214b2b5c0ea93e4add2dec85d036a63ed351a89f9985d804e8c81e2c0d93fbd92c5cfa4e1c454b00c8cbe47fd065c9e6441a54c38580ec8bfeac048220b517603d6a37c53ea177f9f281d689c5799ec7829664aaeee8de8c02b86dd8eec8ff5a12644104d22b744e3451fc337ff1aa5d1f8e641740f5df314ed4ee100e50f2490db6919035890b5104ebd44f3f6d16fb85ca7a7c14d96aeefa434c911f4abe6c19bb12daf4e8915253d533cd9bca74a8995c12584faf91a9b20e3e6e27f612a028d590fa47b66ab55b0e3179faab2f743429ff4cb4155d8096f3d8980536edb52eb50bc2a372033ee313bc8016b93eb69e3e3e7670b8e368c3677f3f045d5f1cf683878c2704d66d24a1ecb7ab80b58318873c124da81e3bf3b9cc0911a4363b285a5223e9d6164aa233d5d224801411d2190ad734e19cb6460a1bda5cbeb8397d0740e6aeadd2d9bea85a598f2c9ebe25c262b31c572edbb9663c45f01b279ae50e6df8dc5c3ed70773e8786775114131da2cd1219d3aba36ab62efc5b782afe1ba5a52334db8f4efbf8be284db12ae51734b9162c9a2e051ca96e8e5d812ff056904deafc46d7e0a4879214ba5969027919683ac00bad02d3d7cf8dd052fd0de4ba55fa1cb07c528354297e0089d40e17032d560b0b99b7694de78b5eafbace73540eea6b7a184e4978b008af7cb350d551995ea0716bae9ea0d3bc27eed42e24aabf02511f20e680de5b2cb0faf3cde59b25f5a3584c7a230e6e6044fd5770c0c64c5f003e8a6c1cdb01bc787e96c58f455c89d47fbc7c572e36cc8bf623f2ce604adc253a7bb77faee7cfce75e932956c13de2a1ed6089461b978cd79e5946c4ad8cd538b3420e23913f6c89893e466cca8dc33af8a26ea2cbc4eddd699f4fbd44c7d87ed84889050eb828cfb44f4fb2add8ca89aebbb2ec9e7ca8b68c845272a3aa409ab9659f0cc5e3b4d3dc0129a5f5f8daea22f6b09b3bd57feeba0cb98b62854edbc9de2880eced0046ac8e3f17090d1611666a92459d272f3ee5ae335fd562b2ed4e4df5def34755d3da49cd93a532c889ede1a3d31fb76fb24f23c10777bccb9f68a8f59dd1385bac48d7a9ccce08b4eaa4b9371df65a662989280f47c82fd504080a79fa50579e9fd66846ae4c86460a3770787968bb48800cb15f052816f3a817fb73186b2dccb965f2f2c312e26e82c2ce712ef2204c9b1ba15da4739e43c2646a4d750b475ddbe0b7c759e7a9fb8a12f92da1b082c351dac3a387d4ed573bf184c1b284404dee5805d6fbf65aa822f4f7a51a9a07b0c7a30679a2753704cdd280bfe2127055fab4b8e95615adf8b726c1676d867a67ad3489bd5ca142c5571a612a131071e3210faf0354a6f03e960e46694afe59d513a32c03705c2157ee74552e99d57fe1d0d4ff72e04e93946f70107102ba443e9c5ecb0f4f0b537fcd509ad9e6e0dd10e6ac0613c92ecff5018ec9f298157fb91819a32730647ca5e78b3666a57b6e469e20d5db9614ce96f90b6ba53670c7d25baeaba7582e6870770b38c46f21fdb7b7557ab9c824822ac5bb273485707883d2cae57e301e9a3e6353c76e25698192057a01aeefec0109c89c57a8f00b2a4c9a79f5b46e5f5cf0328e58fe7a17828765706d0691cf2a0b698d0370ad0b1e44aaa7d00fa25fb3187a65ddc61abd4090b2ec890f5e9ff45435801381217a6150015cbb7ed2cc8326f3c3cfbaff284a6e13a47809be2bbc2b6b1ebc2a4d70cd802157e94d441d5cb2e97347e80d434a0918290e3a4463442554df0387124d7000bf3e66b61876e54a83c3e90744fe3fb42bc46a6aa746606c08f55d7141e96eb5053d84db88c821cfdd0a8a93ff688b03efb97a5e020c766e31a3a102310608095720ff5b84eaa1398057eab7efeae5edb2dd70e1eba6e33aa2185f3be4da343687b25bddecd8be42a785e4846ff92f541bff884c73a09b3dc388b274050afe4fac4935a25d6ed6e35e586ecfa782746b0aebb0dbcd0af1c23396dcd48b8a49873b277c1227533c227c5522d5cf3460ede8807ee56a779d699a0d8b744168fd9b35343f3e5c793381b9d6c230ee83793febbf20214df4fbedc1b0321b8fb32d1702acd712a7a79fc3c944c97f578581251efb508aadf6a786616f21bcec27a09af9ac1290e16459440fbb3e62c08922ba9af42194d454a8f4ada763717a3d530b0a52d3f2b017fad6d426312135ea1941a29218afeaec4ef4d80833aaf7d753e9781a350ea9b407fb4ba4f086ba461b784570e5e78994a0d97d7fad03d626ec8de3c41cc8aad4139f47bd2937f7d13eecc79eee53febca6469ed2ab47df602c40b680c5bfae6fea894d106c29cb46b261847be15823728863992c38e1e66ad399b3556faddf58246c6800a5ca6e944631847aada47979ef68e4a733572ccd1961a0fdf43ee9850f62329b18ba96717eca5c4aff03a0455d30fc9012804a6067076c56255ef4f02558a7288365b28a9b4d0c3cd8d1fa4db0b9c5a556b3b7d2c5ef8852b2dd8cc9e6efcced9b18e575001da9fc065f4f1dd158a0a687dc4373f5960b482cd3bb0af28d0703fb04a922c1a3d0878f7ec2fa7fc2daf704404dae31a108b24642ed3e6f39acf409a52e26890fd3fe6973a4b4dcda23da9e9634307973013fdcfefadd9295f0a631f584fa51820fe22cf38704b573ac3433a50899fbf9de2e8bb5e9db0f299eedb8e1c7ae50836a8155ecfbfec6ffe284d71b3d3ef115623f509d8dbd0b003bb9e19997d432039c087a0f62ca24a7ac389a8a10c2b8847ecc3050389de5fb1ab9770401c4ce0db08b68c89a7d405cd9e326d7c32a3b306b30ff3da6bad6585db6734b31d4a0441fda1f8c0eec0b3087310903f99ce81c4f4d534f59d146a52e0ccd5684305327b398fbe63caabc6c685cd60ed2f32c905b1d3f0622e37cf0a2c8c7290e3ec07c9d4fceab2f173221d17271cfd162f69b88f206bb4e3372deabbf16cdc6e51b0e76bbe3aea3d1569dce0394a5a35ff2ef2d735d7e8b4bee4204b07607a3606a6008a8e44af009aea1da8d30ac73da17c1513e64117090e6b66055ca596954f418683fb3523beb698948abfb5e8532e1c1c68e8c6d5bfd164eedbddb0dd86f43c40981b3221805ea24e3419faa8f673795feb6a64f20d08f6b0eb240892675b03abe1ec4581acd82136e0090792d5010be7770c21df532908b38d28230bbc30dc23ee121792daa3ad7d7659edbc9cef676d660c17bca208304444aade57067b9f72e488aebc23f376ccaf38fa411944a17e137757ee2c98d89ada9ade5da82e06f5f8847e0b40999d1098f4efa9c1bbd745bfc259947604806050da3f7456528e412e9b49c3b74c4cbee3cd8be25c52f829dd111c733c7d94841eddd4b0bc3050c97e35d18cd14c0149623b92e7495928cb76854b51beb76d337178df081cbabbce84bb8702b532811b44b826dd7b23f429ca5f65b8108361b4c14ca2683b3df3b2a0b30ac1ca245e5e074ec5908b444a12d805da98601fe16ca54018c65ec8eb2525edebb1f5024277a0aece1dfd22057c436a9b84edf227b7b6c560bda409758c7db8ca2ca5720680fb90ad9bca0bb6891970412f597812e3f16e03454600ef1133ad5b4045175a165ce4217513bb8330590a21275856002fc997d846f42c5653a633032d9939bbca89b4e73b89e05827582f6c3c340067bd80b81c53b0600f07416d5627a57587bdd94fd0a9abff9858347ae1858050d09589eb06a59f30b6c64d9ab4abab86f0af18bd4b8e6c85376289f94a6e61dfc8a0cd3f0d1a94f19df3f7061bd13ebb8fd4eef845cfd77ea4c0758a505ecb9dd0b65fe4cf514990fcb2d9e3a15ad7790dca362c80706b85f7440422d9dbd07646693798db915503ff8a4b269794b9bb05325f6e3fd393f7b12b09adce9f2f5a5ec1ca580ea7e51b7bf42d2722256602ddbb207f08c8d58793f73cf1361d9526fb561ad1bd5a6b079116d5eb6fce4d3548ec9baab82bef0a160d3b36cd13f6da7f3014f814422364a178c865696320bd2b188442230485ef4940480a72362c58991a1dac7a8ba8e43db2f9c43e29c1345584f028a3bd18db658920e1bd82700d091cfefa307ba116fb0a88f8bf94cb06fe931d01fa3186a1ab35487cfb56bc30bc9375e25987c5cc0f830044e2d292d56c4d82d542a070457269a18af0c5a21b117cba733745c684c3a2c4e926162a08eace645e4e4839d11b28cd57ad294ce5e0ab9d81376e9e2aa6a430fe5a4eeec18e357dc7d1f8f0251115b824be0376a50049aa24e613b47695aaab8e8ea0578df8c60a066c14c05e0050afb4be2d884efc4027f45c3cc275b57919ebee84d44508eabb1ba79c7535271045dc07bed021801449b1c987cf007cbf65cf8ebb3ee6dd304a6121f6761effa7d1fd2e398c1d58a66b6e9e92f878352808b466e545e7976c30c807f1f84e8429670813e33aad410c45d776028a8fa695a1a565d0cff9fe648104b42482728aa786d8854f15d039dbcabf3e5f6e3da8127b9ab99ddd5c698ddb37fb8c11d83f8c4fade4f8c3f515fbe56b32eaf5a28e92f2349c03a61172a95a70fe8ba5eccfdc3171566006e718fa3311fc56880938c176cc8761ffe204d475e6324b2db810228b891f62a8cbef3a03c2ae03eeb3dd623fdbc7eff5347714cb4b34d2ac9564caae21633f9153b95a58db66cf85f86a2bc23261f4455bfae89644eea928a98baef794bae15ded5ef02b3a95fad31eb463425c78e12ef2b5eb77af16d66fed1364832d579017430ebd2513263bb6c8186cb224722c611ad1eaa84a77a5f0f3d7f8fb1ffbcb531fd699b1f029ecee1ef8a05134042952b04033d27a91764dd77740dbfd4f76815858e79b5db08549589ddd6707b3ca14ac1b176ce3bdba97a572208d9674803f40004d52a0a6f3a833f93ce9ce73d3c738d252ef37693416ca1fa4ee2ea16d61ca04d01d13346d2402fe9e0e541bf7350784b9f27106a79d137cb5a4645e078a6d332eb9b8343bb5885c0e923012ac607e6ed42ef838fd8cd38d72350ebf2a7cb997f7cbdddcd7754b9e6546a8e4314fd421073fffba9311d3c99c7f424cfc5007f566f9ca099aee07626767d6eb417c7313731dae1641f214c84e1e119d506eb64a3e9371a94c2101adc0f6386aa8c548a306e7a873028610fe3b78ac391386ae6617522eb83cc3d23bcf140f4d45dad43b6a2031ad566f33f7b03a41c8473801115045654b93980bc2d72a310ad4b2f55afa6f34ba44c02b5726bb9a5b6fe1566973d2f809828e47e66a0ce5ecf40e3beebf8f616a84557108eacb42096f38eea2d8480a82e09abcd75bc7c5af2d9c9cba295f0b1a4d658ac32eff4e4a7de773bf1852d89ddc7522cc60ab967aa7f7c98e79a19307e71cc4c67f582808fdb906b7e784a29c58a04c40500c0a6b4b0d9d8c97832a54b7b08252973f77ce0d2387c27146333bcc091caac5d04a512cbb0b3c3f724e513e6c655cad3efe21d93e16d954c977085c8de1e159be2ba848e0138d62c7b8df42e4839e3e44e9f8fc5ac790af483e6b88f310d2c0a980636de3de31e97075a06c5af2c42757c2de91a1c157bad4fb4de8e8c3056a1dc6370c6cfc507779c8fdf3175b9ecca757a3446d4c9cfa5dc89b2cf60323c20d4f8a57008ac8085582c589e8223062e4a096db303dec0a7e81172ae0b2337d6be56f7f7e4dc195b75b573eeebfdbe9b39da7b614751054e6b48c53f0e093e4452a809a6020ae8cd4affb82d42000745f7f8faa38858348227c38092c45d7dd5794cddc078ee3ddbc67383d76680851b00fd363d56974abd9a11eae541a12fc34cdeb13e5ab0c1e393dd255d487982f1602fd81abc8d1f93c47921e2777e334eb92be4040d3ee493811c914a080d18d46616116f6da8c9e608a898818c82c36565d8dbdfaaf5f3c9d1fc7adb8e43fe3215416ddea89ea0ecd6d10296f6e85baf4201bed40c98551e9e79613da1300a9f80c6da7e9602d58b36856deba9c76f390b46ce730c2c4ddaec719aec765d9ea115f4b007294c9843656c4c62d25a2569cb9d67095f9676b4c2079148d7df9d3d54c6319e34a913e989f9baa983440d84a5cb1c50ae9a0cf0d9d16264dbd2fdb0605ae91b68730bc9e8a25d0e2957e043957c6c713fb71dba9c64806c7b720191c8e24ec4595181e4519030d1113585384f36b50fd1a5b596709ca177015a6faee012da87fabf10abd57bf10f70b005b55de633038edc6b463c5c1b0f34fc2541a35e3f1d10f5b7f2dde22ecc3873aa579fa343985b303e11523985c777c5007f6ebf9da97c6d8ef9748507ff99536c4d561aba19793823b85f6f70466f1cb081ba668035caf1f7fee9baa974a956a890d281e845da9ed359db74f40e124b48d0a08352daaacbcf44e105d5e1571f79d9c97f71c939d781c28027037d7deb7cfb4e293655385d2e54abd4d0a71467eb854022a6b331d747532d495ea6293fcf02f29752bbf1f88b7b5d82dad1db92f782a34afe2c3f426e399c960cfbda1d1a8d771aef40819f3608b49c512d183c494b65b22c285779bf6265689a5f16ba13181fcfc5e41a90798b75e9f06f397185186744d93f75f2d3a60f74d0733f61af926e8f113821d364396635b184a57f5f137101950ecc69db10bb6d597afb4f83d6652597b4c679cf365396f10aab2cec06252ca2ffe6b67ccfd08f056212ff3d82bfc3bce2ba0fbe6210385e1d99621e8577c8b60b0146f0563e8db559730fce91b6ee142358d13695b1e8b4746057c2d84f15764c60465531dcead47f497617f8c7cb2a61c4e6641d94d93be2e4bf423ed31e370df6712fa94e7df77c32c9280fe5f412139e8cf041d2389575675697a9c650ae0e9a3124fb19ee22595561685037088fda8032355c94535a9ea33b4563069121db4e45d173eba6ee8b87a9de17c981fd883e591875675ab28e14ba6aec481ae38c02fb09feb326d9bd0d7be9bec460e9611ec96b6b3411041af7e5a2eda91b76453c9553ba3de0ce2f442035fe96cbe9a909c6aa9594ed0813d5006787b53863ed1350979be9cb94a09fe56fcbe15283763e2df581ac3ad9edd15a1adb18be14f9190b58eafdef519c900493e79a063b4f7a87f4068c4d3f3968e9703ca715229b1f2003bff13f444eef0244c621d75d07946f0efd9a7db8ead21864a1393311f0ac05f5f60c7029c44e9ca21c4ce7832a6879782d081784bee6cdd53a7d6d0f84dfa969ebe8146711cbcf44b1f5d1c6ff357a082e0aeac837d48ecfce7aa799884ac361f53dd4f5977b9f6ab3810bd9eed5dbd728d42c6b6062b66bd8c3687e5ff88004aef5cf91d080a896e55f2042a51ffa804bddf3b7bccbf71de931587fe6c8cbac094d4fe2bc636c38fccb65784892683541088bb511593e1cc79f0fa8406a63cb2feecb4db85bc1bfa7a5bd42f772b825684b0517902bb9d65fb36ad3c8ca3ddcb5c301bb28fdc05263ad5c752cdecc2e250d239c4609500467ad7b1da9656daf4eaa086dbc61ec3cad5ebae985d8cc9f7b9eaae30bfb78f81ff459efee92d8b8fd0f2b130ea6b63e1510ca42eacaa55081e4366380eda919ae214ba463ddedea2ed234262085c093956ec29e4667aa79e492937c280f76ef71c3b8939be6888f2db65e03c154e9da454d302ec22c25d90e69d6554ea585966ef9ccf1641ef37e85ed6d8dc60f39f958933bbd877d574e167546c722951bae0d3d5b548cec8dabcc01e3dff8d526db0ca879024228ba6848b83433f30405e3746bf9ff7d324e295a4939be3379ed2971b3f709283c94b579e60a076cffc05b63fe938e35d847eb2f8e54b33f2ea791f0b52f2d5ee75fb46750670efd1331158583afbbefaadc5411b591f0f66bdc9858f4c25a5fee1b340ed9265f51f980cafa076dd5b680222fa8bb9b82035fbc4f6ea4563e0e8f7e38f46cb1d4a5993a7463b48f05345d59004be5ac93fe228721f9458adebf97d12cf6192ce650fbd58d21a39dfc4ee32eca8940b03db5d3d69115b619f80f6bda19319513992c4d21baf41de667c350d8ce911958c519573f57d691ad7793cafad68433cd3bce62c6933e651f756a0a7073535694a527b53775ff5d773f917289c07e08c2e9bd6103ad26544121e9cb5cf983bb17ff0f0a67648b15f163959fa58bb6de99aa98102ce49b4e6ffe84c0be3e3f93018ca538a8647ee3eb81704fd4a81bb4d21bc886f6367961024d1da34704175d9e033e09b1119412f30ecb27338d5a5d26c273c6b7a4b0bc126f4fecc861cfdc3f69de7c30405bf9e234d54de696dd8cfea50270c9e07dd285696087532cc2e63b7e12efacb7517f1a9858a68523f7b4ba6f27ea4e8ebb008b0f80b94c7129b20eaa743f8b23c20ac0f7f1b802744f1247b5d65fbcdf8b7c142992891c5074b6d155cbb7de932af7056587f573cdba040e5b931e20308b31aaf4218e934a409fd8f6927407d06df4964413f04fc637e6d9c7f778da359631560e82ab44b298599c998dfece62c5cac443b66d05a6d0f173f3221379e60d199afd57ca1616764c30449628c68c8d47f02e9f3200f274069ae346186fa10e12430c1ee1d8162e7cfe2b9d824c3ed7440c5fd52109f264adf5b9669ec0a35a2a32d70120f9056584729b81af395e51703450cd81e2f01d877991f5641daf8d9ad002414797065dce3bfb4bc1cd93eef5c9cb2ccb62cef6d38103bf61c6bb985c04ec1408409f13e37e8f1197c6d50fa69cc91e8467db3d0c22a1e7aa9f627554839b61d912132e39ea00d2dfe2563e1bbfd0747b047c52529f747884d0f76e589d830cfd813048922069ab4c3d3bfff8f48cc61009fe10fc55fad680a09942e99f298a4c44a1cac2912f2d0f565806c22e1770f57ae9f609015f0d0857bf6ec7cb7ebfab996986304395d57137a51056de683d3dbca7fd127b1becb5594776f77473dbcdd0246edbd17fd173cdb0e98be1a485913532301f6546e73c847ef0d1968553197e493cb3cf2613c18fcbcf539b6e29a101279d5c1b5ecd8a732cc78ecca586265a6fd49da47cd099e849045ff8e18ae47ccadd3eec83a9b342c35afc60e1f52ebae6694fd11954c007d6660f796ed45749ad1bc68e64392df6fcfb9a256472f634c5f6c3177411a643f24d965742182f832682d243358369401f91b4b920285c7993f6570004e194dd31dcb6b722e679c65e1cb6d29f42533e206877afd604b05f888d1b1fd047181658b3399488d21033427915933567349ff18d10f8ac0fcaedc3d405fffb6e05c3e6f592d1461141b83b7e8f3868ed057fb415feea924f1b8483387e553e3f3621f2207a90a4ed3bd7795d022a0a0274c36985153698e6e2817ce1975df0edf6ebfc07a7dfe01631de41730f1923fd6d13faaef313290f36ce8a3c9214adc0a024df9637ffc248d278279f0e49b88f134474a464770e17f305c12a56957aadf88c75c2e3dda0e55bb50e2a3d5c47df8e91098cae707283864b1cec64cbc1979126c794313f5dc2ad08dc15d2851f9c91a01a1687ed4e337efd641596b16a5153d9f8d1b8ba34e0408e9d9dfc32dada4097732e41178c72ebc1bebd01c215bfdedee6894df91456901496a94022475cd2c3493ca351167771cfa493d995ee10e9ec155a7af8898323ab401ce69120736b3bb31ea2de30b96ff982604087f31370814f80032b0d5de0e9f286f3e3bad3dd8bebf8d3cb5a9ca53a264f98c2a8a0c201869813f9faa1cd230f7654ba52db09404a2bfa5be8c39d11e658ac8718bc386668f4814c8b801b58c8e8ff445b72cb4e03f8f800187b66e0abb7b6f76849b68e12617eef891ef294e138569e59060e325d9dce7e41ab2bc69cb905c6f7a8c2edc0e6cc2a6205c1163509573f62a146dee1cecda0084bfd7febe3c3f5dbff06634f6bf588989e02e35087a48bce63504406782a9d62af8028fee607a2a10965f4ab31bca90f03ac8b561b4da1c232771b3549ec6644159da897dea07a9642be37e3f5902b8ddbc1c308875b4c50b6c0349a0500c7cf0373bea5ead05baa2bb59d12f4a0e40d2c4c1be76d9373fafb53e9b45b2224c01b2990902337350856ce4abf881ca1a67627d1bd628c0b23d1f9ea8c079b4929a8cbc99ca2e2fb5b53bd2a239d82b13accaf006d34ad11707a87e5677adc514afc5e7943b60cd48c6609e3308d786bfbae1934795ca574d8d9d59f7d3823493ba28fadeff266277632a454d4966c106cfb0fcce80869c6e08d1b89a1824ff25d03cf51833700e5bcb3db5ad3062954942726e3b4ce621ef522c2db289f5fc49a8ca11685a7f38d5cbc04023cd0f022387e6080550563c448f4c6e068253100428bac1498891862d9e4100a78bdf5b395f96a46b9a42fa51461685dc2bf43aeb6adc14b332aee8df02ed4a3e1c4ba29bb7b4547e522b403ffbc4e3ae609717b5976e7da383b5bddddf48c96e1339ffdbbaec62522ef9371e4d4e4e8d30dec2772562302731aab67b36fc40a7cbfa0213a31ff2599abf82d4f8c620d96c63314daee90f3b22c3a08af393970ef0f730a93930e498277cf442d379c5aaa87cc437241e6d2b54bfa94</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">当前文章暂不对外可见，请输入密码后查看！</span>      </label>    </div>  </div></div><script data-pjax src="/blog/lib/hbe.js"></script><link href="/blog/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> private </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形式语言与自动机学习笔记(1)</title>
      <link href="/blog/2025/03/05/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)/"/>
      <url>/blog/2025/03/05/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="7c61ec9804b01124107ce4359cd15d2b5d6faf0ca1183dc92479278e2de90e5e">6df07e4654b2f23296fe416e73f530c96bf04cf67b3d4ddcef59c681cd714fa39f8d816a44e2fd435266a3c3411085fd09f5a7491153f04c2faeea0330f725a22d987d0789f77feaebbe5363e5758723ef626485283a653da14c6362dbefee5fde883b70eb748556b8e5472c70a524fe901fb6bd48638e2f10a3e1e40235435c01c5a2b59928741ab3fa911077653fe885a65725a0311606ded3cad842f33d963b7044f9a488048594b34962866da6d2478b00d7b45eabb7c2347ae5b7ef987e5b41fafd356580bb82c8a2967e7f56c771807e69349c07c8f4b359dfe27728a5fdb2c6b9caa5e0353b86c5be823a4ea3f5eb74f71b0cd47f6e5af988dfaf533391d61123c37093757411594c2d27fb7a56e802c7e8692926e4e9cac5909d556a257375154a79f2c3d44be39eaa01008036c1943050f24d23913d097c02f51554f75571cc11ef193e849ab5dff063854187af01aaa1c684eb6516c7e1ab2081b20b72c3b4329a863815fe1c4a6d20f6aad7b78e8151a529181386776722dc7f1794b57f725dfe50c44b7afcc18a2510991dd164291db9acbd9553546433a2c21e48fbbf6e400da33da005c70b1ea5c8c42f57d61a968a66c671904ba242d43f32c334abdfaa366ab61b3d2272c345413fad8998c4e9bb6de72c306aac37420f017433c5343ee433dd20d8e59ead2ee2e6e5d926efb8cc0acfd075f04744f17e8300a6c88c02230e382d9b4dd7759af1e1134da437391282dc07da5c4a310d70173eb85eb4ba3ada8b4d37c411d5c77568aed6fdcee6a321658fbc0003dd6b96e7f08140ad7e51ecfd9f05235df87b8af06b21f257290a0c4708e8c87dabe0c73abab862fb558974e13b76ba370712cf35d27525232096601ed70395104939509012a6b983cfcc9ccc8484d04faad24685b8c7fa74e10a631bbb9d4dfafc499ebefbf279764aeadfc1a5bb39ede750bf9b6ec08d7be901f5f8ecc6fba44e0531217864c35136e310e0169e5db16970416af7b2031777524f751d92637a9ff09e0a7956b415e2d33c934436f66c4c712cfb097a622b84e75389aa87aed6c0082ad591f6e04df06907848d1bd45f52617568f0b1e10e892c1027148ae6da29e2ab7676a4325d24528c1f7b56e9b85360a8d1d22114e2b06bffe2eb50c6709e6c055f7259fa9b4ce32ae222680fbf40769badaec16dc6f6c45bc54906acbe7a08ae07ae69e5cd7ffd12326504f5cf2350a8b08810f97fe100ffc4faa4487752b07346672f34c69090e9f903763e647a0411ebe8feb712771065ad1c5f29174ccefeede362563b15361717dc41acd50e9d5689cf3f7f0eda8120869fa52ce5e6efc4a4c93fcd5b9cce25dfcc0ecc590d031037a15007805d9451d932b1fdb2539e58f20d3c923654616a9638aee888d572d3777a0b536e64b545b277de1800a5cf73d0544ad6cfc50c53b695b621e77c40935f60a9947dd64724f6caf6bb043b10d391f9907c1f537e11af51aa9b3ae4b03b40c13e3226d5b8a02cde7f3773e64adf4ef13b0f1ef772903c215be1ae1c06d692bcf4f2a47d57abe5f0b7e08cda7507b377f08e5145062dcc48fc61e2e02b7ea33e4a94454e2cf04fa959190f686333b659c1591f7941cbae1b5b59ff53cda60fd539f5a73103261a22a05da0d66fc6744983943bf7c08bf16a12e7eaff6e1c046861b3b54fbb52022e4a72c3555b28c5e653d4ac4dfb2393a9bc9ccb95938b62b569ea1ce0d708e7b41981be0954c1fcadfbf96a456dfb4cebb23b44d20088e8a8aff0bf2d3b5ea24c0d57ec34a3f81fcee720dcb115d8cf96332d0c511b0108d098101758b68c839cbcebd4584e75de7930ea9fd0870d397edc168f10986c5ddf21c75212f358b75b4528bd66781c9d98be177d6d0d0c76cd62fdd106909a1eac93700ce29271c55ca7b1c43c8910a7ef71bf25e0be37ac95dabf6622388680e7f9356812937e3d76fdd9f8d1c09ceb6e188760c40101eba3ae64247b509f26d9676c675d7cd697d716c623c225a53a66235698406282d4ef61126b16aa49787bd60abb14b82f388a947ac9521c5f3460189e95490893ce5adf5d6b6b9ef5163f62a01236e8864d7586ffeddecb54fa824e8bff4bef36a9e8ee0c28235606a554ce9804eed8e6a32ee5ed4725fe898b4635a2c76adff2f6b2cfaf2feed2fbf4d64e969631d4a6d2e433f7d8112c921aea5c1320b6b0d6427bf6685472001bdf6d5476af5967a6b514ac08780b1eca3697a05e47ae10fd01d31d848b22b905d8ff40290a7677b923f271f26921c8787fac9b69072b9d4b1842406c9d53e0e20c5901302ee4a69d076a6a9e1d8e949cd86b13120e4108875f84a645df6bad053ce24baf62273de991fc0cc945676d85c9c65c08e300775e256808bcae03fbb1738246c8cc7b554d7556ffe9810d2fb50e78f58999123ba6f31240d09a16575dffe711ac9a165e2f4f702ac98420d149c601ea8266bad7a3d79b5aa3db084cfe0a0473e5702689303a38a9be96e31ff97c8df6cbf6fcb89b4c7fbb6c0c99b9cb1faeaa81665f0ac7bd45ec964592f5f6f6797847d00d35f3a77b51a478b60ef0985d369d9004ea5e1ee54a76e4ea907ed90676f397644ebf50f18365895cd5d0455fa59fabe1e2fb64793c655982c54fbbd051afff2c7555356fccf07b5a56607c8d69e41f84136d3ea499d906264470eeba82bc774686c4c64a627ec4f8657e0b80824d54fb506a8cb65b38ced6d567e204e1f1afd60eceffb2e7dfa4932836aa70460e4c67f10fc7dabc8f9dfc22cfb0b3b84af47ba51fbe74a8a4bb3b346864ce8f6ba9df38b5f903321ed379f21fc05f0d7f6b8edbb89478031c49927a25eefcf5cba0a213144df0d08eb2de95f9efefd47705290e06e1d8d93e76847227c1c382188817e1fa2484a0b36cb5cb3a71563c76faa75f92b341e09c9654b0b3dc60e3cfb5215708252d54dfe47ea0cc1414922684bf8bea2c4e6de37b70b45a5e38d4f0fcdea2782676080b667e90b335f5e65f51da137d29486bd143d72a81b7271333b39fcee8247d2875c413ff2f856095645d271e44f743383b4a354a1e7e080e756f7af47e8bb509d4f39d61bce584fa2b83834cf226a809b9e4e2400e025e49e37fa0b9d59bcc7ed0c71fef634fb3ba1defb8dbdd1677370bb4b714b555e2c4e7f8e34b2209be78374b210d5af161d2c75fd0b87e1dc61d17b6fefd6bee23d288aeba4c15e88ea3d8fd1163715bb38c618be95f34723f8373b91ef9f6d0e4d9ff4b33c4798667c20c68f38800a03465bdf2572440d6abfba257a41b0a3a9f6a3aa2feb3b5e53291fc134bc131725f0052d425ef8f8b98b31572472f1a0f46fca3da502820fbbab54ea2707dc00f338d8fb2931bdbfd299cdee2c5cc9b922541bc3f40b397c99060b502dd91ebf03f2b4e228730d74ae41ccbf7f24928a71ef55dc62620776b7313dd99142d6e6044c8d6d6e88d770c8816be4c367a359cbe458dd17a5cfbec20a57b23b979997e9eae7b1a38185136c1f3dffdb9c079c5ea5d61fb8e45b1f94385bb6b3a6414da5236bc11fcac8c6fe69198eed60151f532dd6f5696476276b382b5c7ab765ea9afefeb69cb535c44cc1de25dc340817812f3f1f23eed5ac6738a65ad4cd939cf7e6a9e4c5cfd10876a217c63be43f94bdfe0b0127fe8f2c4e617c19daf8c4950c450e8334d0deada37eb784be0c8a3a3a2854c6b25b4dd28c58d5a0724c84b1ca67314fefa24f21093a009c02f01c56e87bcca9e4f21559ed496c12f22db0f2b979e65861c31d552b0a3cbd2c3248ec07e8bc16097f2dc198847f9727ebd772940ab4608bf686010674a813db2fe1764c2ddb558627e481f82adeba7e4f7bac1335deb24447c591a1641399743efd353346abae1a1f9b7fbd4aaf1f2b04b849e6736fe01faf796f4f0e459305e077dab407cfe3aefa4e5da88fc025851ea4cbd22d9d63c7b6f6e9e1ca37716681ee18f0f08c26f4c54eabfd587b6ee3e4c0d61f536e46a0f6e7aefeb8bc2783b2b1d8734c05952ed9e2d95f928ef8591ddee91b421c922fff6a4f5764055a3f0c10ffff6dd8d6b42f3bc4c0e398bde7d4d32bce0340f8d7938c75d89249f773cfc908143d774d34352819cd17502caf686abeeeaace9377bab40b59477a64d636fd74eaa5f0fbc163b020b929978b78532a305fccb9eb21ecfe1e8d251de0ed0f6c3c632891b3ba610a5b0af25efc843e19b08208f09f202058fe0ff073d8a66a841cd8f68a58f453357b1737a3851d90e39dfc23f633c136eedd8eab7e028f1a35bef7b9724a231716f517eb77d707cbf9b5ace84cb0d500d1508147fce462a1e528c788fd88a4041e0e8d3485e2d223705615b3dea16a215bada213d54f0f86dc7fc9d8e81011c5a342e38ebefd88e0c30ffb85f5c2bbeccb43078e2857935f25b29c7a8cd033ab4bd1bfd4aa9968e3d55a4891593c9a63dddf76de49943b559952b728d6d9cd4fe2cb5e7421f986145bf7dbc97cb0b51abdd2d948ad5a572c212473504e3f1f350741e3cc2f80baff3342a7ce5a7cc5aeb79abd47afd25727635bdfc3c6973e8e4620119ae7a911b93e417c057018cb4b740c99a43695d728e5a13921db36ca11cc568320dd0e7889600ed8d3bfdc9748e703279b1855fe49cbf64630135b2499cc0720cfca8ea08b3112d7f2d2d1caf64e91f99dc1700efe8d5ce793f4736df2eaa2136f7ddfac62e3b5b653e949df79386ff0f6ae3808645afb2f3f28bcb54f42b46cd13ec63e906262450f947d7e241cbd13aedde4013f64ae15ae31b04955186deee34efd526402ef7dc4f77dd7183f762edf86053f5f9e6ca594c9c8f2594506ffe2ca03d871da3f6ff2a506a6b42720161d1d0cd3b100f4e67cb6c2c53bfdb901f8b11a254d90d19701c957f77d41162ac82c0e5ecbd2d46e0e069e25abb40b2be44b01adca8c878e08fc0f784ad6912f21b38a99f1e4ce43570dfc25b5b9278d7869ecea9eae7546aa5c759b4f69ff14eec9bf64e59c821c2f07703674787c3fd0d9d533c6448210259e9febf2b6a1c598380abf7472fe3d4975dbbe7dd4ef5df0c9d71508fb1bc976fb3904a8ae26e7846be0a10a9656453d8ce640442e6707d4a452f6619b53640e341f500a708da60f364702ad5226ff73ae09eba26c949460d1be215afa775c96f7e19f09100c475d1f8a918e17b6fc28bdd6e599b3004194b3bc4b709575088ecdafcbead4cca131c10b7f16b674c8581d7defc7e9ae06c93f9fbd9dac66d7f0a990fc8bc1bf89fb0db8444073880d4ed4d1ad7dac5366aa627c7a1e0c5bec0b1ae2412b646a4c2f1dac5edf623887caa1570a32b024449ca261ee9378c8a1dc845e402116585cd7c110561bcf9bd65ac061110f1371ecccd4cd9654b3a59ee599025cdad04953396c26fbae73353fa6e3702bff69887f9a69e6ea05e2ce7c383b5afa4108e095989a88178b203cafe51322eadb0d891316c7b2e3d6d191bb88a7d8e19c6a140d10e28bbd564debee57ce3fc71972e148efb340e94adacda0b1c494410993dc651cf44df0f39afc69dc4b7383b836fcfc929a239e802c23cfb698ed105deb900dac6941ff43f0cf87da312c17e833da44a3e29a6cd9fad43862fd3cbe2d44f22c67641d763bf61c3fa46376cc78996671c4dd8b6d48f381c564f3584a35f97c15faaec25a87ecbad11c02ac46725062cfa1d82b96bef46e83a8ddf5a0a4c2bf48f4e0a391c63960b70cce2b6bac195ce2d229bfeb2e3e44a6e314f6377e3aefbdb9f8b0c37aab75d13112801d0c7d803d24e79fd1b8762888c54b8108ec62b755874c22fba3bb1dabe78b1e357696e2416fbf07ef3016e563e536d0af131abe0dd493651f0101c0a7c33e62b26d87af25a276dc0fbe54f76b4d12dbed33743cf926314c525b5ad49ea6d943ee8f25e3b876c861693a2459fa1ed91af79d641a1b3c0791a582bb2935ece80683e8d64f84a64943baf3074cd503c1996b9513bee3c7b8ffc798800ea021b7443b026053672d865f011c174a3dd41d2ec07d53e876121c71485006a82d556f49bc6487c0b5f9fd1497873dfb4b6d39f8dabdc30c945c6a3bbfc91ab2a69fea3dcfe7f28c7c245af928569ea0f2f975b4dfe39977eebdc9599f72700ae4429dd79d2f431e965f2964bf416718fb5c698aadd06b3af354ae0ea5fa55f549cffa78fe862ba971507a960ebbc95ebca0e3f299333f34200169cf0f6a5b5bf020727778cea4ae0f18e755f71b8b123dc153980512824dd5ac16710a2f142dd65830767b6ba2aa890ce5cebcb66ac7cc7dbe2d16bc728ca96400f3d663cb9987ca77ea633d9eb1f5166c8bb6399bf7295b69932bf05993aaf1ccbe0cdb6834ac13134646cde6873a2a75b4ec9787e9d13abdbc05ecf4b6eea8bc9f8cd94d4a53b30a1db505868b5af501c04c42167c317c49550c963121ebc4594b4c7dc0a9aa5b7e0fb22613bbafdff539d66b7e870333711c32957e0dc12e9092ae0de64c9ffdde781292b7196922343937059836d850959be83c230354a02047988635e8a2f1ad7b65807a82dbd732a6889e9f842708946428e63988fd99da9d2222f06b43dc2361494a9232376a7dfa448ed0635cd14f408a810b67f2f9cfee8a1f5728ee430d6a6999efb47a6539e07b095a54585e9905b305df33c83d7416d0c354541cb9ba59a251044808de8b68d73a445d10b07e0f5c0b248f77e6bf3bc61c3288986f1160fc3db0043cf940cdfa2040e1c16012e988d480dd6056fa03a28c56a2fe1f97941c7c221377cef8c1d67edcf6e5bb7d7a5f9e1da6ae7615fdc6e51c307192c5b7daae72d622d9a5b9d9def33961ec3113e091e6a191e960f07833f88895351bd1e93741b2ff4f71b9f819a28d6aab16c07824ffd2ea1f0eb45b9209e10972b1042d7cb7816bd582b0fc223483bb5a3fa560efe1c15af04b29864ea171de064ba3f4bfa499066a5554a353ca0801bced834400a8c935225ed64b020b52d7303c89d5aa4ae61460357756cfe398fa3f7a693c38ca55e510612f7c1beaf6742a872bec97122d1c886ce74c6a684b2c4c08af7b05c326c8cb44c7e1ab8a8d948c3419c596b4f388c1a5553482df3ff2f4563c58114a0c05cc5477a07805dea5fc75ef9bf5d063ad3f04f48b331fc95dfa3aa59ee4887ad202cc79441a557edd181e883999996303a63ba8811c261ee8d927ee968044506840ca241c57e509d1b656fd0524be4499200290e05800eb4bb91183f6937a25448c5940e338cd22ec7bead6ecde0ba995831faa50be0f58abd179713d8d8a08e4a90b173315108f9922398645603449b696aa727aa889dcff81e7fa9318414845e1f1057a741911f761149da78e4fa6ad2752c290cd657189fa7b97f582bac24adcc1ea9fb5adb90357fbcef668a6dae9cd430365fc16f7ea568f67930e2eeedcc78855e25b8a5b8d90c76659f11f838a22d2eebb2cad8a5b597e5c8c5131e96b7469794f608bfaf375870ebbc3c53c91fc3487e1d06b05305390ef83ba7dd2d920629cac056a1397296cc80afa30a5ee0861822e53727a7cfcf347368b142617da6090cc15c23c7a37e4f01b74fd4e645b5c52793068d89722ecd6d86bbe571b0cfa4f649100d9585c08eefc2828b78b70ab3bba8fb4b305e11f0f21f6d28c63ea59b1b9b09587836a60d1281aaf8301ee44c9bb0865217da2f5bf42b54a2bacb1006075e1e732fb6d1787a45f91101677e3d6af5ed818e7ba823b2877b39ea96793ce879624872aaab2d59a8f2e6e7cfac68632b61787756bfd72faa8240e6dfe3780ecfccda47ed3dd9ec6cfc88542876676874dcbdbb439e51aa1a7ad42592053862686791d4d60ebb53e0b02dd16c133e34c3033bc0422ee98f192d83b15c78219f9da6efd9ffc56c8a9091cb7819a4dac50729ef881e86af3184103cf311bba69dad56e8c662ea9f66d4388ccef7cf336cd520c944289336eca4327bd45dcd7cff464860411d9a75ad56d1007608247e2db5bac3ff785e76470dc75cf7514d25fd8020fb35953519080a1738b6b477fdcfd0bef102a766e2f12275a61995fec8c34a044179ebae15c406253cec9f959715563f9ad69f6f02d53ccdb6cffa4a09d42a156bdfc33c2dd063c868438468eeea688bef5e634e6b99171d227a8df2ec6016ddd097</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">当前文章暂不对外可见，请输入密码后查看！</span>      </label>    </div>  </div></div><script data-pjax src="/blog/lib/hbe.js"></script><link href="/blog/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> private </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象的程序设计(Java)</title>
      <link href="/blog/2025/03/01/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1(Java)/"/>
      <url>/blog/2025/03/01/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1(Java)/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h1><ul><li>封装、继承、多态<ul><li>封装：对抽象的事物抽象成一个对象，并对其对象的属性私有化，同时能提供一些能被外部访问属性的方法。<ul><li>对象：属性+方法；</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网学习笔记(1)：引言</title>
      <link href="/blog/2025/02/27/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%EF%BC%9A%E5%BC%95%E8%A8%80/"/>
      <url>/blog/2025/02/27/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%EF%BC%9A%E5%BC%95%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="211a27179047e22a5a2da13f5fb61a874067bf38e4496b1c5ea777e68299bd22">6df07e4654b2f23296fe416e73f530c96bf04cf67b3d4ddcef59c681cd714fa38152c1497a0d6f1fd5cba657c866d6f56d4071744c36b8eb53888ecc1d93ce6d51550e8875af73d8e81f7fa128c182abe32b8c74b7d6c3356ca7e09035980e20e1bb7b26bcdd6ea1d5a2a3c850cc98aef4dc0fbb9c228ccbcbae915607900b5d42c8093b58b38607f7dd5d45385901e8bb87da5e0ba742089d498b76761a25ae8448c3bf31a8780428e287856a681421309207f98c331eb25af9df37740e8490f58e0efde67aaeec78b000217953b398a51b37f7c9d3e4a12d92a2fc9d6da7b579cfc795c772011c7e5a3a37ac66561232d8e159d3defe9287d26087ed98578833543bd7ada518d5ad394b74b396d9d38a6ac015cd1875734fd06bed9cf090d4e89e5232c6a34c6b31657d82f77372d5d8e4d69cab96c8d754148d6996acb85532adcdb2853994c1bb51cbfd8820924a766b458cb013d4ffba4f315be9620f5866c164bccabbf5faf9cf4571b7c374d0db2d024279712f50f000695eca6c8b31bedbf69aebcb48042ad1b26614261e58170ee743d41d4015a996911c4377b29450d0b891e753442a0f42f1a4d55b53941b8f2ade32d07255976bc75cf13069893d8f3ed536bf3b981b2dcf701d57e7f339c2617e597d87a84300cd0dcc61d576dfd41d6eaf4e1a1e6eb485fd1084fd1504b82cd2ab4ed0b2183644822bb60c29867d618e3c78231a0aeeeb0aa18ec4b432899fe5662848d739f912990a905ef0843bb2f938603eab87c2b2dacd46d4fe79ad9d62b8cfad4972aa873d6c4502921fbaa6f535235da53cd09769f901161442b041d0e2f4f04bd9e9b0a557f8f75c1aaaf48248dba5cb0bb17b5beec461e96024d6d5990a7859bd1c791bf26a684bc0bf59b9935488c71cdd00ede2c0ae99f0b90038751724750f28d744422c697a62f90e9eb2fcc0d95def076beb14e0e46cb1b4812b56968b1c8a0895d74c94dd541a34a3cd8ae1d0741b8d4c860675c6ac892c2faaa64bf37f44e485fd46808dfd3b469f048d75dbefa81b28594467ce9d25bc149498f4758b727b1673370d7c5692600ed879b3bed74f04b75e158a11ccfe4c7d1301892a719f17d8429a9d1d28f4c90351c1ee87d48b7efcd94f0b267b24e6ff0d8728e1680a04cc8bcbdf353d662fe68251e97b5a4c3c966bf41d2bc36908d4ba8fda92b0608b6432f014102f67059da431ff1f8eefdfb646bbfd53cda7fc490e6ca7833bc30d90a79bf61d97cfdc4d7ad1b7ab0a46c07a445c3dd57419e75d3b387d453d6faa3ed900dffdc79c6b3c6fc1c11347045de1feda0d5c047aa2e0be63ffbf21c16cfa4c8b65238799a7f5cfebfe94406ab8989a8ba72c46f52fa320bca8cea19a708cfd480ff33af6ba72b67b6f2a83b726f68f33435f7a4594f6c0da0055bce5e549b3d368d87d2f0b6391ad388e33ab95b3d16c493d7674ed9d10bacd94460fd37130e58a4fdcfcd8592416aaa82e55c47ebe8698921b6af1021f90e30310c850b2141d9ceef682a9aea45cb614eb025401673dae3605ed51e884f1fed317091f60ddce9eb70b4178e5c98669c14574e9cf847abe7cfa9c71ffcc0478d8447e11b21dffdb98177e2027b3fd957f2b703ca54ee979da1108f27c91636027a9656395e4a81c5ee7787fae7bad9dbc2afc8be32da9b3c6f9407d0fbd65861d4483fad97450303cccc576df7586a7270ec6b1b832624b114ad6ed5f86602ad5a5250f55dd227b80fbc19c0c372236faadb734bdcf138053668189b80e7369fdf7b4f9d1e3e3fb63a5c4c72e988cbc16cf4fce33297db877b131d1202616f952498f7523a42ec5912e1478e8f9355ae4fd3f795eb84ca07999df57a690c91945efe710246a75de97df7abd20688946229c473a65db7d9bf2fde60d9ec90e45ef7be92a1fbebfeb113b9f8575a34ec986688f46a0c82d2fba3099f55f0eb90a52101553d0c76d6ac7b87bd49155a027db82711558fb13cb7851f5cb406cd2a36a3c858038e8f0552dc0219c3f806f9f6c83b280d66bebc2c29071c809bb184c46f2cfa345d052eed0a1aed893baadb0626c2d6000c9bdfd23c74f22646a204fc679015710ed7f3be4bbbb45b2d9fa69e338432447464af3be0db65081822c32a98ec4296f64a70cb65f20d815b3ab10bbae632dcb0dcab7412f860b25ddaa5bfb09edfdfc3254082a6626df89e563ffba460d0a47a03017c13c8ed336d2df5dc1f88be4ec8105f6a15a2f98481df680ca1249825c458d2c183614a7172c010a1c64e73742457028d23b1ad496801366cff6ac903d7505db4c9442b2794a910c12ad9a8e1df512f765f2ee85c8413c906a6b0322a57476b837bad07a69d3dbdf3f9962cc229fea82c85227809a2f35074ee62981b155d53773c619726e737f7b909ee5aeab34f37b98314f992fdafc59c9e4512178a946cc8dc8b0bdebcc7066054b170ef58ea2be66dc9def2ae02c54c1ca05ba3486d7a8302e864fb6797cbf9440311621c326cc40578a49f755656059382d20caa0c5e2aae80a7ee12106c60b74d4d83c60018729143b30628ecc2698cfd5fae7e0024f0e3b70c1b402b61be2a57818397c8ec8d5c5ec45f7d61e51a39ef96510c3c07eafc7a64cb7bfb6b61433a2f2ee4e611da7c13c1d1aa58d2ad3bba05106b4a0c46cec1bc5b3d1eb47cf66785381748ab8e839d5264adf1a6d6b2643dfe5ed3019e9f90a6587683b04d71568ffa89be303dba3539edde64dee4ba89230dc95cb2cc6d7748955bf7bbd6b4efb9fea6684da590f53e81756864c8c0f4c5ba5d21edce1721c9e8297d24479e7118b0bb1578331c27b63eef78f3f48c77c3b1646db48e752a7a857f17af5969ecf98d056d4767bb99145792c5415f125b8d62cc7597cb9b1b2d39614e3044ef3182472a08799e3f919db9346823c5576f493574aa009d27ae176851cdc75aba509d90045716b46b16d9abdad42aae8e27a5e6ec0454c0d32a62a12478aa2be3cd5f0a18f73227f811b34f72f3aa093328d6648d279e08b1a7d2839b1f0046f8dc7123ef47c6cab94b9fa5c06cbda62951ae0b2a386c64c612689528ea443c85b89e450a862cbccd76a93fa4a0569b2168f256f72a40d3c6a1c19ef7a05b7247d5c78f1d38b1bdf49cd32b9a406e8956195710a539ccfd6b82a6c0540b8350227e17e5f3f7c6c46b3a6ad263a3a884349fd1a400322dbd9a66f606013243bb7d6b62ab48e0839ffa693a9f019f6c952325aa91fa0f313812fc08a19d0cd919543f557e76e09503e82f683ca9b2567d2da884793cbf8ee43b75158623aae0bd66b546db9e3416ea0e8bf95f80915d90234d858b85c423c74b1288accd3e61f3b2d8d007950399800fb005e57a98ad0ea81b5bb89c694af7a0ba868143d21ce373c06ee32f24d77f71b30dd0891c7295e669abba67da27ed65cc473ef594babe679aafe7e95f8597a22730d65aa7ae389926336b317d276e0674208cbe6a5c3384163da8c19f41862ded8974fd9f35efc25daf08c37709f025e6516f25b5d0e932d9ae31bf0d73af0ea069dad77ece14b0c79d2ad011bfed5bffcd243d9345f0ad22af393e82aa8f5b77f057f4bbce9e71862086e61f5863a303fafc818fd5468a96c3f14b22f0a7c668d06cf6120373e118ccc3df355a5e305066eabb35294c126414f5ec058da87a7b290c2b57ce1c1928ed329884622c0ee8c4bd5a5c60373634b46b68bb0ecec8a5d8369f337f1449cbe46024e4a90aae537a532985c6a1817c88be9201d72285568aceaccce30a5fbb6f17418eb75784a47a84ab7b1771068fdcdf0f1c63541b9f7d3466942974b3192b504d65f87bc2906dc275043396733d5d31a267fbbd8de5e3d657f8841e581863a1bd2212dd6d3e5f7c3c369215339b2ffc2419f1859a4af6aab49def9e214c0c171e219a322fbbbfe80ae7edb8ae1f5c428b99ee93ffd7da3922f72941cfd190d14a782f0754b1e166d7029f30bd146b918783c2d0d73d0b3c1cf81551c978342f7514a372c6d1bdba170345eadb4b06ed460e384a1ef02e764a3cd00c9ea50d051b62da0e83f6927eaa52128e45a4cd58805167b7ba387239764452019a3d0364d7a06e55a1bb16bffcb6986bd0db566a032644cce0eb063dba4160641389ca597d29e87f9216ace924df0c010632d72c497532a41a6a4d7c1898fea403007251a6b9b58bf9c778cbe3decb72ee1f47bf00840718a707b884bf4abe962021a6098f95597d0bd01589969a6ac3ba7b83aecda99abb28998d9b5c409cab4e74c2e13c009f9fb42c4fe0810ab1fd1ead7f0e3f0c978233b494d4c39bd02d159c604f20bc9f864e68b418a62d1fef19f7450109f08715c4e04f6153b9be88d3762b28dbf851252e801acb782b789dbd63676687fdc29c4a78ae6557e3d0ce9260b10ad99b5729ebe9804262f3ac5460582d322a05e08546c60ca9ff97df6ab316da792656615217f3e5789982d733bc4fdbc87c466381f4a781d575923a60d5cbbea2382a38b678f77551d92a4f6e2d5bf9de6e266f0494f8bbe7044c2d629035c887f40374f75d28d7faaacb09d37e1d54f2b98753c3d398d6f275f44257ff428227f4d03a0af1b991a43885922b7facb99fe4556f74b029f0326eb9ea3fa02ce83b163c56dc8e01939d7cd0c7d884d9b1ed2de1bfa1021d2c4194c7fa27a532f0206b4807e58aa56b0f3b3da63ae917191c4f4e77d29206ec496590a87f64a0a79f0f0f6329a00c4cd15b4fd43eba199b43e89cef2e6e43392cba9312f656fbef74342e5f2142b5c91ed8b18c8b1e6778b3e9b1462e54fc0d61305cecae5e2b3ca7edcaf43e4eda5b851cef8af265ebe2f4e2cf05c8417362345935e98994f5cbdf578b78e3a827d9923b88483e8d073b92909a5f42ce062b3f7370e33b19a8758f11f3b08238f917b67a79c7b79a4c914caf316901ed64388dc4dfef6f1e329405c8512134732687e5231721eb63e573f963826e1f4c7ab62aaeec3ab6eee3462d1028dafe5e3eab1ced0772aabc5c1513c9f708c241d35c6e3ce5f02d15d7ff18e944ba69134aaa39a2d890ef221532c37be4fc7c74296e50baddeaa362c9b0156f8ca489c57e1a1e34adf591a56d92d3bbd7395c1def77013f866abe3871b5221f2006e9ccd23c62955efb1a29d65971863348a61945b8af8a6c7b501ae1e8429b71e9c61a4fb49d95cbdbe349b8f7e7323f452a6c1a8e551771ea4eec9f0cb5fb26b8cb39334af1476d2a5feb4dd5a308c9b39d76729a83fa8e74da2a76ee5fc4c9f6051c5c39c179590032d5424cba74538573841ad035a6e3d7d2254bdab3e81e0d02cea6a3af719331c12cce660cbcd41e0514368fb229c5669eb895add7ff6b94d723d34796b4e5b05a7869c4d578fd30f9ccd3e18f6cea796a56fa5e1b2806b12be8a61c621ed6efd27eefb11bea8d927cf01721e29acbd508f77e98dbf7d232d5379cc33202b2eb91cbbf9df7881e2b25a24da6875290f2c28ee4cd5ab46df04c1365ddba5d6046dbef53a271371a7e8a0c82c271e065e20c4cfc42de5ddcd1f3c6041937ddb174700c795d37d7e85004cb4c3dcb7f74f61e0456f459311111e29c163670b7beb476ddabfb10537b175c77a4272e7ba29ffdb9b1558576d636b4eead00264af786ac9f4433257493225bf50373d168b62d8dab79544c8128f9664c75b170200f4511d114295e0c324db163f0b2b64087954074c6802df4559cfed6d471b6ddf068505d72931392a49a76efb5f19b62eae2494b07d747ab88add1bb1712af242b128cd800ff5707a4a905074bcb606900251b4b7fb3f6651cf9baaa99f5ccbaab037eb841181cece2021dbff4c85175c40e8d846ff657d8d446a0703005df069e5c59929fffb1546998face113fcfbe5d34c11b2b246125d0ed14c168dba777c4fd954512973572384a869b980601d2d1eb0c2cb225038c733963cf83d13b847f2eb5894804463a734d85fad0649fcbe445dc0cd8afca092529195aef47704d557bc8bf7ba9e63a27dade4496d1eb3729e20ee45e0615d9d84b401ed0519e876fe6b7c6080faf81b68a0d8880f6e152831809710bbc302ccce5dca11fa87cd310469c88cd7cd2c55d3eff70e79d33e58c99bcbaf631d9c6d50d0f56cea50b5d5e79b230987f0cc64fb6238dfd1ceebf52338dca67b45c5de6a24e4f8c2580d6d25297ee875c83289e03f2004e34bcc08f7076c32ead73d2bc29920f758bf3d76522cb3d5edd0f52b24b7f57410758f4bf083f890ce207655305004387a84dd374ced61a9b49c8ce08d4b7fae04d67c8cf7753a83bd45deac7f521501767af6fcbb251a5ad083860a7fc35eeb1b2c9b2e9409b4f9e30959ad08cf12ee2f6c0130d481c3004bc8dd5e925c78d64cf3577fc0253c82ee3d9024a0ca52add6f0b38a0ca062d03d5ba4b4d9a3513c1582e4c9e93dced20450cf660e21ae780f3d315d78fd3b8ba30f818a1fdbe69510dc3a3c14bb84ca2d04fa0dde1a43364c78eb0c11b8cce53b2f404c72cd5e5834c3929eef0d67995011ea689da6ff1253e2f2bdb2b6e78a2790f958cf7a79dfa5a88cdf5855feb92e1d39076cca8ed793ded3aff309fbdc8971571ed592e42d3ac11ca1f362b58b308d122c5a452547afc109a482c7e5c448d366be4e1c36daab02fff6cfc8236fcdd69f31677c81f483832d4808a4bde5d5d387f4ba5cbe60508d8b168057ebd5d6fbc0cb245e9b165b9377f719f27184e53b831db8326b40fcacd9f0115a4c150e63f217a4d35d517094bd3d7fef841da9ad905b0e6d36e8f5c2c16c834c8bb62008c8d7866847a52eb19c5e452bdf35edfe50993f73b849977c12d3d0ae5d5c5c48e30e921c7d26c0c7a514847faa7daa4e170fe5246810db5dd9f75405a1d588d485de0e804cfb05b8fdd7d08adc76718bb3161f08383ce41b5edf614fcc044b4fc50b329f0adce2e078c45b9905069c5625cecfbd4d415cf88271dfe049859a1cd3cca554a0fd0182782534dca20b922f302352aba38a5c237b67fceb2667a08be38addafba2bf1321144278d740f8e239348182e4f93ff2d8e3470c85f67cc34020c6a9874149e4956a8ac5d8868b24f57485a0c966f09d28de960a9be9119e82b55094044ffca06c04d1bbac59e68dfcab7832632f35043a1bed51384c5593f7f6cfdce8a757bc79006f8e5a50b93d05a21878f083c3d7923f48ea74eed0116cf475b2117f06995c4802b6914ae310f7cc98ef74b6ee8e0c560949c729c82e9cb93d6da543b76a5db4b9146450d92feb9a6ae58ab65327fcb9cd57a317ac44a1cd83163f16286d6138424258ea2620c0973af82b48c4318914a9a263399a9262d2c1e1e8aa92ded5a75d9ad3873c81840282f5eae12aaa4876cfc25c37f0301ad3b5d47066be4887d4154147a9a3b8a12655b361ee3e21c465252faff623502f9dcbcfee0786762a2ed677fe6a03a0d369e8ef6ec2609222995fba0ebdefe76f74eaf3a3f336f3f2725df2f2ec7df6fe69336b5f0a5600266eabf2f7333dc740657bcf053152bad6caa8509d5c36f37a9f01159e8ef4ba93769860ed360be662d4f9bedbcfebce0d8534d609273cb545359362ab82e2838bd469ff81b280baf483e29e70fb9b415780823435d01865ad52079c32cada8553526ffcce6fbe1851dd1a4669b23d8a3832e05c540ea17413764d723220dd0841674516a931b8292a2bd2fb472271c848c3a93b5dea9db095785ec19d28464999268c6a00074874e338061e7425c6ee8ed119de1655495f501cf8842ebbef28f9d86b19bd5c4c5ce27479ff49d1591ca14adc924c59d1341d6aa66db4aedf83692ae9dcd95c41b9e43395cd8ba7608f5d0b3fd7436f8c1d4462b53ede1b5e4f0f977cf927ffe64d3ef60ab3a09e895e0943fdc7957552bf0074b7a9383900a724f2f6d785c4eb6ead6abdc885be8a844451e8e925d7a30b155c4c899e458f7507b69c8b781e8076a67cf5914f8bbbc0845221ff20f1474f7a4683a7d0b2e85a00ed28f4bad7b673519d568db8e885cb748982e3e6bc70a1df5ea36348bf67a7fd6a85fecbf07842db5e596d63ffa319841f81550a895e0a7146f9808d55bf7d8c325acd35b6f6369c561b88e96f1f40f4290d40ab39e69723499ba37daa60d07f878b2ed5f268736e8716d8a07e74c8a7097dc7a1e6001852706c6275bc63311afb35dfaeb25354653df675aebb464d3d4a048e82c749b985e72ad7140512a0b96245be6e53fead9d06753a5f565779d1ee168804ddab52ef5f855991545661d94cd0821dcff09430bd28d5c7e29ae86e577783e4c45c98eca6e68bb69dcff50b6a2f716571916b1a6b7fe930137173eb8a7bf9d11cfe5de9715f8384a38a70d91c2a2ffa02ad14235ceea491f542bdfcbceef6015cefede5ede631dc763912b20537128aee8091396ce1596cbf7e2bd2f446cf80f80ea92d86c03ea16388a499dfeb24100ccdf916214116fbb0db451989b3e9c1d36508c27242a7dea8d475acf1e695770187cff012c6d680145d8d0240c1d82e2774fcf7adf166d4ab3e15bc3827f4d662a94d111f5ac2f55dfcd690d5090aff50c657966f5a40a7a08aeb9790441be6e280ec549db8abd48a9c0c953ffe280cd635c0cd8816adecc45667927632ee108c6cb518f345bf89edb5da047b5a0d20cb3a0a1770279ae8fa9ff109a2d4f94aa99a5cd0c90e094c28e17dc8aef6f15d16ec0f90771c961b04a91c3d5939ae06081be8fddf82da11af8195f4b2b0fd4eb01366dcedde7fce826b32abb77e7ed497cbb6bffa049ac32be34851be0727e02803655b17fd1556931d9e27c7dfbb500457914bfdba4564a5e960ac45c2afbeed1d8d9e53955e8988a6acef0f2a6a566c5a5d9357249ddbe008227ff6b4cb105d2a0c4aeb34352aa9d9989ae3146a485384fe512d57605fa31cdc6ce695e5adacb8c97fb9226754cd0b16ce000d8c36c2419dfb3c926614de25cdaa59d7cf68e51596a37c326f19339c0230f3afd5d5ab84701484ba02f93682f1b5d7af2a0bee14a352fa3660ba685a63b003ccc2bd75817d3f8ba7ef4021f6b606b230bd2cf9b6e803abe2d05382844dd5acc75b7c012f160b2019d07f3e5d1acda744c6017e94dce2cd9bebb2cc33e0153d9031c7cb7f1d5550375fa99dcfc4da9d42eac6bce19860860c87dacff2c40245570ab840e2b385c818464f37937644483d831b476a85bf8fc5bd6b3d9bad2c9dc9b9afa8d4e5cdd89dbbf4fe9d7fddc0a8eb6c96d66ae111b467cddc73341f6f3725a67b3e8c910f93c7ebebaa9f4b6c2e7923e8396062462dafee65ba05418b2099193b7025e9336c988aabf786f3d5bf6be039d9f7073bb1349c2f13e532196163d49793ee006e0e43a4c0f26415f5965e10f54e7b67e2ffe1861bcf94e4ec8738936914c96b76601d5d8a762d6d010daf9e8ae93bb3714ace3913ce989d05414b459d01ef2d18f89b12ca69450f6745e7d8ede12efc88faf44b643bb9ede55ae6458378e144a27f4c6feea1b435e4f14beb9513e23c125222f004dafe2fde804b7c23d60ffe002933a0c816f0fafd147b251098acaca51c551c08e75a6e2ae97869d91565f23b3c4ab12242ee810c83611fcc868dc37ed6e8eb2123c0a6eab125f227084249f02a40addf7a24bcb0641e88ce7fb4058cdd0e7115b8b297badf06bac7c2ad69e82d39f710fc03f9d89f0e55266d8a253fa5512db2ef968c5a00a052631f91b5fa679da745baf50e8368d8cf1c103e1f5de8217b16a58a64c299c40166994e7caacf320f6ae7b1fe27e5d1010cf2b21a10f8a030eb5efa6c1a2934aa3cc8aa06f14fed86f21785135f55c3ac483a32e5a1952ca7f65b847364110dca3ac066dd35a8fc70e3ebb791567ba562a29444799a27cd358ee37aa0ea753a50a8e245187037900a92da0bcab1d274f4feafde6ec82166a027d3fa8c158acdd65b49a1319b5e1315ced7affb1ea9fdfdc99af4605cfad0d68588cae36be3823ce625b5d6a6f4184ff9400e2d610503af3662c55d9d00e64440a8d4bd9c0e620e80593d385f18c47eb120ca842a6259f32c58558d9c685e45648fdefe732b1366e5dd3a690a770d9f0bcd9c1b782f8efbc2fc3fe6b11b45bf5db39a9bd4ef312cef8b5c354ac498c3c93eea8711144680e49af94553f656983e5cfd1f76627ae48179e45e9eada968c70faa498cf31e6a6e1baddbef6ab79bda0247b19c0c81c9e378e52af58bf7824ca924f7afadf8cec8d658897aac5de000682acfaaaa4df2f3aa5a1aa91e7f89b00bb4cb9982895dceab5820894f0205469de8b67af9c71b7d3ec360574872f8009bb778aba77f65d90ededd1d3a1ad822d5ed5b16999b079bbc7e2313f8177e9f8a8229638224c047a7947fc1247972dcce517513feaf2d4767a8ca5ba6d36a06ee4216c82d98c261568f4d688c7b41e18e945c7e511bb2413f290c819b1ab9072749838578b6987371f3e8798477abdb1df1d98f3f9011d7b3d8dea1bb60af960ed934a80b0bf1fa5fd6908372e4f920cff8591f8e4d0c07f8254a4c4f825fcacafb1ceefddfc39eb09a4b8d5d15f50dc222a75f10b36b341e5203eb707f279caf535b6c48877b012c37e74f6a0cc6d6e3d03c517ec91587adab63a8d9021709e1631168966e9a04710cac429d67b75df1a0bc2e56707eef9971940f24b48dccb68f9d4910638d4341b9308d911730cfc4eb2fc3c0bb61d1c29dbdf66041a76ddf62cc54ca5d45ee0c6b249aa3be0ea6791f51cb07b596e03d30077a69944cea7832a31c0165bff729bd994ecec1423a4c79326eed2d0d7d19149ecbc097e73f04687511f2635ec78c47eded6b55960791c42896d87631bba9f21c217f3c29fd7f8c963f3b3643938f6f1c36eaa6deceaf4fcfb9f4ee94954da3f00aaddf90e56c2eaa6f76db47fc1af2af6d80fed56f3aaf788d665109ef506ba8ae8dd3476be6ef861e54e90e1f1d304a74040f41d2b0c9ae15856f1569b522d7ec1c3686cc56a0245b186877e879b3b13eec3aa8205e63b4bcc96acecbb8bcb83bb7a9769706c9a19aa1a634709cf43f95ea0a0cb6ed02d4cc578b23632e283308a010343dccbc3cee0554b40799f43f60619742730bd8484a7e01469c7eac55838be2488fe6623e156bbe629214575121d0f4c76d2647b12be08b11b2e1d578fddb6bc4e1e7f961fc6d2846989903edde4002b08a70104935d50daf1f41fe7d25c29dfb062b98908c1e171857075236b8d044a86edc17ebe9a3103addbb0f2f878abaff7ebccf91a33309666f6befcfd7441913c78ae926042a43e858389cad945929a7d8328aea9c0218492e3e7548c34c7bddccc5af00b5d62a288457a673ab1abbc2ee58a3bb8bc7987480b96d2835bf6f6af0c6d86e2d0108d6c749ad3d9e6461d4f9a17128d4a44121ca8fc7e1b1882863da7f42d880e3634c80bcdfd20b87c67fdbd2e83951fb23efd6601f085ecf99fd1d3f5f724cd0f160d0f87d8debf6ed6405fdbbe5b186499987cd07b30baa35019a06143c04c87326c0da838257b73d25ea9adf4128c86af4fb34aa7ea64a72ce81bae88d794d8bc7fe362adfbe2dbbf839a6fa11400dcf9223b722583d0d8ce9566307e2f539c521a78660d258e887b60e1b3e64e521d44c91a9cd1cd2ca26cdd9abb97f333e22f0a74099a0c9d162cc66e4d5f807a875160307b1ba77dcf037e7bece2a104a96d020d1884000b398c1cef66fa4996ac14e71b8a1ab1bf512c7b9e2548ef65de978a7658d674660d9710bfa82d3a1a1f35ab6c4d5a349bb7dd68ae75ba350a7867d21ae89e2ff55048427fb62ad8a5e66df0c4e428ec31c764ccd0fecc5e4b762917efbf0f020def4d20b953604ebf5b93b3e1aa2831fc108abf2460566c664c7b8444fff8099c4a41a75199ef59c0d939ccddad9dc907977ee5205979c2895657e80b49bd1e525f9590e9f8d49e59e039336da95e06935830acceb635b5db226df348d703a38956ea7d823a6feee22de035734ba8baec0eb6392aa668aafa84cc012b1c53800a0a498eb8efd0f6df85d25c3f37dfbce02088f524cfedb9be25fa000343cbef4be0beb529d8efea2088452d990a4130be746fb901f8646d93a443e132c3f5f93bf3b7cb611b7f6a0f5e5429833e45334ce4ca967ce7810c04de99d4be0e394a8f9c1f363e920e35c7b1158e50e8c3b4e3611c77f885c89c5f71c8bb171d248e0bb943cb37e31a36946fd142b49d8aecb35dd01c4a5933d5978cd5e2241f94d5fd404bcbbecf03efdc38d461ede602a93a837e5fd3a571c82d135a2818e2ce0b1d84b27add5c310d7b22b5d848a02f0c5cbb87bdda767950e96db92929c35dc2c114873a85f904d92b844c91f5301d161a235ece0a9d72b46f52443953c00b2a241c6e76ccc64071b30f38a3f114f1ed4b5a7cdd2207196cffb67647a54b607f6ad59f37d256b39364308271b156a58d897f6b1b217fe6f8973e63b7b5e1f5a3bb55b119b0a9bfc9a6cc7369496bfc31b64b76d32369dd17c0f25dfe2e5a0bb2de12bf7d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">当前文章暂不对外可见，请输入密码后查看！</span>      </label>    </div>  </div></div><script data-pjax src="/blog/lib/hbe.js"></script><link href="/blog/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> private </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计组学习笔记(1)：计算机概述</title>
      <link href="/blog/2025/02/27/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E8%BF%B0/"/>
      <url>/blog/2025/02/27/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="378d983fde2a52f100c6a892dc6aa0f4f50195705ab72de831739b4afcf84c45">6df07e4654b2f23296fe416e73f530c96bf04cf67b3d4ddcef59c681cd714fa3d4a00212cb63781011cb4fee306dc53aa11fd2af0629ad99cbd395d18f1da35e488390b1624ef1dfdae8e5da0809c6f8ee0f8daf76948646fdf6ed1f9aabf9b6df1cc30966c1cc8bf6afd7a5ece917244a85a6ddc126ef29e9b1a8665dafc856acb37f340d306174e9fd9b5d38b286b6af4d9278d2438d7a5c354aa7e6663712b1785744587b8796556f4971a502d8f42fcf3b8dd5458d2e0da79c708e571cb0ac417bfe65348ed99655b239c5b429cbab549de01d9a6d8a108e27a9037e1cb02ce9a3870c30eefd7020cd8042af78449043dc0af07ca57c50d599a1a6a440322cea84e6f833fe265bf62d0e72688e9646b7d0b8d340ab3441df1ac8182ff83c812930f15109f66bce7bb97d62f3a2b52caf0ab1df62abf9c59b0d324e901a36e4d47ac533fcf56177542522ff9090d3e05bf871bfb88f240eabf69691b9037c4798133eced75bf25a983b0e372aea48c848de8f979eb1f5ecbd90a6d647a2372e88292f5e82322fe81dd32ecc5eb5f0114027c974a51be5d97fba15e0a3139049db5fc628c0163ffa46c5eb140d9bb597ef49a005365f3faebf6441cc06ffd6e68507df322b22452830833dc547bd2725b588ba8dfe37ec528dcf6b14eee9952e660c00e9a18e18e91140ea907d490d8cfbb9a26e0670d7aa569775061cb02499b92cd65c5614539c855c2b24ed74b90243ed84b514d1b84fdc17db43ae0d5dac731741b2514ebbe19d7964050ee3ba47b9828487071b5e9615ce4810ff49da25ad87f3c1ffafbdae07f4e53ad83a329f71ee857dfb2e7833aef8d4311fd5bd90dac66c532eb0061f7c03b2d0be7e5a7fad59084928cadcf9c8204fc7ae2f751766d666fa28f7a6e9f2ec5f588d67ee5eb4f99d0b01ac82edd975de5b489d0c54e86c9a9a1058ae6e782f7c17be7b2da9351380d77f3cdc0ee159d2e6cedd9b583484e99ce226030c2a859c5b779e50195243fa3d32738fd2d601a3e92d5ec2ea1ca990f2901c4b6b9190bb2eed4ab1eaec49ad6caf7f4f90e9f59b85bb5e60985de807313adb1ae04b72cac260837f0b7bff909fc2aa028a5b6401d85d9948cf04dc9306122d0ccf8dc353dce95cc6d601b70ee3028095f14a7d645295d4afb94454987e0281817977dc994030118655aa00fa1c250db10ee3ced11ccc229a04e9648c6eb7c453ca72c40fc6a0dbd4e3713786ba97291b20500747eb1891ba76d65401929fc300a8017c7d5ca156f486e22ed1cc2b58f74d95697d0d555077454203e5482d7d5d635536d1ab21f62e1d8e307f6e5b7f1b63723c96d912e42ea3b7692069ba418cdd10648bf8a55344a6f62d83141d14b0ad6317b668432d12e07ef5e4a23ba393654af812da0e518d2e5d3691a93865a49d764781cb4088b3863929b32dfdd7e76a69e046abe52b64635f9cfd6ddec146326ec085d5aa4ac02576804216eec19ff936476c767ea6c605b860e11c213653ca1a37acbc48d1174cb42da728ff45f17e5c56542ce70c628777f988c0e782bc00d7c092ba02f0b28f89c28dc22efee6f17fae25119fb3b75d22b78a572410d2d3e1376518c7d9e177a9575b5d7b8d2ee77b437200ef9345acc720e2069f01cd9b31cd488f770f646e97ea5c42d1d519372ee52d9209c80f301afb9ba0d3b955fe2b846db03e4e67bc12b38a3570eeb576b4dd7d4423e410061d326d0a6e255487f787e0bf01145010175c068e4d337e50ce6818638c84bed65d190a06d16cc8589ecf52c5bcb5840e4628bf1acff76a37679ef086f30ef52efb15e5ca88ae16c5daf5ca64aaf53cd1516ba23657fae940b7dc345b83fee708164e6763bbe8f647bb77f3add5316b2abe5ae8019fcf3d67d7c07ef5f32e1345e6c34822b0e1ab33a89afb57d6e3beff9fb4cef54b3cc48ca3c4e0ed94acc139acdd8d0e6feb9840691516b202c46dd239d0e18ec55dc83909a3238b75f65a5bab8705be015b31c08f6f687de6b1b152be4ee1685014f69b98efca4b4c7d99567b80d8f21ef4b4fe1a6b0a4b93bc1f29ebd8dac3782f51c94e81c1bc5478857a9245f9aa36da0dcc436a0c6443e2218fb902754e89e4ba60fadb46145bbb16dc3eea9887dc14c3d2c8afdda9555c577a04e7a25eaa3312e5007cfd23d55eaad45961758d959a69b2184862eec998178d9344a312eaa9bf1c5948d79b81573e1371ce61110c9ce286bf3450fe12f67681bece98c10ce35f443925cb70e4ac7d779273a1698298ff0448bac5820e2e561b01fcb4bb68e99592985a1228736de922ae331020ff7ab81dc2a3cd87981182df73d89ea44e2465c1a9707f39f0ff839c24f6189789ddfd9cab8e41ec567c5334fdc0ba6feef55131f56836b4f91edeceddd8ba6c089236366b3b23868f2188988519b3221aab71b664ea49a982b4b58bc46b18f85bf9da6186db48db3861fb7ceb8fd59dbab7da16aa4d94f5f8d0151fe84511623d179839b0fbb4f14ec4866b47d0d0f1ba12b3679dc00a4ae91ac512a1609ad53af574ec21b49990376a544a6b8f4a85990a05d4a01ff83f805374bc19c38e376daf30cc99462506391f966544cb7737ab0e14b8256dd445686ba3ea2ab02cd73403bcbad411a48db844c6ccc5bf51999e50783dd659ee9470ac41a713cfed159a7eb4d2fd0137e1f16408e4e3c937ebc2ef8e18ef2cee262a28796581edcb8f236b5af6161ad36b5951c61e7c5dea715ffd49cd27b498615882ecc62fc56bc699826e807b65085a250c83cc9dbd5e855e77c6d26ce914fd437bd13962098a66a6c46086227848df5939bd3d4d23a56c50f485b15f092cc3a95ca6981a22bf094d7b114108b092bf3bedd246a33393f0af43230d7f20913d6eeecbef5bf15d444d4f4e655105a838937e4349f3e69cdee42f48264d4be355434fea3c205c13adc75794c1f47749278830d95aa040bc936a6089ceea631be2573639603dee817fdf2c5441a6934877eb332d69db73eb35a5eea1f5b473cdb52e3e5e8ea3d20e69387ad32329bc9013094791819549aacd958fa30fb6ebdba0cbe25792d1f2913b416c90ccaeb5211df02412effae7209b4cbde2bc9c3adee5d3bcc5bce68aec932f47739b766290e5b172c28b47dcf2379b5dcb1bc9b064f406e394</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">当前文章暂不对外可见，请输入密码后查看！</span>      </label>    </div>  </div></div><script data-pjax src="/blog/lib/hbe.js"></script><link href="/blog/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> private </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RAG（Retrieval-augmented generation）个人学习笔记</title>
      <link href="/blog/2025/02/22/RAG%EF%BC%88Retrieval-augmented%20generation%EF%BC%89%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/blog/2025/02/22/RAG%EF%BC%88Retrieval-augmented%20generation%EF%BC%89%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么需要RAG？"><a href="#为什么需要RAG？" class="headerlink" title="为什么需要RAG？"></a>为什么需要RAG？</h1><p>传统的LLM模型主要存在以下2个问题：幻觉以及外部知识/最新知识的缺失，RAG可以通过结合基于检索和生成模型的优势来提供更准确和上下文相关的响应，可以添加自己的预料构建知识库。</p><h1 id="RAG-vs-fine-tuning-a-LLM-model"><a href="#RAG-vs-fine-tuning-a-LLM-model" class="headerlink" title="RAG vs. fine-tuning a LLM model"></a>RAG vs. fine-tuning a LLM model</h1><p>下图源自<a href="https://github.com/Tongji-KGLLM/RAG-Survey/">RAG-Survey</a><br><img src="RAG_FT_Table.jpg" alt><br>结合个人理解：</p><ol><li>RAG更适合知识库需要动态更新的情景，这部分数据不作为用于LLM的训练数据，而是通过LLM的能力进行检索。</li><li>RAG由于采用检索的形式，数据来源是可知的，而LLM是黑箱。</li><li>RAG 可以对生成过程提供更多控制。</li></ol><h1 id="Query-Classification-查询分类"><a href="#Query-Classification-查询分类" class="headerlink" title="Query Classification 查询分类"></a>Query Classification 查询分类</h1><p>并非所有查询都需要用到检索增强，需要将查询分类为需要使用RAG和直接用LLM生成两类。</p><blockquote><p>持续更新中…</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RAG </tag>
            
            <tag> LLM </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NSFC爬虫练习</title>
      <link href="/blog/2025/01/22/NSFC%E7%88%AC%E8%99%AB%E7%BB%83%E4%B9%A0/"/>
      <url>/blog/2025/01/22/NSFC%E7%88%AC%E8%99%AB%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>从国家自然科学基金大数据知识管理服务门户爬取论文数据。</p><h1 id="搜索API"><a href="#搜索API" class="headerlink" title="搜索API"></a>搜索API</h1><ol><li>打开浏览器的<strong>开发者工具</strong>（如 Chrome 的 F12）；</li><li>在网络（Network）选项卡中，监控搜索的请求；</li><li>找到接口()[<a href="https://kd.nsfc.cn/api/baseQuery/completionQueryResultsData]；">https://kd.nsfc.cn/api/baseQuery/completionQueryResultsData]；</a></li><li>其请求体如下：<pre><code class="lang-json">&#123;&quot;code&quot;:&quot;A01&quot;,&quot;fuzzyKeyword&quot;:&quot;&quot;,&quot;complete&quot;:true,&quot;isFuzzySearch&quot;:false,&quot;conclusionYear&quot;:&quot;2020&quot;,&quot;dependUnit&quot;:&quot;&quot;,&quot;keywords&quot;:&quot;&quot;,&quot;pageNum&quot;:0,&quot;pageSize&quot;:10,&quot;personInCharge&quot;:&quot;&quot;,&quot;projectName&quot;:&quot;&quot;,&quot;projectType&quot;:&quot;218&quot;,&quot;subPType&quot;:&quot;&quot;,&quot;psPType&quot;:&quot;&quot;,&quot;ratifyNo&quot;:&quot;&quot;,&quot;ratifyYear&quot;:&quot;&quot;,&quot;order&quot;:&quot;enddate&quot;,&quot;ordering&quot;:&quot;desc&quot;,&quot;codeScreening&quot;:&quot;&quot;,&quot;dependUnitScreening&quot;:&quot;&quot;,&quot;keywordsScreening&quot;:&quot;&quot;,&quot;projectTypeNameScreening&quot;:&quot;&quot;&#125;</code></pre>需要用到的字段只有：<pre><code class="lang-json">code // 申请代码conclusionYear // 结题年度projectType // 资助类别</code></pre></li><li>观察其返回内容：<img src="1.png" alt>为一串无规律的长字符串，初步判断是经过了某种加密；</li></ol><h1 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h1><p>页面的HTML文件：</p><pre><code class="lang-html">&lt;body&gt;        &lt;noscript&gt;            &lt;strong&gt;We&#39;re sorry but 国家自然科学基金大数据知识管理服务门户 doesn&#39;t work properly without JavaScript enabled. Please enable it to continue.&lt;/strong&gt;        &lt;/noscript&gt;        &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;        &lt;script src=&quot;/js/chunk-vendors.559d99e0.js&quot;&gt;&lt;/script&gt;        &lt;script src=&quot;/js/app.17b88e26.js&quot;&gt;&lt;/script&gt;    &lt;/body&gt;</code></pre><p>在网页的 JavaScript 文件中，尝试寻找相关的解密代码，最终在app.17b88e26.js中找到以下内容（注释为后期补充）：</p><pre><code class="lang-javascript">function g(e) &#123;    // 定义密钥    var t = p.a.enc.Utf8.parse(&quot;IFROMC86&quot;);    // 使用 DES 解密方法    var n = p.a.DES.decrypt(        &#123;            ciphertext: p.a.enc.Base64.parse(e) // 解析 Base64 编码的密文        &#125;,        t, // 解密密钥        &#123;            mode: p.a.mode.ECB, // 使用 ECB 模式            padding: p.a.pad.Pkcs7 // 使用 PKCS7 填充方式        &#125;    );    // 将解密后的内容解析为 UTF-8 字符串并转为 JSON    return JSON.parse(n.toString(p.a.enc.Utf8));&#125;</code></pre><p>使用 Python 的 pycryptodome 库来实现解密：</p><pre><code class="lang-bash">pip install pycryptodome</code></pre><pre><code class="lang-python">from Crypto.Cipher import DESfrom Crypto.Util.Padding import unpadimport base64import jsondef decrypt_des_ecb(ciphertext):    # 密钥    key = b&quot;IFROMC86&quot;    # Base64 解码    encrypted_data = base64.b64decode(ciphertext)    # 初始化 DES 解密器    cipher = DES.new(key, DES.MODE_ECB)    # 解密数据并移除填充    decrypted_data = unpad(cipher.decrypt(encrypted_data), DES.block_size)    # 解密后的字符串转为 JSON 格式    return json.loads(decrypted_data.decode(&#39;utf-8&#39;))</code></pre><p>对网页发送请求，成功得到解密后的JSON文件：<br><img src="2.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵论：矩阵的LU分解</title>
      <link href="/blog/2025/01/15/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E7%9F%A9%E9%98%B5%E7%9A%84LU%E5%88%86%E8%A7%A3/"/>
      <url>/blog/2025/01/15/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E7%9F%A9%E9%98%B5%E7%9A%84LU%E5%88%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="矩阵的LU分解"><a href="#矩阵的LU分解" class="headerlink" title="矩阵的LU分解"></a>矩阵的LU分解</h1><h2 id="Gauss消元法"><a href="#Gauss消元法" class="headerlink" title="Gauss消元法"></a>Gauss消元法</h2><p>在介绍LU分解之前，我们先通过Gauss消元法引入。</p><p>对于求解以下线性方程组的问题：</p><script type="math/tex; mode=display">\left\{\begin{matrix}     a_{11}x_{11} + a_{12}x_{12} + \cdots + a_{1n}x_{1n} = b_1\\    \vdots \\    a_{n1}x_{n1} + a_{n2}x_{n2} + \cdots + a_{nn}x_{nn} = b_n \\\end{matrix}\right.</script><p>其矩阵形式为：</p><script type="math/tex; mode=display">\begin{bmatrix}    a_{11} & a_{12} & \cdots & a_{1n} & b_1\\    \vdots & \vdots & \vdots & \vdots & \vdots\\    a_{n1} & a_{n2} & \cdots & a_{nn} & b_n\end{bmatrix} \triangleq (A \vdots  b)</script><p><strong>Guass消元法</strong>的基本思想是将矩阵$ \boldsymbol{A}$通过初等行变换转化为阶梯型矩阵，我们假定该过程中不涉及“对换变换”，变换过程如下：</p><p>记</p><script type="math/tex; mode=display">A^{(1)} = A = \begin{bmatrix}    a_{11}^{(1)} & a_{12}^{(1)} & \cdots & a_{1n}^{(1)}\\    \vdots & \vdots & \vdots & \vdots\\    a_{n1}^{(1)} & a_{n2}^{(1)} & \cdots & a_{nn}^{(1)}\end{bmatrix}</script><p>若$a_{11}^{(1)} \ne 0$，则：</p><script type="math/tex; mode=display">A^{(1)} \xrightarrow{r_i - \frac{a_{21}^{(1)}}{a_{11}^{(1)}}r_1,i = 2,3,\cdots,n}\begin{bmatrix}    a_{11}^{(1)} & a_{12}^{(1)} & \cdots & a_{1n}^{(1)}\\    0 & a_{22}^{(2)} & \cdots & a_{2n}^{(2)}\\    \vdots & \vdots & \vdots & \vdots\\    0 & a_{n2}^{(2)} & \cdots & a_{nn}^{(2)}\end{bmatrix} \triangleq A^{(2)}</script><p>若$a_{22}^{(2)} \ne 0$，则：</p><script type="math/tex; mode=display">A^{(2)} \xrightarrow{r_i - \frac{a_{32}^{(2)}}{a_{22}^{(2)}}r_1,i = 3,4,\cdots,n}\begin{bmatrix}    a_{11}^{(1)} & a_{12}^{(1)} & a_{13}^{(1)}& \cdots & a_{1n}^{(1)}\\    & a_{22}^{(2)} & a_{23}^{(2)}& \cdots & a_{2n}^{(2)}\\    & & a_{33}^{(3)} & \cdots & a_{3n}^{(3)}\\    & & \vdots & & \vdots\\    & & a_{n3}^{(3)} & \cdots & a_{nn}^{(3)}\end{bmatrix} \triangleq A^{(3)}</script><p>如此继续，如果能进行$n-1$步，那么可以将矩阵$ \boldsymbol{A}$化为上三角矩阵：</p><script type="math/tex; mode=display">\begin{bmatrix}    a_{11}^{(1)} & a_{12}^{(1)} & \cdots & a_{1n}^{(1)}\\    & a_{22}^{(2)} & \cdots & a_{2n}^{(2)}\\    & &  \ddots & \vdots\\    & & & a_{nn}^{(n)}\end{bmatrix} \triangleq A^{(n)}</script><p>上述过程就是Guass消元法的矩阵描述。</p><p>在上述过程进行的过程中，易得，如果Guass消元法能进行到底：</p><script type="math/tex; mode=display">    \Leftrightarrow a_{11}^{(1)}a_{22}^{(2)}\cdots a_{n-1n-1}^{(n-1)} \ne 0</script><p>那么问题是，如何判断$ \boldsymbol{A}$的前$n-1$个主元$\ne 0$？</p><p>回溯上述过程可知：</p><script type="math/tex; mode=display">\begin{aligned}& a_{11}^{(1)} = a_{11}\\& a_{11}^{(1)}a_{22}^{(2)} = \begin{bmatrix}    a_{11}^{(1)} & a_{12}^{(1)}\\    0 & a_{22}^{(22)}\end{bmatrix} = \begin{bmatrix}    a_{11} & a_{12}\\    a_{21} & a_{22}\end{bmatrix}\\& \cdots \\& a_{11}^{(1)}a_{22}^{(2)}\cdots a_{kk}^{(k)} = \begin{bmatrix}    a_{11}^{(1)} & a_{12}^{(1)} & \cdots & a_{1k}^{(1)}\\    & a_{22}^{(2)} & \cdots & a_{2k}^{(2)}\\    & &  \ddots & \vdots\\    & & & a_{kk}^{(k)}\end{bmatrix} = \begin{bmatrix}    a_{11} & \cdots & a_{1k}\\    \vdots & & \vdots\\    a_{k1} & \cdots & a_{kk}\end{bmatrix}\end{aligned}</script><p>记：</p><script type="math/tex; mode=display">\begin{aligned}    & \Delta_1 = a_{11} \\    & \Delta_2 = \begin{bmatrix}        a_{11} & a_{12}\\        a_{21} & a_{22}    \end{bmatrix} \\    & \cdots \\    & \Delta_{n-1} = \begin{bmatrix}        a_{11} & \cdots & a_{1n-1}\\        \vdots & & \vdots\\        a_{n-11} & \cdots & a_{n-1n-1}    \end{bmatrix}\end{aligned}</script><p>可以发现，$\Delta_k$即为$ \boldsymbol{A}$的$k$阶<strong>顺序主子式</strong>。</p><p>所以，得到如下命题：</p><p><strong>命题 1</strong><br>当$\Delta_k \ne 0,k = 1,2,\cdots,n-1\Leftrightarrow a_{kk}^{(k)} \ne 0$</p><p>于是，自然得到：</p><p><strong>定理 1</strong><br>Guass消元法能进行到底 $\Leftrightarrow$ $\boldsymbol{A}$的前$n-1$个顺序主子式$\ne 0$；</p><h2 id="矩阵LU分解的步骤推导"><a href="#矩阵LU分解的步骤推导" class="headerlink" title="矩阵LU分解的步骤推导"></a>矩阵LU分解的步骤推导</h2><p>从高斯消元法的过程，每一步初等行变换的过程相当于一个<strong>高斯变换</strong>，即左乘一个矩阵：</p><script type="math/tex; mode=display">L_1 = \begin{bmatrix}    1 & & & \\    l_1 & 1 & &\\    l_2 &  & 1 & & \\    \vdots &  &  & \ddots & \\    l_n & & & & 1\end{bmatrix}</script><p>其中，$l_i = -\frac{a_{i1}^{(1)}}{a_{11}^{(1)}},i = 2,3,\cdots,n$。</p><p>易得，高斯消元法的过程可以表示为：</p><script type="math/tex; mode=display">L_{n-1}L_{n-2}\cdots L_{1}A = U</script><p>其中，$\boldsymbol{L}_i$为下三角矩阵，$\boldsymbol{U}$为上三角矩阵。</p><p>令 $\boldsymbol{L} = L_1^{-1}\cdots L_{n-2}^{-1}L_{n-1}^{-1}$，则有：</p><script type="math/tex; mode=display"> \boldsymbol{A} =  \boldsymbol{L} \boldsymbol{U}</script><p>这就是矩阵的<strong>LU分解</strong>。</p><p>求得 $\boldsymbol{L}$ 和 $\boldsymbol{U}$ 后，如何计算 $x$？</p><script type="math/tex; mode=display">Ax = LUx = b</script><p>取中间变量 $y = Ux$，则 $Ly = b$。</p><p>那么，为什么LU分解能加速线性方程组的求解呢？</p><p>实际上，虽然从矩阵形式上看，$\boldsymbol{L}$ 需要计算 $n-1$ 个 $L_i$ 的逆，但是实际算法求解过程中，三角型的矩阵的乘法和逆是容易计算的，并且甚至不需要额外的空间存储开销 \cite{Matrix_Computations}：算法会将 $\boldsymbol{L}$ 和 $\boldsymbol{U}$ 的元素直接存储到原矩阵 $\boldsymbol{A}$ 的相应位置上：</p><ul><li>$\boldsymbol{L}$ 的下三角部分（不包括对角线）会存储在 $\boldsymbol{A}$ 的下三角部分。</li><li>$\boldsymbol{U}$ 的上三角部分和对角线会存储在 $\boldsymbol{A}$ 的上三角部分和对角线上。</li></ul><p>例如，对于矩阵</p><script type="math/tex; mode=display">\boldsymbol{A} =\begin{bmatrix}    a_{11} & a_{12} & a_{13} \\    a_{21} & a_{22} & a_{23} \\    a_{31} & a_{32} & a_{33}\end{bmatrix}</script><p>经过 LU 分解后，它的存储会变为：</p><script type="math/tex; mode=display">\boldsymbol{A} =\begin{bmatrix}    u_{11} & u_{12} & u_{13} \\    l_{21} & u_{22} & u_{23} \\    l_{31} & l_{32} & u_{33}\end{bmatrix}</script><p>其中：</p><ul><li>$l_{ij}$ 为第 $i$ 行，第 $j$ 列的乘子；</li><li>$u_{ij}$ 为第 $i$ 行，第 $j$ 列的上三角元素；</li></ul><p>通过这种方式，所有分解信息都存储在原矩阵中，无需额外空间。LU分解既降低了时间复杂度又降低了空间复杂度。</p><p>不过，从我们进行高斯消元法的过程就可以发现，要保证高斯消元法能进行到底，需要避免乘子中的除数（$A_{kk}$）出现 0（实际应用中，很小的情况也应该避免），所以一般不直接应用LU分解，而是应用<strong>列主元PLU分解</strong>，它通过交换行来避免出现相对很小的主元，实现稳定的LU分解 \cite{数值分析5}，其伪代码如算法 \ref{列选主元PLU分解法} 所示。</p><h3 id="算法：列选主元PLU分解法"><a href="#算法：列选主元PLU分解法" class="headerlink" title="算法：列选主元PLU分解法"></a>算法：列选主元PLU分解法</h3><p><strong>输入：</strong> 矩阵 $A \in \mathbb{R}^{n \times n}$<br><strong>输出：</strong> 矩阵 $P, L, U$，使得 $P A = L U$</p><pre><code class="lang-algorithm">初始化：U = A, L = I, P = Ifor k = 1 to n-1 do:    1. 寻找主元：       pivot = max_&#123;i=k, ..., n&#125; |U[i, k]|       记录主元行号 row    2. 若 row ≠ k:       构造置换矩阵 P_k，交换 U 的第 k 行与第 row 行：       P_k = 交换 k 行与 row 行的单位矩阵       更新 U: U = P_k U       更新 P: P = P_k P       若 k &gt; 1，则更新 L: L = P_k L    3. 对于 i = k+1 到 n:       计算消元因子：       L[i, k] = U[i, k] / U[k, k]       更新 U：       U[i, :] = U[i, :] - L[i, k] * U[k, :]返回 P, L, U</code></pre><script type="math/tex; mode=display">\boldsymbol{A} = \boldsymbol{L} \boldsymbol{U}</script><p>其中，若矩阵 $\boldsymbol{A}$ 满秩，即 $\operatorname{rank} A = r$，则可利用 LU 分解或 PLU 分解构造其满秩分解：</p><p>• <strong>LU 分解构造满秩分解</strong></p><p>若 $\boldsymbol{A}$ 可分解为 $\boldsymbol{A} = \boldsymbol{L} \boldsymbol{U}$，则从 $\boldsymbol{L}$ 提取前 $r$ 列，从 $\boldsymbol{U}$ 提取前 $r$ 行：</p><script type="math/tex; mode=display">\boldsymbol{F} = \boldsymbol{L}[:, 0:r],\quad \boldsymbol{G} = \boldsymbol{U}[0:r, :]</script><p>其中，$\boldsymbol{F}$ 为列满秩矩阵（$m \times r$），$\boldsymbol{G}$ 为行满秩矩阵（$r \times n$），从而得到矩阵的满秩分解。</p><p>• <strong>PLU 分解构造满秩分解</strong></p><p>设 $\boldsymbol{A}$ 通过列主元 LU 分解得：</p><script type="math/tex; mode=display">\boldsymbol{A} = \boldsymbol{P} \boldsymbol{L} \boldsymbol{U}</script><p>同样取：</p><script type="math/tex; mode=display">\boldsymbol{B} = \boldsymbol{L}[:, 0:r],\quad \boldsymbol{C} = \boldsymbol{U}[0:r, :]</script><p>代入分解式可得：</p><script type="math/tex; mode=display">\boldsymbol{A} = \boldsymbol{P} \boldsymbol{B} \boldsymbol{C}</script><p>其中，$\boldsymbol{P}$ 为置换矩阵，显然满秩。</p><p>进一步推广，若方阵 $\boldsymbol{A}$ 可分解为：</p><script type="math/tex; mode=display">\boldsymbol{A} = \boldsymbol{L} \boldsymbol{D} \boldsymbol{U}</script><p>其中，$\boldsymbol{D}$ 为对角矩阵，则称其为 <strong>LDU 分解</strong>。</p><p>由高斯消元法的推导，可得如下定理及推论：</p><p><strong>定理</strong>：矩阵 $\boldsymbol{A} = (a_{i j})_{n \times n}$ 存在唯一分解：</p><script type="math/tex; mode=display">\boldsymbol{A} = \boldsymbol{L} \boldsymbol{D} \boldsymbol{U}</script><p>其中：</p><p>• $\boldsymbol{L}$ 为单位下三角矩阵，</p><p>• $\boldsymbol{U}$ 为单位上三角矩阵，</p><p>• $\boldsymbol{D}$ 为对角矩阵，其对角元：$d_{k} = \frac{\Delta_{k}}{\Delta_{k-1}}, \quad k=1,2,\dots,n \quad (\Delta_0 = 1)$</p><p>其中 $\Delta_k$ 为 $\boldsymbol{A}$ 的顺序主子式。</p><p><strong>推论</strong>：若 $\boldsymbol{A}$ 为非奇异矩阵，则其可进行三角分解：</p><script type="math/tex; mode=display">\boldsymbol{A} = \boldsymbol{L} \boldsymbol{U}</script><p>当且仅当 $\boldsymbol{A}$ 的顺序主子式：$\Delta_k \neq 0, \quad k=1,2,\dots,n$</p><p><strong>进一步推广</strong>：对 <strong>Doolittle、Crout、Cholesky 分解</strong>，定义如下：</p><p>• <strong>Doolittle 分解</strong>：设 $\boldsymbol{A}$ 具有唯一 LDU 分解，令：</p><script type="math/tex; mode=display">\hat{\boldsymbol{U}} = \boldsymbol{D} \boldsymbol{U}</script><p>则有：</p><script type="math/tex; mode=display">\boldsymbol{A} = \boldsymbol{L} \hat{\boldsymbol{U}}</script><p>• <strong>Crout 分解</strong>：令：</p><script type="math/tex; mode=display">\hat{\boldsymbol{L}} = \boldsymbol{L} \boldsymbol{D}</script><p>则有：</p><script type="math/tex; mode=display">\boldsymbol{A} = \hat{\boldsymbol{L}} \boldsymbol{U}</script><p>• <strong>Cholesky 分解</strong>（平方根分解）：设 $\boldsymbol{A}$ 为实对称正定矩阵，则其可分解为：</p><script type="math/tex; mode=display">\boldsymbol{A} = \boldsymbol{L} \widetilde{\boldsymbol{D}}^2 \boldsymbol{U}</script><p>其中：</p><script type="math/tex; mode=display">\widetilde{\boldsymbol{D}} = \operatorname{diag}(\sqrt{d_1},\sqrt{d_2},\dots,\sqrt{d_n})</script><p>进一步，可得：</p><script type="math/tex; mode=display">\boldsymbol{A} = \boldsymbol{L} \widetilde{\boldsymbol{D}}^2 \boldsymbol{L}^\top</script><p>令：</p><script type="math/tex; mode=display">\boldsymbol{G} = \boldsymbol{L} \widetilde{\boldsymbol{D}}</script><p>则有：</p><script type="math/tex; mode=display">\boldsymbol{A} = \boldsymbol{G} \boldsymbol{G}^\top</script><p>这被称为 <strong>Cholesky 分解</strong>（对称三角分解）。</p>]]></content>
      
      
      <categories>
          
          <category> 矩阵论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 矩阵论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵论：矩阵函数和矩阵求导</title>
      <link href="/blog/2025/01/15/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E7%9F%A9%E9%98%B5%E5%87%BD%E6%95%B0%E5%92%8C%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC/"/>
      <url>/blog/2025/01/15/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E7%9F%A9%E9%98%B5%E5%87%BD%E6%95%B0%E5%92%8C%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="矩阵函数介绍"><a href="#矩阵函数介绍" class="headerlink" title="矩阵函数介绍"></a>矩阵函数介绍</h2><p>矩阵函数与通常的函数类似，但是因变量和自变量都为 $n$ 阶矩阵。定义如下：</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>设一元函数 $f(z)$ 能展开为 $z$ 的幂级数：</p><script type="math/tex; mode=display">f(z) = \sum_{k = 0}^{\infty} c_k z^k, \quad (|z| < r)</script><p>其中 $r &gt; 0$ 表示该幂级数的收敛半径。当 $n$ 阶矩阵 $A$ 的谱半径 $\rho (A) &lt; r$ 时，把收敛矩阵幂级数 $\sum_{k = 0}^{\infty} c_k A^k$ 的和称为 <strong>矩阵函数</strong>，记为 $f(A)$，即：</p><script type="math/tex; mode=display">f(A) = \sum_{k = 0}^{\infty} c_k A^k</script><p>通过以上定义和一些基本函数，可以导出 <strong>矩阵指数函数</strong> 和 <strong>矩阵三角函数</strong>，并推得一系列等式。</p><hr><h2 id="函数矩阵对矩阵的导数"><a href="#函数矩阵对矩阵的导数" class="headerlink" title="函数矩阵对矩阵的导数"></a>函数矩阵对矩阵的导数</h2><p>我们已经在上一节中引入了矩阵函数的概念，类似地，也有微分和导数的定义。相较于标量导数，对矩阵函数的求导和微分较为复杂。在具体应用中，如梯度下降等算法，这部分内容具有重要意义，因此需要深入理解。</p><p>首先，我们将标量求导拓展到向量，对于 $\frac{\partial y}{\partial x}$，存在以下几种情况：</p><ol><li>$y$ 是标量：<ul><li>$x$ 是标量</li><li>$\boldsymbol{x}$ 是向量（默认为列向量，即 $\boldsymbol{x} = (x_1, x_2, x_3)^\top$）</li><li>$\boldsymbol{X}$ 是矩阵</li></ul></li><li>$\boldsymbol{y}$ 是向量，例如 $f_{3\times 1}(x) = (f_1, f_2, f_3)^\top$：<ul><li>标量变元</li><li>向量变元</li><li>矩阵变元</li></ul></li><li>$\boldsymbol{Y}$ 是矩阵，同样有三种变元。</li></ol><p>简单理解：</p><ul><li><strong>分子布局</strong>：分子是列向量形式，分母是行向量形式</li><li><strong>分母布局</strong>：分子是行向量形式，分母是列向量形式</li></ul><h3 id="向量化操作"><a href="#向量化操作" class="headerlink" title="向量化操作"></a>向量化操作</h3><p>在具体分析之前，先介绍矩阵的 <strong>向量化操作</strong>。例如，对矩阵 $\boldsymbol{X} \in \mathbb{R}^{m \times n}$ 进行列优先展开：</p><script type="math/tex; mode=display">\text{vec}(\boldsymbol{X}) =\begin{bmatrix}x_{11} & x_{21} & \dots & x_{m1} & \dots & x_{1n} & x_{2n} & \dots & x_{mn}\end{bmatrix}^\top</script><h3 id="向量变元的实值标量函数"><a href="#向量变元的实值标量函数" class="headerlink" title="向量变元的实值标量函数"></a>向量变元的实值标量函数</h3><ol><li><strong>行向量偏导（分子布局）</strong><script type="math/tex; mode=display">\boldsymbol{D}_{\boldsymbol{x}} f = \frac{\partial f}{\partial \boldsymbol{x}^\top} =\begin{bmatrix}\frac{\partial f}{\partial x_1} & \frac{\partial f}{\partial x_2} & \dots & \frac{\partial f}{\partial x_n}\end{bmatrix}</script></li><li><strong>梯度向量偏导（分母布局）</strong><script type="math/tex; mode=display">\nabla_{\boldsymbol{x}} f = \frac{\partial f}{\partial \boldsymbol{x}} =\begin{bmatrix}\frac{\partial f}{\partial x_1} \\\frac{\partial f}{\partial x_2} \\\vdots \\\frac{\partial f}{\partial x_n}\end{bmatrix}</script></li></ol><h3 id="矩阵变元的实值标量函数"><a href="#矩阵变元的实值标量函数" class="headerlink" title="矩阵变元的实值标量函数"></a>矩阵变元的实值标量函数</h3><p>从标量求导到矩阵求导，就是分子的 <strong>转置、向量化</strong> 和分母的 <strong>转置、向量化</strong> 的各种组合。</p><p>对于 <strong>分子布局</strong>：</p><ul><li>分子：标量、列向量、矩阵向量化后的列向量</li><li>分母：标量、列向量转置后的行向量、矩阵的转置矩阵、矩阵向量化后的列向量转置后的行向量</li></ul><p>对于 <strong>分母布局</strong>：</p><ul><li>分子：标量、列向量转置后的行向量、矩阵向量化后的列向量转置后的行向量</li><li>分母：标量、列向量、矩阵自身、矩阵向量化后的列向量</li></ul><p>在机器学习领域，常见的主要有以下三种形式：</p><ol><li><strong>梯度</strong>：<script type="math/tex; mode=display">\nabla_{\boldsymbol{x}} \overset{\mathrm{def}}{=} \left[\frac{\partial}{\partial x_{1}},\frac{\partial}{\partial x_{2}},\cdots,\frac{\partial}{\partial x_{n}}\right]^{T}=\frac{\partial}{\partial\boldsymbol{x}}</script></li><li><strong>Hesse矩阵</strong>：<script type="math/tex; mode=display">H(f) =\begin{bmatrix}\frac{\partial^2f}{\partial x_1^2} & \frac{\partial^2f}{\partial x_1\partial x_2} & \cdots & \frac{\partial^2f}{\partial x_1\partial x_n} \\\frac{\partial^2f}{\partial x_2\partial x_1} & \frac{\partial^2f}{\partial x_2^2} & \cdots & \frac{\partial^2f}{\partial x_2\partial x_n} \\\vdots & \vdots & \ddots & \vdots \\\frac{\partial^2f}{\partial x_n\partial x_1} & \frac{\partial^2f}{\partial x_n\partial x_2} & \cdots & \frac{\partial^2f}{\partial x_n^2}\end{bmatrix}</script></li><li><strong>Jacobi矩阵</strong>：<script type="math/tex; mode=display">\begin{bmatrix}\frac{\partial y_1}{\partial x_1} & \cdots & \frac{\partial y_1}{\partial x_n} \\\vdots & \ddots & \vdots \\\frac{\partial y_m}{\partial x_1} & \cdots & \frac{\partial y_m}{\partial x_n}\end{bmatrix}</script></li></ol><p>不难发现：</p><ul><li>若 $f(x)$ 是一个标量函数，则 <strong>Jacobi矩阵是一个向量</strong>，等于 $f(x)$ 的梯度，Hesse矩阵是一个二维矩阵</li><li>若 $f(x)$ 是一个向量值函数，则 <strong>Jacobi矩阵是一个二维矩阵</strong>，Hesse矩阵是一个三维矩阵</li><li><strong>梯度是 Jacobi 矩阵的特例</strong>，梯度的 Jacobi 矩阵就是 Hesse 矩阵，这其实就是 <strong>一阶偏导与二阶偏导的关系</strong></li></ul><hr><h2 id="自动求导与链式法则"><a href="#自动求导与链式法则" class="headerlink" title="自动求导与链式法则"></a>自动求导与链式法则</h2><p>在实际应用问题中，标量求导中的 <strong>链式法则</strong> 也可以拓展到向量乃至矩阵。在使用程序计算时，库函数一般采用 <strong>自动求导</strong> 方式，而不是一般的符号求导或数值求导。自动求导应用了链式法则，并将整个计算过程表示成一个 <strong>无环图</strong>，其中包括两种模式：</p><ol><li><strong>正向积累</strong>：<script type="math/tex; mode=display">\frac{\partial \boldsymbol{z}^{(i)}}{\partial \boldsymbol{x}} =\frac{\partial \boldsymbol{z}^{(i-1)}}{\partial \boldsymbol{x}} \cdot\frac{\partial \boldsymbol{z}^{(i)}}{\partial \boldsymbol{z}^{(i-1)}}</script></li><li><strong>反向传递</strong>：<script type="math/tex; mode=display">\frac{\partial f}{\partial \boldsymbol{z}^{(i-1)}} =\frac{\partial f}{\partial \boldsymbol{z}^{(i)}} \cdot\frac{\partial \boldsymbol{z}^{(i)}}{\partial \boldsymbol{z}^{(i-1)}}</script></li></ol><p>反向传递过程需要存储中间变量，导致内存复杂度比正向积累高。</p><p>其在实际场景中的主要应用就是神经网络，在神经网络的正向传播中，我们将输入数据通过网络层逐层传递，计算出最终的输出值。我们的目标是计算神经网络的输出$\hat{y}$和损失函数$\mathcal{L}$的值。而反向传播用于计算损失函数对所有网络参数的梯度。</p><p>在实际应用问题中，由于反向传播的链路过长，涉及到多次激活函数关于净输入的偏导数矩阵、当前层输入关于净输入的偏导数矩阵的连乘，如果这个矩阵的谱半径小于一，那么随着反向传播的进行，回传的梯度信号衰减地越厉害，这使得越是网络浅层的参数地梯度越微弱，那么其越难得到很好地更新。这就是<strong>梯度消失</strong>问题。</p>]]></content>
      
      
      <categories>
          
          <category> 矩阵论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 矩阵论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵论：矩阵级数</title>
      <link href="/blog/2025/01/14/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E7%9F%A9%E9%98%B5%E7%BA%A7%E6%95%B0/"/>
      <url>/blog/2025/01/14/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E7%9F%A9%E9%98%B5%E7%BA%A7%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="矩阵级数介绍"><a href="#矩阵级数介绍" class="headerlink" title="矩阵级数介绍"></a>矩阵级数介绍</h3><p>在数学分析中，级数（特别是幂级数）的理论占有重要地位。在建立矩阵分析的理论时，矩阵级数，特别是幂级数，是建立矩阵函数的理论基础。</p><p>类似数列级数，我们给出其收敛、发散以及和的定义。</p><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义 1"></a>定义 1</h4><p>把矩阵序列所形成的无穷和 $A^{(0)} + A^{(1)} + A^{(2)} + \cdots + A^{(k)} + \cdots$ 称为 <strong>矩阵级数</strong>，记为 $\sum_{k = 0}^{\infty} A^{(k)}$。则有：</p><script type="math/tex; mode=display">\sum_{k=0}^\infty A^{(k)} = A^{(0)} + A^{(1)} + A^{(2)} + \cdots + A^{(k)} + \cdots</script><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义 2"></a>定义 2</h4><p>记 $S^{(N)} = \sum_{k=0}^N A^{(k)}$，称其为矩阵级数的部分和。如果矩阵序列 $\{S^{(N)}\}$ <strong>收敛</strong>，且有极限 $S$，则有：</p><script type="math/tex; mode=display">\lim_{N \to \infty} S^{(N)} = S</script><p>那么就称矩阵级数收敛，并且有 $S$，记为：</p><script type="math/tex; mode=display">S = \sum_{k=0}^\infty A^{(k)}</script><p>不收敛的矩阵称为 <strong>发散</strong> 的。</p><p>若用 $s_{ij}$ 表示 $S$ 的第 $i$ 行第 $j$ 列元素，那么，和 $\sum_{k=0}^N A^{(k)} = S^{(N)}$ 的意义是：</p><script type="math/tex; mode=display">\sum_{k = 0}^{\infty}a_{ij}^{(k)} = s_{ij}, \quad (i=1,2,\dots,m; \quad j=1,2,\dots,n)</script><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义 3"></a>定义 3</h4><p>如果上述级数中 $mn$ 个数项级数都是绝对收敛的，则称矩阵级数是 <strong>绝对收敛</strong> 的。</p><p>我们不再赘述有关矩阵级数绝对收敛的一些判别和性质，而是将重点放在矩阵的幂级数上。</p><p>首先，我们看一个比较简单的方阵幂级数。</p><h4 id="定理-1"><a href="#定理-1" class="headerlink" title="定理 1"></a>定理 1</h4><p>方阵 $A$ 的 <strong>幂级数（Neumann 级数）</strong></p><script type="math/tex; mode=display">\sum_{k = 0}^{\infty} A^k = I + A + A^2 + \dots + A^k + \dots</script><p>收敛的充要条件是 $A$ 为收敛矩阵，并且在其收敛时，其和为 $(I - A)^{-1}$。</p><p>如果用级数和来估算部分和矩阵，会存在一定误差：</p><h4 id="定理-2"><a href="#定理-2" class="headerlink" title="定理 2"></a>定理 2</h4><p>设方阵 $A$ 对某一矩阵范数 $\Vert \cdot \Vert$ 有 $\Vert A\Vert &lt; 1$，则对任何非负整数 $N$，以 $(I-A)^{-1}$ 为部分和 $I + A + A^2 + \dots + A^N$ 的近似矩阵时，其误差为：</p><script type="math/tex; mode=display">\Vert (I-A)^{-1} - (I + A + A^2 + \dots + A^N)\Vert \le \frac{\Vert A\Vert ^{N+1}}{1 - \Vert A\Vert}</script><p>现在，我们继续将矩阵幂级数 $\sum_{k = 0}^{\infty} c_kA^k$ 与对应的纯量幂级数 $\sum_{k = 0}^{\infty} c_kz^k$ 建立联系。</p><h4 id="定理-3"><a href="#定理-3" class="headerlink" title="定理 3"></a>定理 3</h4><p>设幂级数</p><script type="math/tex; mode=display">f(z) = \sum_{k = 0}^{\infty}c_kz^k</script><p>的收敛半径为 $r$，如果方阵 $A$ 满足 $\rho (A) &lt; r$，则矩阵幂级数</p><script type="math/tex; mode=display">\sum_{k = 0}^{\infty}c_kA^k</script><p>是绝对收敛的；如果 $\rho (A) &gt; r$，则矩阵幂级数是发散的。</p>]]></content>
      
      
      <categories>
          
          <category> 矩阵论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 矩阵论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵论：矩阵序列</title>
      <link href="/blog/2025/01/14/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E7%9F%A9%E9%98%B5%E5%BA%8F%E5%88%97/"/>
      <url>/blog/2025/01/14/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E7%9F%A9%E9%98%B5%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="矩阵序列介绍"><a href="#矩阵序列介绍" class="headerlink" title="矩阵序列介绍"></a>矩阵序列介绍</h2><p>在《线性代数》课程中主要学习了矩阵的代数运算，我们继续将《数学分析》中的理论推广至矩阵空间，对于矩阵的分析，类似数列，我们同样从极限理论开始，介绍矩阵序列的极限运算。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>设 $\{A^{(k)}\}_{k=1}^\infty$ 是一个矩阵序列，其中 $A^{(k)} \in \mathbb{C}^{m \times n}$。当 $a_{ij}^{(k)} \to a_{ij}(k \to \infty)$ 时，称 $\{A^{(k)}\}$ 收敛，或成矩阵 $A = (a_{ij})_{m \times n}$ 为 $\{A^{(k)}\}$ 的极限，或称 $\{A^{(k)}\}$ 收敛于 $A$，记为</p><script type="math/tex; mode=display">\lim_{k \to \infty} A^{(k)} = A, A^{(k)} \to A</script><p>不收敛的矩阵序列称为 <strong>发散</strong>。</p><p>同样，矩阵序列收敛有很多与数列收敛类似的性质，此处不再赘述，继续往下研究其收敛的等价条件。</p><h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><p><strong>定理 1</strong> 设 $A^{(k)} \in \mathbb{C}^{m \times n}$，则</p><ol><li>$A^{(k)} \to O$ 的充要条件是 $\Vert A^{(k)}\Vert \to 0$；</li><li>$A^{(k)} \to A$ 的充要条件是 $\Vert A^{(k)} - A \Vert \to 0$；</li></ol><p>这里，$\Vert \cdot \Vert$ 是 $\mathbb{C}^{m \times n}$ 上任何一种矩阵范数。</p><p>至此，我们将矩阵收敛的判断与范数建立了联系。</p><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p><strong>定义 1</strong> 矩阵序列 $\{A^{(k)}\}$ 称为 <strong>有界</strong> 的，如果存在常数 $M &gt; 0$，使得对于一切 $k$ 都有</p><script type="math/tex; mode=display">\left | a_{ij}^{(k)}\right | < M(i = 1,2,\dots,m;j = 1,2,\dots,n)</script><p><strong>定义 2</strong> 设 $A$ 为方阵，且 $A^k \to O(k \to \infty)$，则称 $A$ 为 <strong>收敛矩阵</strong>。</p><h3 id="定理-1"><a href="#定理-1" class="headerlink" title="定理"></a>定理</h3><p><strong>定理 2</strong> $A$ 为收敛矩阵的充要条件是 $\rho(A) &lt; 1$。</p><p><strong>定理 3</strong> $A$ 为收敛矩阵的充分条件是只要有一种矩阵范数 $\left|\cdot\right|$，使得 $\Vert A \Vert &lt; 1$。</p>]]></content>
      
      
      <categories>
          
          <category> 矩阵论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 矩阵论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵论：矩阵可逆性条件、条件数和谱半径介绍</title>
      <link href="/blog/2025/01/13/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E7%9F%A9%E9%98%B5%E5%8F%AF%E9%80%86%E6%80%A7%E6%9D%A1%E4%BB%B6%E3%80%81%E6%9D%A1%E4%BB%B6%E6%95%B0%E5%92%8C%E8%B0%B1%E5%8D%8A%E5%BE%84%E4%BB%8B%E7%BB%8D/"/>
      <url>/blog/2025/01/13/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E7%9F%A9%E9%98%B5%E5%8F%AF%E9%80%86%E6%80%A7%E6%9D%A1%E4%BB%B6%E3%80%81%E6%9D%A1%E4%BB%B6%E6%95%B0%E5%92%8C%E8%B0%B1%E5%8D%8A%E5%BE%84%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="矩阵可逆性条件、条件数和谱半径介绍"><a href="#矩阵可逆性条件、条件数和谱半径介绍" class="headerlink" title="矩阵可逆性条件、条件数和谱半径介绍"></a>矩阵可逆性条件、条件数和谱半径介绍</h2><p>在明确了范数的定义后，我们对它的几点应用进行列举。</p><h3 id="定理-2-6"><a href="#定理-2-6" class="headerlink" title="定理 2.6"></a>定理 2.6</h3><p>设 $A\in \mathbb{C}^{n \times n}$，且对 $\mathbb{C}^{n\times n}$ 上的某种矩阵范数 $\Vert  \cdot  \Vert $，若 $\Vert  A \Vert  &lt; 1$，则矩阵 $I-A$ 可逆（非奇异），且有：</p><script type="math/tex; mode=display">\Vert (I - A)^{-1} \Vert  \leq \frac{\Vert  I \Vert }{1 - \Vert  A \Vert }</script><h3 id="定理-2-7"><a href="#定理-2-7" class="headerlink" title="定理 2.7"></a>定理 2.7</h3><p>设 $A\in \mathbb{C}^{n \times n}$，且对 $\mathbb{C}^{n\times n}$ 上的某种矩阵范数 $\Vert  \cdot  \Vert $，若 $\Vert  A \Vert  &lt; 1$，则有：</p><script type="math/tex; mode=display">\Vert I - (I - A)^{-1} \Vert  \leq \frac{\Vert  A \Vert }{1 - \Vert  A \Vert }</script><h3 id="逆矩阵的摄动"><a href="#逆矩阵的摄动" class="headerlink" title="逆矩阵的摄动"></a>逆矩阵的摄动</h3><p>在实际应用问题中，矩阵参数往往为非准确值，即带有误差 $\delta$，我们希望其构成的近似矩阵 $A$ 的逆矩阵 $A^{-1}$ 与准确矩阵 $A + \delta a_{ij}(i,j = 1,2,\dots,n)$ 的逆矩阵 $(A + \delta a_{ij})^{-1}$ 尽量接近。</p><p>一般称 $\delta a_{ij}$ 为 <strong>扰动</strong>，$\delta A$ 为 $A$ 的 <strong>摄动矩阵</strong>。</p><h3 id="摄动定理"><a href="#摄动定理" class="headerlink" title="摄动定理"></a>摄动定理</h3><p><strong>定理 2.8</strong></p><p>设 $A\in \mathbb{C}^{n \times n}$ 且 $A$ 可逆，$B\in \mathbb{C}^{n\times n}$，且对 $\mathbb{C}^{n\times n}$ 上的某种矩阵范数 $\Vert  \cdot  \Vert $，若 $\Vert  A^{-1}B \Vert  &lt; 1$，则有：</p><ul><li>$A + B$ 可逆；</li><li>记 $F = I - (I + A^{-1}B)^{-1}$，则 $\Vert F \Vert \leq \frac{\Vert A^{-1}B \Vert }{1 - \Vert A^{-1}B \Vert }$；</li><li>$\frac{\Vert A^{-1} - (A + B)^{-1} \Vert }{A^{-1}} \leq \frac{\Vert  A^{-1}B \Vert }{1 - \Vert  A^{-1}B \Vert }$。</li></ul><p>若令 $\delta$ 是个小量，并且令</p><script type="math/tex; mode=display">cond(A) = \Vert A \Vert \Vert A^{-1}\Vert</script><p>则当 $\Vert A^{-1}\Vert \Vert \delta A \Vert &lt; 1$ 时，</p><script type="math/tex; mode=display">\frac{\Vert A^{-1} - (A + \delta A)^{-1}\Vert}{\Vert A^{-1}\Vert}\leq \frac{cond(A)\frac{\Vert \delta A\Vert}{\Vert A\Vert}}{1 - cond(A)\frac{\Vert\delta A\Vert}{\Vert A\Vert}}</script><p>称 $cond(A)$ 为矩阵 $A$ 的 <strong>条件数</strong>，一般情况下，条件数越大，$(A + \delta A)^{-1}$ 和 $A^{-1}$ 的相对误差就越大。往往在用算法进行矩阵求逆时，先计算条件数，判断矩阵的逆是否“好求”。</p><h3 id="矩阵谱半径"><a href="#矩阵谱半径" class="headerlink" title="矩阵谱半径"></a>矩阵谱半径</h3><p><strong>定义</strong></p><p>设 $A\in \mathbb{C}^{n \times n}$ 的 $n$ 个特征值为 $\lambda_1,\lambda_2,\dots,\lambda_n$，称</p><script type="math/tex; mode=display">\rho (A) = \max\limits_{i}\left|\lambda_i\right|</script><p>为 $A$ 的 <strong>谱半径</strong>。</p><p><strong>定理 2.9</strong></p><p>设 $A\in \mathbb{C}^{n \times n}$，则对 $\mathbb{C}^{n\times n}$ 上任何一种矩阵范数 $\Vert  \cdot  \Vert $，都有</p><script type="math/tex; mode=display">\rho (A) \leq \Vert  A \Vert</script><p><strong>定理 2.10</strong></p><p>设 $A\in \mathbb{C}^{n \times n}$，对 $\forall \epsilon &gt; 0,\exists \Vert  \cdot  \Vert ,s.t.$</p><script type="math/tex; mode=display">\Vert  A  \Vert _M \leq \rho (A) + \epsilon</script><p>由上述定理可见，谱半径小于等于任意矩阵范数，同时也必存在一个算子范数，小于等于谱半径加上一个很小的正数。</p><h3 id="谱半径在迭代法中的应用"><a href="#谱半径在迭代法中的应用" class="headerlink" title="谱半径在迭代法中的应用"></a>谱半径在迭代法中的应用</h3><p>谱半径在数值分析和迭代法中起到了关键作用，尤其是在矩阵幂法、迭代求解线性方程组的收敛性分析等领域。例如，当利用迭代法解线性方程组时，谱半径决定了迭代矩阵是否收敛。</p><p><strong>定理 2.11</strong></p><p>在数值线性代数中，迭代法通常用于求解线性方程组 $Ax = b$。设迭代法的一般形式为：</p><script type="math/tex; mode=display"> x^{(k+1)} = B x^{(k)} + c,</script><p>其中，$B$ 为迭代矩阵，$c$ 为常向量，$k$ 为迭代次数。</p><p>迭代法的收敛性由迭代矩阵 $B$ 的谱半径决定：</p><ol><li><strong>必要条件</strong>：如果迭代法收敛，即 $x^{(k)} \to x^<em>$ ($x^</em>$ 为精确解)，则迭代矩阵 $B$ 的谱半径必须满足：$\rho(B) &lt; 1$；</li><li><strong>充分条件</strong>：如果 $\rho(B) &lt; 1$，则对于任意初始值 $x^{(0)}$，迭代法都会收敛到线性方程组的唯一解 $x^*$。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 矩阵论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 矩阵论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵论：向量范数与矩阵范数</title>
      <link href="/blog/2025/01/13/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E5%90%91%E9%87%8F%E8%8C%83%E6%95%B0%E4%B8%8E%E7%9F%A9%E9%98%B5%E8%8C%83%E6%95%B0/"/>
      <url>/blog/2025/01/13/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E5%90%91%E9%87%8F%E8%8C%83%E6%95%B0%E4%B8%8E%E7%9F%A9%E9%98%B5%E8%8C%83%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="向量范数与矩阵范数"><a href="#向量范数与矩阵范数" class="headerlink" title="向量范数与矩阵范数"></a>向量范数与矩阵范数</h2><h3 id="向量范数介绍"><a href="#向量范数介绍" class="headerlink" title="向量范数介绍"></a>向量范数介绍</h3><p>我们知道，对于数列极限，我们有</p><script type="math/tex; mode=display">\lim_{n \to \infty} a_n = M \iff \forall \epsilon > 0,\exists N > 0,s.t. \forall n>N,\left |  {a_n - M}  \right | < \epsilon.</script><p>在 $n$ 维向量空间 $R^n$ 内，我们希望对于一个向量序列 $\{x^{(k)}\}$，其中 $x^{(k)}= (\xi_1^{(k)},\xi_2^{(k)},\dots, \xi_n^{(k)})(k = 1,2,3,\dots)$。如果对于每一个分量 $\xi_i^{(k)}$，都有 $\lim_{k \to \infty} \xi_i^{(k)} = \xi_i$，即</p><script type="math/tex; mode=display">\lim_{k \to \infty} x^{(k)} = (\xi_1, \xi_2, \dots, \xi_n) = x</script><p>则称向量序列 $\{x^{(k)}\}$ 收敛于 $x$。</p><p>但是，我们还是无法解决 $\left| x^{(k)} - x\right|$ 该如何定义和计算，显然它不能用向量 $x^{(k)} - x$ 的长度来刻画。为此，我们定义向量范数如下。</p><h4 id="定义-2-1"><a href="#定义-2-1" class="headerlink" title="定义 2.1"></a>定义 2.1</h4><p>如果 $V$ 是数域 $K$ 上的线性空间，且对于 $\forall x \in V$，定义一个实值函数 $\Vert  x \Vert $，它满足以下三个条件:</p><ol><li><strong>非负性</strong>: 当 $x \ne 0$ 时，$\Vert  x \Vert  &gt; 0$，当且仅当 $x = 0$ 时为 $0$;</li><li><strong>齐次性</strong>: $\forall a \in K, \forall x \in V, \Vert  ax \Vert  = \left| a \right| \Vert  x \Vert$;</li><li><strong>三角不等式</strong>: $\forall x, y \in V, \Vert  x + y \Vert  \leq \Vert  x \Vert  + \Vert  y \Vert$;</li></ol><p>则称 $\Vert  x \Vert$ 为向量 $x$ 的范数。</p><p>我们要判断某个实值函数 $\Vert  x \Vert$ 是否是范数，即验证其是否满足上述三条性质即可。以下列举几种常见的范数(在线性空间 $\mathbb{C}^n$，即酉空间中)：</p><ul><li><strong>1-范数</strong>: $\Vert  x \Vert  = \sum \left| \xi_i \right|$</li><li><strong>2-范数</strong>: $\Vert  x \Vert  = \sqrt{(x,x)}$</li><li><strong>$\infty$-范数</strong>: $\Vert  x \Vert  = \max \left| x_i\right|$</li><li><strong>p-范数</strong>: $\Vert  x \Vert _p = (\sum_{i = 1}^{n} {\left|x_i\right|}^p)^{\frac{1}{p}}, (1 \leq p &lt; \infty)$</li></ul><h4 id="定理-2-1"><a href="#定理-2-1" class="headerlink" title="定理 2.1"></a>定理 2.1</h4><p>设有限维线性空间 $V^n$ 中任意两个向量范数 $\Vert  x_\alpha \Vert ,\Vert  x_\beta \Vert$，如果 $\exists c_1, c_2,s.t.$</p><script type="math/tex; mode=display">{c_1\Vert  x_\beta \Vert  \leq \Vert  x_\alpha \Vert  < c_2\Vert  x_\beta \Vert }</script><p>则称向量范数 $\Vert  x_\alpha \Vert ,\Vert  x_\beta \Vert$ 等价。</p><h3 id="矩阵范数介绍"><a href="#矩阵范数介绍" class="headerlink" title="矩阵范数介绍"></a>矩阵范数介绍</h3><p>对于矩阵空间 $\mathbb{C}^{m\times n}$，如果类似地将矩阵 $A_{m\times n}$ 看作“向量”，可以类似向量范数定义矩阵范数。但矩阵之间还有乘法运算，需要补充定义如下：</p><h4 id="定义-2-3"><a href="#定义-2-3" class="headerlink" title="定义 2.3"></a>定义 2.3</h4><p>设 $A \in \mathbb{C}^{m\times n}$，定义一个实值函数 $\Vert  A \Vert$，它满足以下四个条件:</p><ol><li><strong>非负性</strong>: 当 $A \ne 0$ 时，$\Vert  A \Vert  &gt; 0$，当且仅当 $A = 0$ 时为 $0$;</li><li><strong>齐次性</strong>: $\forall \alpha \in C, \Vert  {\alpha A} \Vert  = \left| {\alpha} \right| \Vert  A \Vert$;</li><li><strong>三角不等式</strong>: $\Vert  A + B \Vert  \leq \Vert  A \Vert  + \Vert  B \Vert$;</li><li><strong>相容性</strong>: $\Vert  AB \Vert  \leq \Vert  A \Vert  \Vert  B \Vert$ (对于 $B \in \mathbb{C}^{n\times l}$)。</li></ol><p>则称 $\Vert  A \Vert$ 为矩阵 $A$ 的范数。</p><p>在数值方法中进行某种估计时，多数情况下，矩阵范数与向量范数常混合使用，而矩阵经常是作为两个线性空间上的线性变换出现的，为此引入矩阵范数和向量范数相容的概念如下：</p><h4 id="定理2-2"><a href="#定理2-2" class="headerlink" title="定理2.2"></a>定理2.2</h4><p>对于$\mathbb{C}^{m \times n}$的矩阵范数$\Vert {\cdot} \Vert _M$和$\mathbb{C}^m,\mathbb{C}^n$上的同类向量范数$\Vert {\cdot} \Vert _V$，如果有</p><script type="math/tex; mode=display">\Vert Ax \Vert _V \leq \Vert A \Vert _M \Vert x \Vert _V(\forall A \in \mathbb{C}^{m \times n}, \forall x \in \mathbb{C}^n)</script><p>则称矩阵范数$\Vert {\cdot} \Vert _M$与向量范数$\Vert {\cdot} \Vert _V$是相容的。</p><p>以下列举几种常用的矩阵范数：</p><ul><li><strong>F-范数</strong>: $\Vert  A \Vert _F = (\sum_{i = 1}^{m}\sum_{j = 1}^{n}\left|a_{ij}\right|^2)^{\frac{1}{2}} = (tr(A^H A))^{\frac{1}{2}}$</li></ul><p>其中，F-范数有一定理如下：</p><h4 id="定理-2-3"><a href="#定理-2-3" class="headerlink" title="定理 2.3"></a>定理 2.3</h4><p>设 $A \in \mathbb{C}^{m \times n}$，且 $P \in \mathbb{C}^{m\times m}, Q\in \mathbb{C}^{n \times n}$ 都是酉矩阵，则有</p><script type="math/tex; mode=display">\Vert PA \Vert _F = \Vert A \Vert _F = \Vert AQ \Vert _F</script><p>即 $A$ 左乘或右乘酉矩阵后，其 $\Vert {\cdot} \Vert$ 不变。</p><p>矩阵函数可以通过如下方法进行定义，并且定义的矩阵函数与已知的向量范数相容。</p><h4 id="定理2-4"><a href="#定理2-4" class="headerlink" title="定理2.4"></a>定理2.4</h4><p>已知$\mathbb{C}^{m},\mathbb{C}^{n}$上的同类向量范数$\Vert {\cdot} \Vert$。设$A\in \mathbb{C}^{m\times n}$，则函数</p><script type="math/tex; mode=display">\Vert {A} \Vert = \max\limits_{\Vert x \Vert = 1}{\Vert {Ax} \Vert }</script><p>是$\mathbb{C}^{m\times n}$上的矩阵范数，且与已知的向量范数相容。</p><p>分别取向量$x$的范数为$\Vert x \Vert _1,\Vert x \Vert _2,\Vert x \Vert _{\infty}$时，就可以得到以下三种矩阵范数：</p><h4 id="定理-2-5"><a href="#定理-2-5" class="headerlink" title="定理 2.5"></a>定理 2.5</h4><p>设 $A = (a_{ij})_{m\times n} \in \mathbb{C}^{m\times n}$，可以得到以下三种矩阵范数的计算公式分别为:</p><ol><li><strong>列和范数</strong>: $\Vert A \Vert _1 = \max\limits_{j} \sum_{i = 1}^{m}\left|a_{ij}\right|$;</li><li><strong>谱范数</strong>: $\Vert A \Vert _2 = \sqrt{\max{\lambda(A^HA)}}$;</li><li><strong>行和范数</strong>: $\Vert A \Vert _{\infty} = \max\limits_{i} \sum_{j=1}^{n}\left|a_{ij}\right|$;</li></ol><p>在机器学习中，范数作为数学优化的重要工具，广泛应用于高维优化问题中，其具体表现和影响在模型的性能、计算复杂度、正则化等方面有重要体现。</p><p>在高维优化中，目标函数往往包含范数，用于度量模型参数或残差的大小；在机器学习模型训练中，损失函数通常衡量预测值与真实值之间的差距，而范数决定了误差的度量方式，例如L-1损失、L-2损失；正则化通过添加范数约束减少模型复杂度，缓解高维数据中的过拟合问题，例如L-1正则化，L-2正则化。</p><p>以上应用场景中，范数的引入通过度量大小、限制复杂性和提升泛化能力，影响了模型的性能和稳定性。选择合适的范数类型能有效在稀疏性、平滑性和数值稳定性之间实现权衡。</p>]]></content>
      
      
      <categories>
          
          <category> 矩阵论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 矩阵论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵论：欧式空间中线性变换的求法</title>
      <link href="/blog/2025/01/12/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E6%AC%A7%E5%BC%8F%E7%A9%BA%E9%97%B4%E4%B8%AD%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E7%9A%84%E6%B1%82%E6%B3%95/"/>
      <url>/blog/2025/01/12/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E6%AC%A7%E5%BC%8F%E7%A9%BA%E9%97%B4%E4%B8%AD%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E7%9A%84%E6%B1%82%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="欧式空间中线性变换的求法"><a href="#欧式空间中线性变换的求法" class="headerlink" title="欧式空间中线性变换的求法"></a>欧式空间中线性变换的求法</h2><p>有了前两节的铺垫，下面，我们正式介绍欧式空间中线性变换的求法。</p><p>我们将问题描述如下：</p><p><strong>问题描述：</strong></p><ul><li>在欧式空间中给定线性变换 $T: \mathbb{V}^n \to \mathbb{V}^n$，比如：$T( \boldsymbol{X}) =  \boldsymbol{X} \boldsymbol{B}(\forall  \boldsymbol{X} \in \mathbb{V})$，其中 $\boldsymbol{B}$ 给定。</li><li><strong>目标：</strong> 寻找一组新基，使得 $T$ 在这组基下的矩阵表示为对角矩阵 $\boldsymbol{\Lambda}$ 或 Jordan 标准型 $\boldsymbol{J}$。</li></ul><p>首先，我们以课本 [矩阵论] 中的例题 1.36 为例，说明对称变换的求法：</p><h3 id="例-1-36"><a href="#例-1-36" class="headerlink" title="例 1.36"></a>例 1.36</h3><p>在欧氏空间 $\mathbb{R}^{2 \times 2}$ 中，矩阵 $\boldsymbol{A}$ 与 $\boldsymbol{B}$ 的内积定义为 <script type="math/tex">( \boldsymbol{A},  \boldsymbol{B})=tr ( \boldsymbol{A}^\top  \boldsymbol{B})</script>，子空间</p><script type="math/tex; mode=display">V=\left\{ \boldsymbol{X} =\begin{bmatrix} x_{1} & x_{2}\\ x_{3} & x_{4} \end{bmatrix} \mid x_{3}-x_{4}=0\right\}</script><p>$V$ 中的线性变换为</p><script type="math/tex; mode=display">T( \boldsymbol{X})= \boldsymbol{X}  \boldsymbol{B}_{0}\quad (\forall  \boldsymbol{X} \in V), \boldsymbol{B}_{0}=\begin{bmatrix} 1 & 2 \\ 2 & 1 \end{bmatrix}</script><ol><li>求 $V$ 的一个标准正交基；</li><li>验证 $T$ 是 $V$ 中的对称变换；</li><li>求 $V$ 的一个标准正交基，使 $T$ 在该基下的矩阵为对角矩阵。</li></ol><h3 id="解："><a href="#解：" class="headerlink" title="解："></a>解：</h3><h4 id="1-先找到一组普通的基，再进行-Schmidt-正交化"><a href="#1-先找到一组普通的基，再进行-Schmidt-正交化" class="headerlink" title="(1) 先找到一组普通的基，再进行 Schmidt 正交化"></a>(1) 先找到一组普通的基，再进行 Schmidt 正交化</h4><script type="math/tex; mode=display">\boldsymbol{X}=\begin{bmatrix} x_{1} & x_{2} \\ x_{3} & x_{4} \end{bmatrix}=x_{1}\begin{bmatrix} 1 & 0 \\ 0 & 0 \end{bmatrix}+x_{2}\begin{bmatrix} 0 & 1 \\ 0 & 0 \end{bmatrix}+x_{3}\begin{bmatrix} 0 & 0 \\ 1 & 1 \end{bmatrix}</script><p>一组标准正交基为：</p><script type="math/tex; mode=display">\boldsymbol{X}_1 = \begin{bmatrix} 1 & 0\\ 0 & 0 \end{bmatrix} \quad \boldsymbol{X}_2 = \begin{bmatrix} 0 & 1\\ 0 & 0 \end{bmatrix} \quad \boldsymbol{X}_3 = \frac{1}{\sqrt{2}}\begin{bmatrix} 0 & 0\\ 1 & 1 \end{bmatrix}</script><h4 id="2-计算-T-在这组基下的矩阵表示"><a href="#2-计算-T-在这组基下的矩阵表示" class="headerlink" title="(2) 计算 $T$ 在这组基下的矩阵表示"></a>(2) 计算 $T$ 在这组基下的矩阵表示</h4><script type="math/tex; mode=display">T(\boldsymbol{X}_1 , \boldsymbol{X}_2, \boldsymbol{X}_3) = (\boldsymbol{X}_1 , \boldsymbol{X}_2, \boldsymbol{X}_3)\boldsymbol{A} \Rightarrow \boldsymbol{A} = \begin{bmatrix} 1 & 2 & 0\\ 2 & 1 & 0\\ 0 & 0 & 3 \end{bmatrix}</script><h4 id="3-计算新的正交基，使-T-在该基下为对角矩阵"><a href="#3-计算新的正交基，使-T-在该基下为对角矩阵" class="headerlink" title="(3) 计算新的正交基，使 $T$ 在该基下为对角矩阵"></a>(3) 计算新的正交基，使 $T$ 在该基下为对角矩阵</h4><script type="math/tex; mode=display">\boldsymbol{A} =  \boldsymbol{Q}  \boldsymbol{\Lambda}  \boldsymbol{Q}^\top</script><p>其中：</p><script type="math/tex; mode=display">\boldsymbol{\Lambda}= \begin{bmatrix} 3 & & \\ & 3 & \\ & & -1 \end{bmatrix} \quad \boldsymbol{Q}=\begin{bmatrix} 0 & \frac{1}{\sqrt{2}} & -\frac{1}{\sqrt{2}} \\ 0 & \frac{1}{\sqrt{2}} & -\frac{1}{\sqrt{2}} \\ 1 & 0 & 0 \end{bmatrix}</script><p>计算得到的新基：</p><script type="math/tex; mode=display">\boldsymbol{Y}_1 = \frac{1}{\sqrt{2}}\begin{bmatrix} 0 & 0\\ 1 & 1 \end{bmatrix} \quad \boldsymbol{Y}_2 = \frac{1}{\sqrt{2}}\begin{bmatrix} 1 & 1\\ 0 & 0 \end{bmatrix} \quad \boldsymbol{Y}_3 = \frac{1}{\sqrt{2}}\begin{bmatrix} -1 & 1\\ 0 & 0 \end{bmatrix}</script><h2 id="线性变换的一般求法"><a href="#线性变换的一般求法" class="headerlink" title="线性变换的一般求法"></a>线性变换的一般求法</h2><p>若 $V$ 是欧式空间，$T$ 是 $V$ 上的一个线性变换：</p><ol><li>任意找到 $V$ 的一个基，并通过 Schmidt 正交化法得到 $V$ 的一个标准正交基，记为 $e_1,e_2,\cdots,e_n$；</li><li><p>求 $T$ 在该标准正交基下的矩阵表示 $\boldsymbol{A}_0$：</p><script type="math/tex; mode=display">T(e_1,e_2,\cdots,e_n) = (e_1,e_2,\cdots,e_n)\boldsymbol{A}_0</script></li><li><p>将 $\boldsymbol{A}_0$ 化为 Jordan 标准型 $\boldsymbol{J}$：</p><script type="math/tex; mode=display">\boldsymbol{A}_0 = \boldsymbol{P}\boldsymbol{J} \boldsymbol{P}^{-1}</script></li><li><p>右乘 $\boldsymbol{P}$：</p><script type="math/tex; mode=display">T(e_1,e_2,\cdots,e_n)\boldsymbol{P} = (e_1,e_2,\cdots,e_n)\boldsymbol{P}\boldsymbol{J}</script></li><li><p>取新基 $(\boldsymbol{E}_1, \boldsymbol{E}_2, \cdots, \boldsymbol{E}_n) = (\boldsymbol{e}_1 , \boldsymbol{e}_2, \cdots, \boldsymbol{e}_n)\boldsymbol{P}$，则线性变换在新基下的矩阵表示为 $\boldsymbol{J}$。</p></li></ol><p>以上方法可用于简化计算，使得多项式函数 $z = (T^k)(x),x\in V$ 的求解更加简便。</p>]]></content>
      
      
      <categories>
          
          <category> 矩阵论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 矩阵论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵论：若尔当标准型</title>
      <link href="/blog/2025/01/12/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E8%8B%A5%E5%B0%94%E5%BD%93%E6%A0%87%E5%87%86%E5%9E%8B/"/>
      <url>/blog/2025/01/12/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E8%8B%A5%E5%B0%94%E5%BD%93%E6%A0%87%E5%87%86%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>线性变换既然有矩阵表示，我们希望其应用到向量上得到的象能方便得到，即我们希望线性变换对应的矩阵尽量简单，比如能变为对角矩阵。为此，我们首先引入线性变换的特征值和特征向量，它和普通方阵类似。</p><h4 id="特征值与特征向量"><a href="#特征值与特征向量" class="headerlink" title="特征值与特征向量"></a>特征值与特征向量</h4><p><strong>定义 1</strong> 设 $T: V \to V$ 是一个线性变换，如果存在 $\lambda_0 \in K$，使得存在非零向量 $x \in V$ 满足：</p><script type="math/tex; mode=display">T x = \lambda_0 x</script><p>那么我们称 $\lambda_0$ 是 $T$ 的<strong>特征值</strong>，$x$ 是 $T$ 属于 $\lambda_0$ 的<strong>特征向量</strong>。</p><p><strong>定义 2</strong> 设 $\boldsymbol{A} = (a_{ij})_{n\times n}$ 是数域 $K$ 上的 $n$ 阶矩阵，$\lambda$ 是参数，$\boldsymbol{A}$ 的特征矩阵 $\lambda I - A$ 的行列式：</p><script type="math/tex; mode=display">\det (\lambda I-A) = \begin{vmatrix}\lambda-a_{11} & -a_{12} & \cdots & -a_{1n} \\-a_{21} & \lambda-a_{22} & \cdots & -a_{2n} \\\vdots & \vdots & \ddots & \vdots \\-a_{n1} & -a_{n2} & \cdots & \lambda-a_{nn}\end{vmatrix}</script><p>称为矩阵 $\boldsymbol{A}$ 的<strong>特征多项式</strong>，记为 $\varphi(\lambda)$。它的根 $\lambda_0$ 称为 $\boldsymbol{A}$ 的<strong>特征值</strong>，而对应的非零解向量 $(\xi_1, \xi_2, \dots, \xi_n)^T$ 称为 $\boldsymbol{A}$ 的属于特征值 $\lambda_0$ 的<strong>特征向量</strong>。</p><h3 id="最小多项式"><a href="#最小多项式" class="headerlink" title="最小多项式"></a>最小多项式</h3><p><strong>定义 3</strong> 设 $\boldsymbol{A}$ 的首项系数为 $1$，次数最小，且以 $\boldsymbol{A}$ 为根的 $\lambda$ 的多项式，称为 $\boldsymbol{A}$ 的<strong>最小多项式</strong>，记为 $m(\lambda)$。</p><h3 id="最小多项式与特征多项式的关系"><a href="#最小多项式与特征多项式的关系" class="headerlink" title="最小多项式与特征多项式的关系"></a>最小多项式与特征多项式的关系</h3><p><strong>定理 1</strong> 设矩阵 $\boldsymbol{A}$ 的最小多项式 $m(\lambda)$ 可整除以 $\boldsymbol{A}$ 为根的任一首 $1$ 多项式 $\psi(\lambda)$，且 $m(\lambda)$ 是唯一的。</p><p><strong>定理 2</strong> 矩阵 $\boldsymbol{A}$ 的最小多项式 $m(\lambda)$ 与其特征多项式 $\varphi(\lambda)$ 的零点相同（不计重数）。</p><p><strong>定理 3</strong> 设 $n$ 阶矩阵 $\boldsymbol{A}$ 的特征多项式为 $\varphi(\lambda)$，特征矩阵 $\lambda I - A$ 的全体 $n-1$ 阶子式的最大公因式为 $d(\lambda)$，则 $\boldsymbol{A}$ 的最小多项式为：</p><script type="math/tex; mode=display">m(\lambda) = \frac{\varphi(\lambda)}{d(\lambda)}</script><h3 id="Jordan-标准型"><a href="#Jordan-标准型" class="headerlink" title="Jordan 标准型"></a>Jordan 标准型</h3><p><strong>定义 4</strong> 设矩阵 $\boldsymbol{J}$ 由以下 Jordan 块构成：</p><script type="math/tex; mode=display">\boldsymbol{J} = \begin{bmatrix}\boldsymbol{J}_1(\lambda_1) & & & \\& \boldsymbol{J}_2(\lambda_2) & & \\& & \ddots & \\& & & \boldsymbol{J}_s(\lambda_s)\end{bmatrix}</script><p>其中，Jordan 块的形式如下：</p><script type="math/tex; mode=display">\boldsymbol{J}_i(\lambda_i) =\begin{bmatrix}\lambda_i & 1 & 0 & \cdots & 0 \\0 & \lambda_i & 1 & \cdots & 0 \\0 & 0 & \lambda_i & \cdots & 0 \\\vdots & \vdots & \vdots & \ddots & 1 \\0 & 0 & 0 & \cdots & \lambda_i\end{bmatrix}</script><p>称 $\boldsymbol{J}$ 为矩阵 $\boldsymbol{A}$ 的<strong>Jordan 标准型</strong>。</p><h3 id="计算-Jordan-标准型的步骤"><a href="#计算-Jordan-标准型的步骤" class="headerlink" title="计算 Jordan 标准型的步骤"></a>计算 Jordan 标准型的步骤</h3><ol><li><p><strong>求矩阵 $\boldsymbol{A}$ 的初等因子组</strong>，设为：</p><script type="math/tex; mode=display">(\lambda - \lambda_1)^{m_1}, (\lambda - \lambda_2)^{m_2}, \dots, (\lambda - \lambda_s)^{m_s}</script><p>且 $m_1 + m_2 + \cdots + m_s = n$。</p></li><li><p><strong>写出每个初等因子对应的 Jordan 块</strong>。</p></li><li><p><strong>构造 Jordan 标准型</strong>：</p><script type="math/tex; mode=display">\boldsymbol{J} = \begin{bmatrix}\boldsymbol{J}_1(\lambda_1) & & & \\& \boldsymbol{J}_2(\lambda_2) & & \\& & \ddots & \\& & & \boldsymbol{J}_s(\lambda_s)\end{bmatrix}</script></li></ol><h3 id="计算工具"><a href="#计算工具" class="headerlink" title="计算工具"></a>计算工具</h3><p>在实际计算中，Python 提供了强大的 <code>NumPy</code> 和 <code>SymPy</code> 库，可以用于快速计算 Jordan 标准型。</p>]]></content>
      
      
      <categories>
          
          <category> 矩阵论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 矩阵论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵论：欧式空间与线性变换介绍</title>
      <link href="/blog/2025/01/12/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E6%AC%A7%E5%BC%8F%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E4%BB%8B%E7%BB%8D/"/>
      <url>/blog/2025/01/12/%E7%9F%A9%E9%98%B5%E8%AE%BA%EF%BC%9A%E6%AC%A7%E5%BC%8F%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="欧式空间与线性变换介绍"><a href="#欧式空间与线性变换介绍" class="headerlink" title="欧式空间与线性变换介绍"></a>欧式空间与线性变换介绍</h2><p>欧式（Euclid）空间作为一种特殊的线性空间，我们先引入线性空间的概念。</p><h3 id="定义-1-线性空间"><a href="#定义-1-线性空间" class="headerlink" title="定义 1: 线性空间"></a>定义 1: 线性空间</h3><p>设 $V$ 是一个非空集合，它的元素用 $x, y, z$ 等表示，称为向量；$K$ 是一个数域，它的元素用 $k, l, m$ 表示，如果 $V$ 满足以下条件：</p><ol><li><p>在 $V$ 中定义一个加法运算，即当 $x,y\in V$ 时，有唯一的和 $x + y\in V$，且满足以下性质：</p><ul><li><strong>结合律</strong>: $x + (y + z) = (x + y) + z$;</li><li><strong>交换律</strong>: $x + y = y + x$;</li><li><strong>零元素存在性</strong>: $\exists 0, s.t. x + 0 = x$;</li><li><strong>负元素存在性</strong>: $\forall x\in V,\exists y\in V, s.t.x + y = 0$，记 $y = -x$; </li></ul></li><li><p>在 $V$ 中定义数乘运算，即当 $x\in V,k \in K$ 时，有唯一的乘积 $kx\in V$，且满足以下性质：</p><ul><li><strong>因子分配律</strong>: $k(x+y) = kx + ky$;</li><li><strong>分配律</strong>: $(k+l)x = kx + lx$;</li><li><strong>结合律</strong>: $k(lx) = (kl)x$;</li><li><strong>中性元</strong>: $1 x = x$;</li></ul></li></ol><p>则称 $V$ 是数域 $K$ 上的线性空间。</p><p>定义中的 8 条性质非常重要。如果对于数域 $K$，向量空间 $V$，设加群 $(V, +)$（$+$ 为 $V$ 上满足交换律的运算），不难验证其满足群的定义。定义 $K \times V \rightarrow V: (k, \alpha) \rightarrow k\alpha$（即 $V$ 上的数乘运算），可以验证 $V$ 是一个 $K$-模。即，线性空间是一类特殊的模。</p><p>为借助数量运算以实现向量的运算，还要引入向量的坐标。</p><h3 id="定义-2-线性空间的基"><a href="#定义-2-线性空间的基" class="headerlink" title="定义 2: 线性空间的基"></a>定义 2: 线性空间的基</h3><p>设 $V$ 是数域 $K$ 上的线性空间，$x_1,x_2,\cdots,x_r\in V$，如果它满足：</p><ol><li>$x_1,x_2,\cdots,x_r$ 线性无关;</li><li>$\forall x \in V$ 都是 $x_1,x_2,\cdots,x_r$ 的线性组合;</li></ol><p>则称 $x_1,x_2,\cdots,x_r$ 是 $V$ 的一个 <strong>基</strong>，称 $x_i(i=1,2,\cdots,r)$ 为 <strong>基向量</strong>。</p><h3 id="定义-3-坐标系"><a href="#定义-3-坐标系" class="headerlink" title="定义 3: 坐标系"></a>定义 3: 坐标系</h3><p>称线性空间 $V^n$ 上的一个基 $x_1, x_2, \cdots, x_n$ 为 $V^n$ 的一个 <strong>坐标系</strong>。设向量 $x \in V^n$，它在该基下的线性表示式为</p><script type="math/tex; mode=display">x = \xi_1x_1 + \xi_2x_2 + \cdots + \xi_nx_n</script><p>则称 $\xi_1,\xi_2,\cdots,\xi_n$ 为 $x$ 在该基下的 <strong>坐标</strong> 或 <strong>分量</strong>，记为</p><script type="math/tex; mode=display">(\xi_1,\xi_2,\cdots,\xi_n)^\top</script><p>显然，线性空间 $V^n$ 存在多个不同的基，对应多个不同的坐标系，我们希望研究当基改变时，向量的坐标如何改变。</p><h3 id="基变换"><a href="#基变换" class="headerlink" title="基变换"></a>基变换</h3><p>首先介绍 <strong>基变换</strong>，即 $V^n$ 的一个基 $\boldsymbol{X} = ( \boldsymbol{x}_1,  \boldsymbol{x}_2, \cdots,  \boldsymbol{x}_n)$ 变为另一个基 $\boldsymbol{Y} = ( \boldsymbol{y}_1,  \boldsymbol{y}_2, \cdots,  \boldsymbol{y}_n)$。</p><p>由基的定义可知：</p><script type="math/tex; mode=display"> \boldsymbol{y}_i = c_{1i} \boldsymbol{x}_1 + c_{2i}  \boldsymbol{x}_2 + \cdots + c_{1n}  \boldsymbol{x}_n(i = 1,2,\cdots,n)</script><p>上式可以写成矩阵乘法形式：</p><script type="math/tex; mode=display">( \boldsymbol{y}_1,  \boldsymbol{y}_2, \cdots,  \boldsymbol{y}_n) = ( \boldsymbol{x}_1,  \boldsymbol{x}_2, \cdots,  \boldsymbol{x}_n) \boldsymbol{C}\tag{2.5.1}</script><p>其中矩阵</p><script type="math/tex; mode=display"> \boldsymbol{C} = \begin{bmatrix} c_{11} & c_{12} & \cdots & c_{1n}\\ c_{21} & c_{22} & \cdots & c_{2n}\\ \vdots & \vdots & & \vdots\\ c_{n1} & c_{n2} & \cdots & c_{nn}\end{bmatrix}</script><p>称为基变换的 <strong>过渡矩阵</strong>，式 (2.5.1) 称为 <strong>基变换公式</strong>。</p><p>显然，过渡矩阵是可逆矩阵，因为新基能变换为旧基。</p><h2 id="内积与欧式空间"><a href="#内积与欧式空间" class="headerlink" title="内积与欧式空间"></a>内积与欧式空间</h2><p>在线性空间中，向量的基本运算仅为线性运算。例如，在熟悉的二维或三维向量空间中，我们发现向量的模长、向量间的夹角等度量概念未能被线性空间直接表达。因此，我们引入<strong>内积</strong>与<strong>内积空间</strong>的概念。</p><h3 id="内积的定义"><a href="#内积的定义" class="headerlink" title="内积的定义"></a>内积的定义</h3><p><strong>定义</strong><br>设 $V$ 是实数域 $\mathbb{R}$ 上的线性空间，若对 $\forall x,y \in V$，按照某种规则定义一个实数 $(x,y)$，满足以下条件：</p><ol><li><strong>交换律</strong>：$(x,y) = (y,x)$；</li><li><strong>分配律</strong>：$(x,y+z) = (x,y) + (x,z)$；</li><li><strong>齐次性</strong>：$(kx,y) = k(x,y) = (x,ky), \forall k\in \mathbb{R}$；</li><li><strong>非负性</strong>：$(x,x) \geq 0$，且 $(x,x) = 0 \iff x = 0$。</li></ol><p>则称 $(x,y)$ 为向量 $x,y$ 的<strong>内积</strong>，称 $V$ 为<strong>欧式空间</strong>（Euclidean Space）。</p><h3 id="内积的性质"><a href="#内积的性质" class="headerlink" title="内积的性质"></a>内积的性质</h3><p>内积具有以下基本性质：</p><ul><li>$( \boldsymbol{x}, k \boldsymbol{y}) = k( \boldsymbol{x}, \boldsymbol{y})$；</li><li>$( \boldsymbol{x}, \boldsymbol{0}) = 0$。</li></ul><h3 id="向量的模长"><a href="#向量的模长" class="headerlink" title="向量的模长"></a>向量的模长</h3><p>在欧式空间中，我们可以定义向量的<strong>长度</strong>（模、范数）如下：</p><p><strong>定义</strong><br>在欧式空间 $V$ 中，非负实数  </p><script type="math/tex; mode=display">\left|  \boldsymbol{x} \right| = \sqrt{( \boldsymbol{x}, \boldsymbol{x})}</script><p>称为向量 $\boldsymbol{x}$ 的<strong>长度</strong>（或 <strong>2-范数</strong>，下一节将介绍）。</p><p><strong>单位向量与单位化</strong><br>在二维或三维向量空间中，通常选取 $(1,0,0)$ 等为坐标轴，这些长度为 $1$ 的向量称为<strong>单位向量</strong>。如果 $\boldsymbol{x} \neq 0$，可以通过<strong>单位化（规范化）</strong> 得到单位向量：</p><script type="math/tex; mode=display"> \boldsymbol{x}_0 = \frac{\boldsymbol{x}}{\left|  \boldsymbol{x} \right|}</script><h3 id="向量夹角"><a href="#向量夹角" class="headerlink" title="向量夹角"></a>向量夹角</h3><p>在低维空间中，向量的夹角概念较直观。为了在欧式空间中定义向量夹角，我们利用 <strong>Cauchy–Schwarz 不等式</strong>：</p><script type="math/tex; mode=display">\left| \frac{( \boldsymbol{x}, \boldsymbol{y})}{\left|  \boldsymbol{x}\right|\left|  \boldsymbol{y}\right|} \right| \leq 1</script><p>进而定义两个非零向量 $\boldsymbol{x}$ 和 $\boldsymbol{y}$ 的夹角 $\left\langle  \boldsymbol{x},  \boldsymbol{y} \right\rangle$ 的<strong>余弦值</strong>：</p><script type="math/tex; mode=display">\cos \left\langle  \boldsymbol{x},  \boldsymbol{y} \right\rangle = \frac{( \boldsymbol{x}, \boldsymbol{y})}{\left|  \boldsymbol{x} \right| \left|  \boldsymbol{y} \right|}</script><h3 id="向量正交"><a href="#向量正交" class="headerlink" title="向量正交"></a>向量正交</h3><p><strong>定义</strong><br>若欧式空间中的两个向量 $\boldsymbol{x}$ 和 $\boldsymbol{y}$ 满足：</p><script type="math/tex; mode=display">(x,y) = 0</script><p>则称它们<strong>正交（垂直）</strong>。</p><p><strong>定理</strong><br>在欧式空间中，若向量组 $\{x_1, x_2, \dots, x_n\}$ 互相正交，则它们必然线性无关。</p><h3 id="正交基与标准正交基"><a href="#正交基与标准正交基" class="headerlink" title="正交基与标准正交基"></a>正交基与标准正交基</h3><p><strong>定义</strong><br>在欧式空间 $V^n$ 中，由 $n$ 个非零向量组成的<strong>正交向量组</strong>称为 $V^n$ 的<strong>正交基</strong>。若正交基中的向量均为单位向量，则称为<strong>标准正交基</strong>。</p><h3 id="Schmidt-正交化"><a href="#Schmidt-正交化" class="headerlink" title="Schmidt 正交化"></a>Schmidt 正交化</h3><p>如何从一组普通的基构造标准正交基？一种方法是<strong>Schmidt 正交化法（Gram-Schmidt 过程）</strong>。</p><h4 id="施密特正交化步骤"><a href="#施密特正交化步骤" class="headerlink" title="施密特正交化步骤"></a>施密特正交化步骤</h4><p>给定线性无关的向量组 $\{ \boldsymbol{v}_1,  \boldsymbol{v}_2, \dots,  \boldsymbol{v}_n\}$，施密特正交化的目标是构造正交向量组 $\{ \boldsymbol{u}_1,  \boldsymbol{u}_2, \dots,  \boldsymbol{u}_n\}$：</p><ol><li><p><strong>初始向量处理</strong>：<br>令第一个正交向量：</p><script type="math/tex; mode=display">\boldsymbol{u}_1 = \boldsymbol{v}_1</script><p>由于 $\boldsymbol{v}_1 \neq 0$，则 $\boldsymbol{u}_1 \neq 0$。</p></li><li><p><strong>构造第 $i$ 个向量的正交化</strong>：<br>从第二个向量开始，为了从 $\boldsymbol{v}_i$ 中去掉前面向量 $\boldsymbol{u}_1, \dots, \boldsymbol{u}_{i-1}$ 的分量，定义投影：</p><script type="math/tex; mode=display">\frac{( \boldsymbol{v}_i,  \boldsymbol{u}_k)}{( \boldsymbol{u}_k,  \boldsymbol{u}_k)}  \boldsymbol{u}_k</script><p>表示 $\boldsymbol{v}_i$ 在 $\boldsymbol{u}_k$ 上的投影。</p><p>去掉与 $\boldsymbol{u}_1, \dots, \boldsymbol{u}_{i-1}$ 重叠的部分，得到：</p><script type="math/tex; mode=display">\boldsymbol{u}_i = \boldsymbol{v}_i - \sum_{k=1}^{i-1} \frac{( \boldsymbol{v}_i,  \boldsymbol{u}_k)}{( \boldsymbol{u}_k,  \boldsymbol{u}_k)}  \boldsymbol{u}_k</script></li><li><p><strong>归一化</strong>：<br>将每个 $\boldsymbol{u}_i$ 归一化为单位向量：</p><script type="math/tex; mode=display">\boldsymbol{e}_i = \frac{ \boldsymbol{u}_i}{\left| \boldsymbol{u}_i\right|}</script></li></ol><p>最终得到一组<strong>正交归一向量</strong>：</p><script type="math/tex; mode=display">\{ \boldsymbol{e}_1,  \boldsymbol{e}_2, \dots,  \boldsymbol{e}_n\}</script><p>有了以上的铺垫，接下来我们正式引入线性变换的概念。线性变换提供了一种在线性空间之间进行映射的框架，其本质在于保持向量空间中的线性结构。通过线性变换，我们可以将一个线性空间的元素映射到另一个线性空间中，并保持加法和标量乘法的运算法则。</p><h3 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h3><p>首先，我们引入 <strong>变换</strong> 的概念如下：</p><p><strong>定义 4:</strong> 设 $V$ 是属于 $K$ 上的线性空间，$T$ 是 $V$ 到自身的一个映射，使对任意向量 $x\in V$，$V$ 中都有唯一向量 $y$ 与之对应，则称 $T$ 是 $V$ 的一个 <strong>变换</strong> 或 <strong>算子</strong>，记为 $Tx = y$，称 $y$ 为 $x$ 在 $T$ 下的象，$x$ 是 $y$ 的原象。</p><p><strong>定义 5:</strong> 如果数域 $K$ 上的线性空间 $V$ 的一个变换 $T$ 具有以下性质：</p><script type="math/tex; mode=display">T(kx + ly) = k(Tx) + l(Ty)</script><p>其中，$x,y \in V,k,l\in K$，则称 $T$ 为 $V$ 的一个 <strong>线性变换</strong> 或 <strong>线性算子</strong>。</p><h4 id="线性变换的性质"><a href="#线性变换的性质" class="headerlink" title="线性变换的性质"></a>线性变换的性质</h4><p>不难验证，线性变换有如下性质，且线性空间 $V$ 上所有的线性变换的集合，在所论的线性运算下，构成一个新的线性空间，记为 $\text{Hom}(V, V)$，称为线性空间 $V$ 的 <strong>同态</strong>。</p><ol><li><strong>线性变换的加法</strong>：$(T_1+ T_2)x = T_1x+T_2x, \forall x\in V$，和仍为线性变换。<ul><li>$T_1 + T_2 = T_2 + T_1$;</li><li>$(T_1 + T_2) + T_3 = T_1 + (T_2 + T_3)$;</li><li>$T + T_0 = T$;</li><li>$T + (-T) = T_0$;</li><li>线性变换 $T$ 的 <strong>负变换</strong> $-T$ 定义为： <script type="math/tex">(-T)x = -(Tx), \forall x\in V</script></li></ul></li><li><strong>线性变换的数乘</strong>：$(kT)x = k(Tx), \forall x\in V$，线性变换的数乘仍是线性变换。<ul><li>$k(T_1 + T_2) = kT_1 + kT_2$;</li><li>$(k+l)T = kT + lT$;</li><li>$(kl)T = k(lT)$;</li><li>$1 T = T$;</li></ul></li></ol><h4 id="线性变换的矩阵表示"><a href="#线性变换的矩阵表示" class="headerlink" title="线性变换的矩阵表示"></a>线性变换的矩阵表示</h4><p>诸如二维平面上的旋转、微分和积分等都是线性变换。考虑到有限维线性空间的向量可以用坐标表示出来，进一步考虑则可以通过坐标把线性变换用矩阵表示出来，从而可以把抽象的变换转化成具体的矩阵来处理。故引入线性变换的 <strong>矩阵表示</strong>。</p><p>设 $T$ 是线性空间 $V^n$ 的线性变换，$x \in V^n$，且 $x_1, x_2, \dots, x_n$ 是 $V^n$ 的一个基，则有：</p><script type="math/tex; mode=display">x = a_1x_1 + a_2x_2 + \dots + a_nx_n</script><script type="math/tex; mode=display">Tx = a_1(Tx_1) + a_2(Tx_2) + \dots + a_n(Tx_n)</script><p>这表明，$V^n$ 的任一向量 $x$ 的像可以由基像组 $Tx_1,Tx_2,\dots,Tx_n$ 唯一确定，因为基像组仍 $\in V^n$，所以有：</p><script type="math/tex; mode=display">\left.\begin{matrix} Tx_1 = a_{11}x_1 + a_{21}x_2 + \dots + a_{n1}x_n\\Tx_2 = a_{12}x_1 + a_{22}x_2 + \dots + a_{n2}x_n\\\cdots \\Tx_n = a_{1n}x_1 + a_{2n}x_2 + \dots + a_{nn}x_n\\\end{matrix}\right\}\tag{2.6.1}</script><p>即：</p><script type="math/tex; mode=display">Tx_i = \sum_{j=1}^{n} a_{ji}x_j, \quad i = 1,2,\dots,n</script><p>用矩阵乘法表示式 (2.6.1) 为：</p><script type="math/tex; mode=display">T(x_1,x_2,\dots,x_n) = (Tx_1,Tx_2,\dots,Tx_n) = (x_1,x_2,\dots,x_n) \boldsymbol{A}\tag{2.6.2}</script><p>其中：</p><script type="math/tex; mode=display">\boldsymbol{A} = \begin{bmatrix}a_{11} & a_{12} & \cdots & a_{1n}\\a_{21} & a_{22} & \cdots & a_{2n}\\\cdots & \cdots & & \cdots\\a_{n1} & a_{n2} & \cdots & a_{nn}\\\end{bmatrix}</script><p>即矩阵 $\boldsymbol{A}$ 的第 $i$ 列为 $Tx_i$ 的坐标。</p><p><strong>定义 3</strong> 式 (2.6.2) 中的矩阵 $\boldsymbol{A}$ 称为 $T$ 在 $V^n$ 的基 $x_1, x_2, \dots, x_n$ 下的矩阵，称 $\boldsymbol{A}$ 为线性变换 $T$ 的矩阵表示。</p><h4 id="特殊的线性变换"><a href="#特殊的线性变换" class="headerlink" title="特殊的线性变换"></a>特殊的线性变换</h4><ol><li><strong>零变换</strong>：$T_0(x) = \boldsymbol{0}, \forall x\in V$</li><li><strong>恒等变换</strong>：$T_1(x) = x, \forall x\in V$</li></ol><h3 id="正交变换"><a href="#正交变换" class="headerlink" title="正交变换"></a>正交变换</h3><p><strong>定义 4</strong> 设 $V$ 为欧式空间，$T$ 是 $V$ 上的一个线性变换，如果 $T$ 保持 $V$ 中任意向量 $\boldsymbol{x}$ 的长度不变，则有：</p><script type="math/tex; mode=display">(T \boldsymbol{x},T \boldsymbol{x}) = ( \boldsymbol{x}, \boldsymbol{x})</script><p>那么称 $T$ 是 $V$ 的一个 <strong>正交变换</strong>。</p><p><strong>定理 1</strong> 欧式空间上的线性变换是正交变换 $\Leftrightarrow$ 它对于标准正交基的矩阵是正交矩阵。</p><h3 id="对称变换"><a href="#对称变换" class="headerlink" title="对称变换"></a>对称变换</h3><p><strong>定义 5</strong> 设 $V$ 为欧式空间，$T$ 是 $V$ 上的一个线性变换，且对 $V$ 中任意两个向量 $\boldsymbol{x}, \boldsymbol{y}$，都有：</p><script type="math/tex; mode=display">(T \boldsymbol{x}, \boldsymbol{y}) = ( \boldsymbol{x},T \boldsymbol{y})</script><p>那么称 $T$ 是 $V$ 的一个 <strong>对称变换</strong>。</p><p><strong>定理 2</strong> 欧式空间上的线性变换是对称变换 $\Leftrightarrow$ 它对于标准正交基的矩阵是实对称矩阵。</p><p>对于线性变换的进一步求解，将在下一节中叙述。</p>]]></content>
      
      
      <categories>
          
          <category> 矩阵论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 矩阵论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字逻辑与数字系统相关记背知识点</title>
      <link href="/blog/2025/01/08/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E8%AE%B0%E8%83%8C%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/blog/2025/01/08/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E5%AD%97%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E8%AE%B0%E8%83%8C%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="Verilog"><a href="#Verilog" class="headerlink" title="Verilog"></a>Verilog</h1><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ul><li>命名规则与C语言相同；</li><li>关键字必须小写；</li><li><strong>存盘文件名应与设计的模块名相同</strong>；</li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><strong>四值逻辑</strong>：0、1、X(不定)、Z(高阻)；</li><li>模块由两部分构成：<strong>描述接口、描述功能</strong>；<img src="1.png" alt></li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>数据I/O类型；<img src="2.png" alt></li><li><strong>always中被赋值的信号必须用reg类型的变量</strong>；</li><li>输入和双向端口不能声明为reg型；</li><li>parameter：符号常量，其定义只在本模块内有效；</li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul><li>位连接运算符{  } ，将两个或多个信号的某些位拼接起来。<strong>不允许连接非定长常数</strong>；</li><li>自动调整位宽。运算表达式结果的长度由最长的操作数决定；</li><li>操作结果的长度:  由赋值左端目标长度决定；</li></ul><h2 id="功能描述语句"><a href="#功能描述语句" class="headerlink" title="功能描述语句"></a>功能描述语句</h2><ul><li><strong>assign , always , 元件例化，是并发语句</strong>；</li></ul><h3 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h3><p><img src="3.png" alt></p><h3 id="always"><a href="#always" class="headerlink" title="always"></a>always</h3><p><img src="4.png" alt></p><h3 id="敏感信号表"><a href="#敏感信号表" class="headerlink" title="敏感信号表"></a>敏感信号表</h3><ul><li>敏感信号的变化才能启动进程；</li><li>组合逻辑中，所有输入都作为敏感信号,否则仿真结果和综合结果会不一致；</li></ul><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li><strong>不要在一个aways 中同时使用= ，&lt;=赋值</strong>；</li><li>if、case、for 语句必需在 always 块中；</li></ul><h2 id="设计组合电路"><a href="#设计组合电路" class="headerlink" title="设计组合电路"></a>设计组合电路</h2><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><p><img src="5.png" alt></p><h2 id="设计时序电路"><a href="#设计时序电路" class="headerlink" title="设计时序电路"></a>设计时序电路</h2><h4 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h4><p><img src="6.png" alt></p><h4 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h4><ul><li><strong>异步信号必须放在敏感信号表中；必须都是边沿</strong>；</li><li>锁存器的所有输入都放在敏感信号表中；锁存器敏感信号都是电平。</li></ul><h2 id="元件例化"><a href="#元件例化" class="headerlink" title="元件例化"></a>元件例化</h2><ul><li>一个元件是一段结构完整的 module 模块；</li><li><strong>不能在always语句内部引用子模块</strong>；</li></ul><h1 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h1><h2 id="寄存器堆"><a href="#寄存器堆" class="headerlink" title="寄存器堆"></a>寄存器堆</h2><ul><li>由多个寄存器构成的集合。常用于数据寄存。 有三组外部信号：地址（短地址）、数据、读/写控制；</li><li>多端口寄存器；</li><li>可同时读、写， 可同时输出两个数；</li></ul><h2 id="寄存器队列"><a href="#寄存器队列" class="headerlink" title="寄存器队列"></a>寄存器队列</h2><ul><li>FIFO（First In First Out，先进先出），用若干个移位寄存器构建的 小型存储部件。用于指令队列；</li><li>无地址线，双端口存储器，可同时读写；</li><li>FIFO用于两个不同系统通信、数据采集传送、串并转换；</li></ul><h2 id="寄存器栈"><a href="#寄存器栈" class="headerlink" title="寄存器栈"></a>寄存器栈</h2><ul><li>LIFO（ Last In First Out，后进先出）方式，用若干个双向移位 寄存器构建的小型存储部件；</li><li>用于减少函数调用时对内存的访问；</li></ul><h2 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h2><ul><li>特性：能读能写、易失；</li><li>作用：存放编写的程序和数据</li><li>逻辑结构：<img src="7.png" alt></li><li><strong>逻辑结构包括：地址译码器、存储矩阵和读写控制电路</strong>；</li><li>分为SRAM(Static RAM)和DRAM(Dynamic RAM)；<img src="8.png" alt><img src="9.png" alt><img src="10.png" alt></li></ul><h2 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h2><ul><li>ROM的逻辑构成＝ <strong>与门阵列（地址译码器）＋或门阵列（存储矩阵）</strong>；</li><li>分为PROM、EPROM等；</li></ul><h2 id="存储器容量计算"><a href="#存储器容量计算" class="headerlink" title="存储器容量计算"></a>存储器容量计算</h2><ul><li>单元数$\times$每单元的位数；即字数$\times$字长；</li></ul><h1 id="可编程逻辑器件PLD"><a href="#可编程逻辑器件PLD" class="headerlink" title="可编程逻辑器件PLD"></a>可编程逻辑器件PLD</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul><li>现代数字系统由三种积木块构成：CPU＋PLD＋RAM；</li></ul><h2 id="编程部位"><a href="#编程部位" class="headerlink" title="编程部位"></a>编程部位</h2><p><img src="11.png" alt></p><h2 id="编程方法"><a href="#编程方法" class="headerlink" title="编程方法"></a>编程方法</h2><p><img src="12.png" alt></p><h2 id="CPLD"><a href="#CPLD" class="headerlink" title="CPLD"></a>CPLD</h2><p><img src="13.png" alt></p><h2 id="FPGA"><a href="#FPGA" class="headerlink" title="FPGA"></a>FPGA</h2><p><img src="14.png" alt><img src="15.png" alt></p><h3 id="在系统可编程ISP"><a href="#在系统可编程ISP" class="headerlink" title="在系统可编程ISP"></a>在系统可编程ISP</h3><ul><li>传统的PLD在用于生产时，是先编程后装配；</li><li><strong>isp则可以在装配之前、装配过程中和装配之后再编程</strong>；</li></ul><h1 id="数字系统"><a href="#数字系统" class="headerlink" title="数字系统"></a>数字系统</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><ul><li>具有存储、传输、处理信息能力的逻辑系统集合；</li><li>由“<strong>数据通路+控制逻辑</strong>”构成，其工作具有周期性；</li><li><strong>数字系统与逻辑功能部件的区别：有无控制器</strong>；</li><li>在各部件之间传送信息的公共通路，称为<strong>数据通路</strong>。由总线连接的运算单元（组合电路）和存储单元构成；</li></ul><h2 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h2><p><img src="16.png" alt></p><h2 id="设计方法"><a href="#设计方法" class="headerlink" title="设计方法"></a>设计方法</h2><ul><li>自顶向下方法（from top to down ）：是将规模较大的系统从逻辑上划分为控制电路＋受控电路；</li><li>步骤：<ol><li>划分子系统、子模块；</li><li>数据通路；</li><li>用数学语言(工具)，描述控制器的控制过程；</li><li>设计控制器；</li><li>设计数据处理器；</li></ol></li></ul><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1><blockquote><p>希望别出太偏捏</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 硬件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图的染色问题</title>
      <link href="/blog/2025/01/07/%E5%9B%BE%E7%9A%84%E6%9F%93%E8%89%B2%E9%97%AE%E9%A2%98/"/>
      <url>/blog/2025/01/07/%E5%9B%BE%E7%9A%84%E6%9F%93%E8%89%B2%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="相关定义概述"><a href="#相关定义概述" class="headerlink" title="相关定义概述"></a>相关定义概述</h1><ul><li><strong>$\chi (G)$</strong>：图的着色数，the chromatic number of G；</li><li>有点着色，边着色，面着色几种类型；</li><li>$P_G(k)$：色多项式，表示图$G$用$k$种颜色染色的方法数；</li></ul><h1 id="常见图的点着色数"><a href="#常见图的点着色数" class="headerlink" title="常见图的点着色数"></a>常见图的点着色数</h1><blockquote><p>零图（无边只有顶点）：1；<br>完全图$K_n$：n；<br>非零二部图：2；</p><p>定理：简单图的点着色数小于等于最大度数 + 1；</p></blockquote><h1 id="非连通图的着色"><a href="#非连通图的着色" class="headerlink" title="非连通图的着色"></a>非连通图的着色</h1><blockquote><p>如果$G$为非连通图，那么它的色多项式等于它的所有连通分量的乘积；</p></blockquote><h1 id="商图"><a href="#商图" class="headerlink" title="商图"></a>商图</h1><p>把图的顶点按照某种等价类规则划分，直观上就是把两个点捏在一起；<img src="商图.png" alt></p><h1 id="构建色多项式"><a href="#构建色多项式" class="headerlink" title="构建色多项式"></a>构建色多项式</h1><h2 id="法一、尝试通过删边得到好求的色多项式"><a href="#法一、尝试通过删边得到好求的色多项式" class="headerlink" title="法一、尝试通过删边得到好求的色多项式"></a>法一、尝试通过删边得到好求的色多项式</h2><p><img src="色多项式构建定理.png" alt></p><h2 id="法二、韦尔奇鲍威尔法"><a href="#法二、韦尔奇鲍威尔法" class="headerlink" title="法二、韦尔奇鲍威尔法"></a>法二、韦尔奇鲍威尔法</h2><ol><li>将顶点按照度数递减排序；</li><li>用第一种颜色对度数最大的顶点以及和该点不相邻的所有顶点进行染色；</li><li>对剩余顶点重复上述步骤；</li></ol><h2 id="法三、递推构建色多项式"><a href="#法三、递推构建色多项式" class="headerlink" title="法三、递推构建色多项式"></a>法三、递推构建色多项式</h2><p><img src="色多项式递推构建.png" alt></p><h1 id="色多项式性质"><a href="#色多项式性质" class="headerlink" title="色多项式性质"></a>色多项式性质</h1><p><img src="色多项式性质.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP Exercises</title>
      <link href="/blog/2025/01/06/CSAPP%20Exercises/"/>
      <url>/blog/2025/01/06/CSAPP%20Exercises/</url>
      
        <content type="html"><![CDATA[<h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="2-21"><a href="#2-21" class="headerlink" title="2.21"></a>2.21</h2><p><img src="2.21.png" alt></p><h2 id="2-23"><a href="#2-23" class="headerlink" title="2.23"></a>2.23</h2><p><img src="2.23.png" alt></p><h2 id="2-24"><a href="#2-24" class="headerlink" title="2.24"></a>2.24</h2><p><img src="2.24.png" alt><br>两种类型都是先截断（对对应的无符号数取模操作），补码的话再进行一次U2T转化；</p><h2 id="2-33"><a href="#2-33" class="headerlink" title="2.33"></a>2.33</h2><p><img src="2.33.png" alt></p><h2 id="2-40"><a href="#2-40" class="headerlink" title="2.40"></a>2.40</h2><p><img src="2.40.png" alt></p><h2 id="2-44"><a href="#2-44" class="headerlink" title="2.44"></a>2.44</h2><p><img src="2.44.png" alt><br>A. 反例：$x = -1, x - 1= 0$；<br>B. $x \&amp; 0111_2 \ne 0111_2$当$x$的低3位有1位等于0时即可成立，$x &lt;&lt; 29 &lt; 0$将$x$的低3位移到高三位。那么低三位如果全为1，后者为真，有0则前者为真，所以表达式恒为真；<br>C. 反例：$x$为一个比较大的正数，平方后超过$2^{31} - 1$；<br>D. 真：$x = Tmin, -x = Tmin$，其余情况x如果是负数，那么-x一定是非负数；<br>E. 反例：$x = Tmin, -x = Tmin$；<br>F. 真：首先，比较类型为无符号数比较；加法都按补码进行运算，两边二进制结果显然一致；<br>G.真：$-y = \sim y + 1\rightarrow \sim y = -y - 1\rightarrow x <em> \sim y + uy </em> ux = x * (-y + y - 1) = -x$；全部按二进制表示理解即可；</p><h2 id="2-45"><a href="#2-45" class="headerlink" title="2.45"></a>2.45</h2><p><img src="2.45.png" alt></p><h2 id="2-47"><a href="#2-47" class="headerlink" title="2.47"></a>2.47</h2><p><img src="2.47.png" alt></p><h2 id="2-54"><a href="#2-54" class="headerlink" title="2.54"></a>2.54</h2><p><img src="2.54.png" alt><br>A. double范围和精度比int大；<br>B. 假，int转化为float可能会发生舍入；<br>C. 假，double转化为float会截断；<br>D. double范围和精度比float大；<br>E. 没毛病，只需改变符号位；<br>F. 两边都先转化为double类型再运算；<br>G. 没毛病，即使溢出到正无穷也是大于0；<br>H. 假，浮点数运算不满足结合律；</p><h2 id="2-60"><a href="#2-60" class="headerlink" title="2.60"></a>2.60</h2><p><img src="2.60.png" alt></p><pre><code class="lang-c">unsigned replace_byte(unsigned x, int i, unsigned char b) &#123;    int i_times_8 = i &lt;&lt; 3; // 将字节单位转化为位；    unsigned mask = 0xFF &lt;&lt; i_times_8; // 将0xFF左移i个字节，得到第i个字节为FF，其余全为0的字符串；    // x &amp; ~mask 可以将x的第i个字节清0；    // b &lt;&lt; i_times_8 将b移动到第i个字节上；    // 两者进行或运算即可实现替换；    return (x &amp; ~mask) | (b &lt;&lt; i_times_8);&#125;</code></pre><h2 id="2-65"><a href="#2-65" class="headerlink" title="2.65"></a>2.65</h2><p><img src="2.65.png" alt></p><pre><code class="lang-c">int odd_ones(unsigned x) &#123;    // x的高位和低位进行异或，如果1对0，得到1；如果1对1或0对0，得到0，那么高位有奇数个1还是偶数个1的信息就被转移到低位中；    x = x ^ (x &gt;&gt; 16); // 将x的高16位与低16位异或    x = x ^ (x &gt;&gt; 8);    x = x ^ (x &gt;&gt; 4);    x = x ^ (x &gt;&gt; 2);    x = x &amp; 1;    return x;&#125;</code></pre><h2 id="2-67"><a href="#2-67" class="headerlink" title="2.67"></a>2.67</h2><p><img src="2.67.png" alt><br>A. C标准中，在32位机器上，移位32位是一种未定义的行为；<br>B. 很简单，先移31位，再移一位即可；</p><pre><code class="lang-c">int beyond_msb = 1 &lt;&lt; 32;// 改为int beyond_msb = set_msb &lt;&lt; 1;</code></pre><p>C. 类似地（16位机器上，移动n + 16位和移动n位效果一样）；</p><pre><code class="lang-c">int set_msb = 1 &lt;&lt; 15;int beyond_msb = set_msb &lt;&lt; 1;</code></pre><h2 id="2-68"><a href="#2-68" class="headerlink" title="2.68"></a>2.68</h2><p><img src="2.68.png" alt></p><pre><code class="lang-c">int lower_one_mask(int n) &#123;    unsigned Part = -1; // 各位全1    unsigned len = sizeof(int) * 8 - n; // 右移位数    return (int)(Part &gt;&gt; len);&#125;</code></pre><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><h2 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h2><p><img src="3.1.png" alt></p><h2 id="3-2"><a href="#3-2" class="headerlink" title="3.2"></a>3.2</h2><p><img src="3.2.png" alt></p><pre><code class="lang-asmx86">movl %eax, (%rsp)movw (%rax), %dxmovb $0xFF, %blmovb (%rsp, %rdx, 4), %dlmovq (%rdx), %raxmovw %dx, (%rax)</code></pre><p>评价是别管Src和Dest，看哪个对涉及对寄存器取值了；</p><h2 id="3-3"><a href="#3-3" class="headerlink" title="3.3"></a>3.3</h2><p><img src="3.3.png" alt></p><ol><li><strong>%ebx不能用来存放内存地址！！！</strong>（此题存了立即数0xF的在内存中的地址）；</li><li>%rax配movq，movl配%eax；</li><li>Src和Dest都在对内存进行引用；</li><li>%sl是什么东西；</li><li>立即数不能作为Dest；</li><li>%rdx和mol不匹配；</li><li>%si配movw；</li></ol><h2 id="3-4"><a href="#3-4" class="headerlink" title="3.4"></a>3.4</h2><p><img src="3.4.png" alt></p><h2 id="3-5"><a href="#3-5" class="headerlink" title="3.5"></a>3.5</h2><p><img src="3.5.png" alt></p><pre><code class="lang-c">void decode1(long *xp, long *yp, long *zp) &#123;    long x = *xp;    long y = *yp;    long z = *zp;    *yp = x;    *zp = y;    *xp = z;    return;&#125;</code></pre><h2 id="3-6"><a href="#3-6" class="headerlink" title="3.6"></a>3.6</h2><p><img src="3.6.png" alt><br><strong>lea是直接取寄存器！！！</strong></p><h2 id="3-7"><a href="#3-7" class="headerlink" title="3.7"></a>3.7</h2><p><img src="3.7.png" alt></p><h2 id="3-9"><a href="#3-9" class="headerlink" title="3.9"></a>3.9</h2><p><img src="3.9.png" alt></p><h2 id="3-15"><a href="#3-15" class="headerlink" title="3.15"></a>3.15</h2><p><img src="3.15.png" alt><br>A. <code>4003fc + 0x02 = 4003fe</code>；<br>B. <code>400431 + 0xf4 = 400425</code>；<br>C. ja:<code>400547</code>；pop指定的地址 + 0x02 = ja的跳转地址，所以pop:<code>400545</code>；<br>D. <code>4005ed + 0x ff ff ff 73 = 400560</code>；</p><h2 id="3-18"><a href="#3-18" class="headerlink" title="3.18"></a>3.18</h2><p><img src="3.18.png" alt></p><h2 id="3-20"><a href="#3-20" class="headerlink" title="3.20"></a>3.20</h2><p><img src="3.20.png" alt></p><h2 id="3-26"><a href="#3-26" class="headerlink" title="3.26"></a>3.26</h2><p><img src="3.26.png" alt><br>A. 中间翻译法</p><pre><code class="lang-c">goto Test;Loop:    body;Test:    t = test;    if (t) goto Loop;end;</code></pre><p>B.</p><pre><code class="lang-c">while (x != 0) &#123;    val = x ^ val;    x = x &gt;&gt; 1;&#125;</code></pre><p>C. 从一个无符号长整数$x$的最高有效位开始，逐位移除最低有效位，直到剩下最后一个有效的非零位。然后检查该值的最低有效位是否为 1，并返回结果。即判断$x$的奇偶性；</p><h2 id="3-27"><a href="#3-27" class="headerlink" title="3.27"></a>3.27</h2><p><img src="3.27.png" alt></p><pre><code class="lang-c">// Jump-to-middleinit:    int result = 1;    int i = 2;    goto test;loop:    result *= i;    i++;test:    if i &lt;= n:        goto loop;done;// guarded-doinit:    int result = 1;    int i = 2;    if (n &lt; 1) goto end;loop:    result *= i;    i++;    if (t) goto loop;end;</code></pre><h2 id="3-31"><a href="#3-31" class="headerlink" title="3.31"></a>3.31</h2><p><img src="3.31.png" alt></p><h2 id="3-32"><a href="#3-32" class="headerlink" title="3.32"></a>3.32</h2><p><img src="3.32.png" alt></p><h2 id="3-33"><a href="#3-33" class="headerlink" title="3.33"></a>3.33</h2><p><img src="3.33.png" alt></p><h2 id="3-36"><a href="#3-36" class="headerlink" title="3.36"></a>3.36</h2><p><img src="3.36.png" alt></p><h2 id="3-37"><a href="#3-37" class="headerlink" title="3.37"></a>3.37</h2><p><img src="3.37.png" alt></p><h2 id="3-38"><a href="#3-38" class="headerlink" title="3.38"></a>3.38</h2><p><img src="3.38.png" alt></p><h2 id="3-44"><a href="#3-44" class="headerlink" title="3.44"></a>3.44</h2><p><img src="3.44.png" alt></p><div class="table-container"><table><thead><tr><th>P1</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr><tr><td>i</td><td>i</td><td>i</td><td>i</td><td>c</td><td>X</td><td>X</td><td>X</td></tr><tr><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td><td>13</td><td>14</td><td>15</td></tr><tr><td>j</td><td>j</td><td>j</td><td>j</td><td>d</td><td>X</td><td>X</td><td>X</td></tr></tbody></table></div><p>P1共占16个字节；</p><div class="table-container"><table><thead><tr><th>P2</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr><tr><td>i</td><td>i</td><td>i</td><td>i</td><td>c</td><td>d</td><td>X</td><td>X</td></tr><tr><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td><td>13</td><td>14</td><td>15</td></tr><tr><td>j</td><td>j</td><td>j</td><td>j</td><td>j</td><td>j</td><td>j</td><td>j</td></tr></tbody></table></div><p>P2共占16个字节；</p><div class="table-container"><table><thead><tr><th>P3</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr><tr><td>w[0]</td><td>w[0]</td><td>w[1]</td><td>w[1]</td><td>w[2]</td><td>w[2]</td><td>c[0]</td><td>c[1]</td></tr><tr><td>8</td><td>9</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>c[2]</td><td>X</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><p>P3共占10个字节；</p><div class="table-container"><table><thead><tr><th>P4</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr><tr><td>w</td><td>w</td><td>w</td><td>w</td><td>w</td><td>w</td><td>w</td><td>w</td></tr><tr><td>8</td><td>9</td><td>10</td><td>…</td><td></td><td></td><td></td><td></td></tr><tr><td>w</td><td>w</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td>16</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>c</td><td>c</td><td>c</td><td>c</td><td>c</td><td>c</td><td>c</td><td>c</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>c</td><td>c</td><td>c</td><td>c</td><td>c</td><td>c</td><td>c</td><td>c</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>c</td><td>c</td><td>c</td><td>c</td><td>c</td><td>c</td><td>c</td><td>c</td></tr></tbody></table></div><p>P4共占40个字节；</p><div class="table-container"><table><thead><tr><th>P5</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr><tr><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td></tr><tr><td>8</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>a</td><td>X</td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td></tr><tr><td>16</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>a</td><td>a</td><td>a</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td>24</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>t</td><td>t</td><td>t</td><td>t</td><td>t</td><td>t</td><td>t</td><td>t</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>t</td><td>t</td><td>t</td><td>t</td><td>t</td><td>t</td><td>t</td><td>t</td></tr></tbody></table></div><p>P5共占40个字节；</p><h2 id="3-45"><a href="#3-45" class="headerlink" title="3.45"></a>3.45</h2><p><img src="3.45.png" alt></p><div class="table-container"><table><thead><tr><th>rec</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>0</strong></td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr><tr><td><strong>a</strong></td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td></tr><tr><td><strong>8</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>b</strong></td><td>b</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>16</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>c</strong></td><td>c</td><td>c</td><td>c</td><td>c</td><td>c</td><td>c</td><td>c</td></tr><tr><td><strong>24</strong></td><td></td><td></td><td></td><td><strong>28</strong></td><td></td><td></td><td></td></tr><tr><td>d</td><td></td><td></td><td></td><td><strong>e</strong></td><td>e</td><td>e</td><td>e</td></tr><tr><td><strong>32</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>f</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>40</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>g</td><td>g</td><td>g</td><td>g</td><td>g</td><td>g</td><td>g</td><td>g</td></tr><tr><td><strong>48</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>h</strong></td><td>h</td><td>h</td><td>h</td><td>X</td><td>X</td><td>X</td><td>X</td></tr></tbody></table></div><p>rec共占56个字节；</p><div class="table-container"><table><thead><tr><th>rec’</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>0</strong></td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr><tr><td><strong>a</strong></td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td><td>a</td></tr><tr><td><strong>8</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>c</strong></td><td>c</td><td>c</td><td>c</td><td>c</td><td>c</td><td>c</td><td>c</td></tr><tr><td><strong>16</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>g</strong></td><td>g</td><td>g</td><td>g</td><td>g</td><td>g</td><td>g</td><td>g</td></tr><tr><td><strong>24</strong></td><td></td><td></td><td></td><td><strong>28</strong></td><td></td><td></td><td></td></tr><tr><td><strong>e</strong></td><td>e</td><td>e</td><td>e</td><td><strong>h</strong></td><td>h</td><td>h</td><td>h</td></tr><tr><td><strong>32</strong></td><td></td><td><strong>34</strong></td><td><strong>35</strong></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>b</strong></td><td>b</td><td><strong>d</strong></td><td><strong>f</strong></td><td></td><td></td><td></td></tr></tbody></table></div><p>rec‘总共占40个字节；</p><h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h1><h2 id="7-1"><a href="#7-1" class="headerlink" title="7.1"></a>7.1</h2><p><img src="7.1.png" alt></p><h2 id="7-2"><a href="#7-2" class="headerlink" title="7.2"></a>7.2</h2><p><img src="7.2.png" alt></p><h2 id="7-4"><a href="#7-4" class="headerlink" title="7.4"></a>7.4</h2><p><img src="7.4.png" alt><br>A. <code>4004de + 1 = 4004df</code>（callq的机器码e8占一个字节）；<br>B. <code>0x 00 00 00 05</code>，注意小端法！！！</p><h2 id="7-5"><a href="#7-5" class="headerlink" title="7.5"></a>7.5</h2><p><img src="7.5.png" alt><br>重定位条目包含了以下信息：</p><ul><li>R_X86_64_PC32表示采用PC相对寻址法；</li><li>offset表示偏移量为0xa = 10；</li><li>addend可以修正偏移量；<br>$r_{ptr} = 0x4004e8 - (0x4004d0 + 0xa) + (-4) = 10 = 0x0a$；<br>所以引用的值是0x 00 00 00 0a；在汇编代码中被更新为：<code>e8 0a 00 00 00</code>；</li></ul><h1 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h1><h2 id="10-1"><a href="#10-1" class="headerlink" title="10.1"></a>10.1</h2><p><img src="10.1.png" alt></p><pre><code>fd2 = 3</code></pre><p>原因是<code>Close(fd1)</code>后，文件描述符被释放；</p><h2 id="10-2"><a href="#10-2" class="headerlink" title="10.2"></a>10.2</h2><p><img src="10.2.png" alt></p><pre><code>c = f</code></pre><p>fd1读取一个字节后，文件位置确实++了，但fd1和fd2分两次打开，对应不同的描述符，从而对应不同的打开文件表，所以互不影响；</p><h2 id="10-3"><a href="#10-3" class="headerlink" title="10.3"></a>10.3</h2><p><img src="10.3.png" alt></p><pre><code>c = o</code></pre><p>父子进程共享同一个打开文件表；</p><h2 id="10-5"><a href="#10-5" class="headerlink" title="10.5"></a>10.5</h2><p><img src="10.5.png" alt></p><pre><code>c = o</code></pre><p>dup2将fd1重定向到fd2；</p><p>最后祝自己明天考试好运吧！</p>]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP 16-io4</title>
      <link href="/blog/2025/01/05/CSAPP%2016-io4/"/>
      <url>/blog/2025/01/05/CSAPP%2016-io4/</url>
      
        <content type="html"><![CDATA[<h1 id="UNIX-Linux-I-O"><a href="#UNIX-Linux-I-O" class="headerlink" title="UNIX/Linux I/O"></a>UNIX/Linux I/O</h1><ul><li>用户程序可通过调用特定的I/O函数的方式提出I/O请求。</li><li>在UNIX/Linux系统中，可以是<strong>C标准I/O库函数</strong>或<strong>系统调用的封装函数</strong>，前者如文件I/O函数<code>fopen()、fread()、fwrite()、fclose()</code>或控制台I/O函数<code>printf()、putc()、scanf()、getc()</code>等；后者如<code>open()、read()、write()、close()</code>等。</li><li>标准I/O库函数比系统调用封装函数抽象层次高，后者属于系统级I/O函数。与系统提供的API函数一样，前者是基于后者实现的。<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2>“一切皆文件”；</li><li>Linux中的文件都是二进制比特串；</li><li>所有的I/O设备在系统中都以文件形式呈现：<ul><li>/dev/sda2</li><li>/dev/tty2</li></ul></li><li>内核也以文件形式呈现：<ul><li>/boot/vmlinuz-3.13.0-55-generic (kernel image)</li><li>/proc (kernel data structures)<h2 id="文件分类"><a href="#文件分类" class="headerlink" title="文件分类"></a>文件分类</h2><h3 id="Regular-Files"><a href="#Regular-Files" class="headerlink" title="Regular Files"></a>Regular Files</h3></li></ul></li><li>Text files：用ASCII或Unicode字符编码的文件；</li><li>Binary files：可执行目标文件，图片；</li><li><strong>Kernal内核不能区分这两者</strong>；</li></ul><h3 id="Directories"><a href="#Directories" class="headerlink" title="Directories"></a>Directories</h3><p>一些常用命令：</p><ul><li><code>mrdir</code>创建文件夹；</li><li><code>ls</code>查看文件夹内容；</li><li><code>rmdir</code>删除文件夹（文件夹必须是空的）；</li><li><code>.</code>链接自己，<code>..</code>链接它的父文件夹，<code>cd ..</code>即可返回上一级目录；<br>Linux 文件系统<strong>以 /（根目录）为起点</strong>，所有文件和目录都组织在这个树状层次结构下。</li></ul><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>打开文件时，内核会返回一个小的非负整数，称为<strong>描述符</strong>；</p><pre><code class="lang-c">// 成功则返回新文件描述符，失败返回-1int open(char *filename, int flags, mode_t mode);</code></pre><p>返回的是在进程中当前没有被打开的最小描述符，由于进程开始时都会创建三个文件：</p><ul><li>0：stdin；</li><li>1：stdout；</li><li>2：stderr；<br>所以文件描述符一般从3开始；</li></ul><h4 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h4><p><img src="2.png" alt><img src="3.png" alt></p><h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><pre><code class="lang-c">ssize_t read(int fd, void* buf, size_t n); // 返回成功读取的字节数，失败为-1ssize_t write(int fd, const void* buf, size_t n); // 同上</code></pre><p>注意ssize_t被定义为signed long类型，因为它需要返回-1，而size_t是unsigned long类型；<br><strong>Short count</strong>指的是当执行 I/O 操作（如 read 或 write）时，实际读取或写入的字节数小于请求的字节数，如遇到以下情况：</p><ul><li><strong>遇到文件末尾 (EOF)</strong></li><li><strong>从终端读取文本行</strong></li><li><strong>从网络套接字读取或写入</strong><br>当向磁盘读取或写入时一般不会发生；</li></ul><h1 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h1><h3 id="Fork语句"><a href="#Fork语句" class="headerlink" title="Fork语句"></a>Fork语句</h3><pre><code class="lang-c">Pid_t Fork();</code></pre><p>返回值为进程编号：</p><ul><li>0为子进程；</li><li><blockquote><p>0为父进程；</p></blockquote></li><li>-1为Fork失败；<br><img src="1.png" alt><br>fork会复制fork之后的所有代码创建子进程；其执行过程如下：<img src="4.png" alt><br>注意进程的调度规则不定，哪个先执行完都有可能；</li></ul><h1 id="I-O重定向"><a href="#I-O重定向" class="headerlink" title="I/O重定向"></a>I/O重定向</h1><p>比如，我们希望将当前进程的stdout改为另一个文件，即更改描述符表；通过dup2来实现：</p><pre><code class="lang-c">int dup2(int oldfd, int newfd);</code></pre><p>如果原来fd1指向文件A，调用dup2(4,1)后：<img src="5.png" alt></p><h2 id="一个读的例子"><a href="#一个读的例子" class="headerlink" title="一个读的例子"></a>一个读的例子</h2><p><img src="6.png" alt><br>需要明确子进程和父进程共享同一打开文件表；</p><ul><li><code>s = getpid() &amp; 0x1</code>决定了进程的执行顺序，如果s = 0，则父进程先执行，如果s = 1，则子进程先执行；</li><li>fork前的<code>Read(fd1, &amp;c1, 1)</code>，已经从打开文件中读取一个字符a到c1，打开文件表中的文件位置++；</li><li>执行fork后，父子中先执行的进程执行<code>Read(fd2, &amp;c2, 1)</code>，即c2 = b，同时文件位置++，并输出结果；</li><li>后执行的进程执行<code>Read(fd2, &amp;c2, 1)</code>，即c2 = c，同时文件位置++，并输出结果；<br>结果有2种可能：<br>```<br>Parent: c1 = a, c2 = b<br>Child: c1 = a, c2 = c</li></ul><p>Child: c1 = a, c2 = b<br>Parent: c1 = a, c2 = c<br>```</p><h2 id="一个写的例子"><a href="#一个写的例子" class="headerlink" title="一个写的例子"></a>一个写的例子</h2><p><img src="11.png" alt><br>首先需要明确一些标志的含义：</p><ul><li>O_CREAT：如果文件不存在，创建文件；</li><li>O_TRUNC：如果文件存在，则清空文件内容；</li><li>O_RDWR：文件以读写方式打开；</li><li>O_APPEND：每次写操作都会将数据追加到文件末尾；</li><li>O_WRONLY：仅允许写操作；<br><code>dup(fd1)</code>复制文件描述符 fd1 到 fd2 ，新描述符 fd2 与 fd1 共享相同的文件表项；<br><code>Write(fd1, &quot;pqrs&quot;, 4)</code>将”pqrs”写入文件；<br><code>Write(fd3, &quot;jklmn&quot;, 5)</code>将”jklmn”写入文件末尾；<br><code>Write(fd2, &quot;wxyz&quot;, 4)</code>将”wxyz”写入文件，注意fd1的文件位置为4(写入pqrs后)，所以此时文件的内容为”pqrswxyz”；<br><code>Write(fd3, &quot;ef&quot;, 2)</code>将“ef”仍写入文件末尾；<br>所以最终答案为：”pqrswxyzef”；</li></ul><h1 id="Standard-I-O"><a href="#Standard-I-O" class="headerlink" title="Standard I/O"></a>Standard I/O</h1><p>标准I/O库将一个打开的文件模型化为一个<strong>流</strong>。对于程序员而言，一个流就是一个指<br>向FILE 类型的结构的指针。每个ANSIC程序开始时都有三个打开的流stdin、stdout<br>和stderr，分别对应于标准输人、标准输出和标准错误；<br><img src="7.png" alt></p><h1 id="Unix-I-O-vs-Standard-I-O"><a href="#Unix-I-O-vs-Standard-I-O" class="headerlink" title="Unix I/O vs. Standard I/O"></a>Unix I/O vs. Standard I/O</h1><p><img src="8.png" alt></p><h1 id="系统调用和API"><a href="#系统调用和API" class="headerlink" title="系统调用和API"></a>系统调用和API</h1><ul><li>应用编程接口（API）与系统调用两者在概念上不完全相同，它们都是系统提供给用户程序使用的编程接口，但前者指的是功能更广泛、抽象程度更高的函数，后者仅指通过软中断（自陷）指令向内核态发出特定服务请求的函数。 </li><li>系统调用封装函数是 API 函数中的一种。</li><li>API 函数最终通过调用系统调用实现 I/O。一个API 可能调用多个系统调用，不同 API 可能会调用同一个系统调用。但是，并不是所有 API 都需要调用系统调用。</li><li>API 在用户态执行，系统调用封装函数也在用户态执行，但具体服务例程在内核态执行。</li></ul><h1 id="I-O-类型"><a href="#I-O-类型" class="headerlink" title="I/O 类型"></a>I/O 类型</h1><ul><li><strong>Programmed I/O</strong>：无条件传统方式，查询方式，效率低；<img src="9.png" alt></li><li><strong>Interrupt Driven I/O</strong>：中断驱动 I/O 中，<strong>处理器启动 I/O 操作后无需等待，可以执行其他任务</strong>，直到设备通过中断信号通知处理器数据传输完成；</li><li><strong>DMA</strong>：<strong>由 DMA 模块负责在 I/O 单元和主存之间直接传输数据</strong>，无需处理器干预；</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="10.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP 14-ecf-procs</title>
      <link href="/blog/2025/01/05/CSAPP%2014-ecf-procs/"/>
      <url>/blog/2025/01/05/CSAPP%2014-ecf-procs/</url>
      
        <content type="html"><![CDATA[<p>正常来讲，程序计数器PC会在处理器运行时不断地读取指令序列的地址，两个指令间的过渡被称为<strong>控制转移</strong>，该指令序列被称为<strong>控制流</strong>，其中包含一些平滑的突变（即两条指令之间不相邻，如函数调用）；</p><p>异常是指指令地址在控制流中发生突变所做出的反应；系统通过对突变做出反应，将这种突变称为<strong>异常控制流ECF</strong>；</p><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>当有事件发生时，会通过一个跳转表（被称为异常表，每个异常编号对应一个索引存储的条目的地址），进行一个间接过程的调用（异常），转移控制给异常处理程序，当异常处理程序处理完成后，根据异常的类型，有以下三种结果：</p><ul><li>返回控制给$I_{cur}$；</li><li>返回控制给$I_{next}$；</li><li>终止被中断的程序；<br><img src="1.png" alt><br>异常控制使得控制从用户态转移到内核态，被压入内核栈中；</li></ul><h2 id="2-异常类型"><a href="#2-异常类型" class="headerlink" title="2. 异常类型"></a>2. 异常类型</h2><p>异常包含以下几种类型：</p><ul><li>Interrupts中断（Asynchronous异步的，其余都是Synchronous同步的）；</li><li>Traps陷阱；</li><li>Faults故障；</li><li>Aborts终止；</li></ul><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>由外部事件引起，并非专门的指令造成的，比如Timer interrupt（看门狗中断）、I/O interrupt；</p><h3 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h3><p>故意执行的异常，<strong>在用户程序和内核之间提供一个接口，称为系统调用System Calls</strong>；执行完后返回$I_{next}$继续执行；</p><h3 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h3><p>由错误情况引起，将控制转移给故障处理程序，比如<strong>缺页异常（可修复的）</strong>；执行完后返回$I_{cur}$继续执行或者终止；<br><img src="2.png" alt><br>以上例子中，当执行到该指令时，a[500]存放在磁盘中，需要从磁盘加载到内存中，此时触发故障，故障处理程序缺失的地址送到内存后，返回$I_{cur}$重新执行，此时能正确加载数据；<br><img src="3.png" alt><br>以上例子中，故障处理程序发现该地址是虚拟空间的无效地址，因此报段错误；</p><h3 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h3><h3 id="Linux提供的系统调用"><a href="#Linux提供的系统调用" class="headerlink" title="Linux提供的系统调用"></a>Linux提供的系统调用</h3><p>和异常表不是一个东西！！！<img src="4.png" alt><br>一个打开文件的例子，注意 <strong><code>%rax</code>存放syscall number</strong>，同时存放返回值，如果返回值小于0说明发生错误；<img src="5.png" alt><br>注意系统调用和函数调用的区别：</p><ul><li>系统调用是在内核态中执行的；</li></ul>]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP 13-linking</title>
      <link href="/blog/2025/01/05/CSAPP%2013-linking/"/>
      <url>/blog/2025/01/05/CSAPP%2013-linking/</url>
      
        <content type="html"><![CDATA[<h1 id="链接概述"><a href="#链接概述" class="headerlink" title="链接概述"></a>链接概述</h1><ul><li>源程序的编译<code>gcc -Og -o prog main.c swap.c</code>可以分为以下四个阶段：<ul><li>Pre-Processor预处理(cpp)<ul><li><code>cpp -o main.i main.c</code> or <code>gcc -E -o main.i main.c</code>，<code>-E</code>为限制gcc只做预处理工作</li></ul></li><li>Compiler编译(ccl)<ul><li><code>cc -S -o main.s main.i</code> or <code>gcc -S -o main.s main.i</code>，<code>-S</code>表示只做编译；</li></ul></li><li>Assmebler汇编(as)<ul><li><code>as -o main.o main.s</code>，这步得到的是<strong>可重定位文件</strong>；</li></ul></li><li>Linker链接(ld)<ul><li><code>ld -static -o prog main.o sum.o</code>以及其他库文件，<code>-static</code>表示静态编译<br><img src="1.png" alt></li></ul></li></ul></li><li>链接动作在编译、加载和运行时都可以被执行</li></ul><h2 id="1-静态链接器Linker任务："><a href="#1-静态链接器Linker任务：" class="headerlink" title="1. 静态链接器Linker任务："></a>1. 静态链接器Linker任务：</h2><ol><li>Symbol resolution 符号解析（符号绑定）：<ol><li>将<strong>引用符号和定义符号建立关联</strong>；</li><li>定义的实质是被分配了存储空间，为函数名制定了其代码所在区，为变量名制定了其所占的静态数据去；</li><li>掌握如何区分定义符号和应用符号；</li></ol></li><li>Relocation 重定位：<ol><li>合并相同的节；例如，所有.text节合并作为可执行文件中的.text节；</li><li>对定义符号进行重定位，确定地址；例如，为函数确定首地址，进而确定每条指令的地址，为变量确定首地址；</li><li>对引用符号进行红定位，确定地址；需要用到在.rel_data和.rel_text节中保存的重定位信息；</li></ol></li></ol><h2 id="2-符号解析："><a href="#2-符号解析：" class="headerlink" title="2. 符号解析："></a>2. 符号解析：</h2><ul><li>Global symbol：自定他用，全局可见，跨模块使用，在链接时进行符号解析：</li><li>External symbol：他定自用，和Glbal Symbol相对，链接时在其他模块中查找；</li><li>Local symbol：自定自用，局部符号通常由<code>static</code>修饰，限制其作用域。</li><li>注意区分Local non-static varibles、Local static varibles：<br>```c<br>static int x = 15;</li></ul><p>int f() {<br>    static int x = 17;<br>    return x++;<br>}</p><p>int g() {<br>    static int x = 19;<br>    return x += 14;<br>}</p><p>int h() {<br>    return x += 27;<br>}</p><pre><code>* 注意区分上面每个$x$，函数$f$和$g$中的都是作用域在函数内的**局部静态变量*** 最外面的$x$，即函数$h$引用的是**文件范围内的静态变量**；* 全局符号的符号解析：如果存在多个定义相同名字的全局变量：    * **强符号**：**函数以及初始化的全局变量**；    * **弱符号**：**未初始化的全局变量**；![](./CSAPP%2013-linking/2.png)    * 规则：        * 不许有多个同名的强符号，否则Linker error；        * 如果有一个同名的强符号和多个弱符号，则取强；        * 如果有多个同名的弱符号，随机选择；    * 注意，**链接器不做类型检查**，所以会发生如下问题：![](./CSAPP%2013-linking/3.png)    * 引用double类型的x变量（8bytes）时可能会覆盖y的空间；## 3. 目标文件Object Files* 可重定位目标文件(.o file)* 可执行目标文件(a.out file)：前者经过链接得到的产物，可以直接复制到内存中并执行；* 共享目标文件(.so file)：特殊的可重定位目标文件，可以在程序加载或运行时被动态地加载进内存并链接；## 4. ELF可重定位目标文件（可执行可链接模式）：![](./CSAPP%2013-linking/4.png)* ELF header：16字节的序列，包括字的大小等信息；* .text section：代码段；* .rodata section：只读数据，比如switch的跳转表、printf的格式字符串；* .data：初始化的全局变量和静态C变量；* .bss：未初始化以及初始化为0的全局变量和静态C变量；    * 实际上不占用任何存储空间，仅是一个占位符；    * Better Save Space；    * 运行时自动分配这些变量的初始值为0；    * 有些题目比较恶心，会区分.bss和COMMOM：        * .bss存放未被初始化的静态变量以及初始化为0的全局或静态变量；        * COMMOM存放未被初始化的全局变量；* .symtab：符号表；* .rel.txt，.rel.data，占位符，即引用别的模块中定义的全局变量和函数的指令的占位符，就是下图箭头所指的；![](./CSAPP%2013-linking/6.png)* .debug：调试信息(需要加上`gcc -g`)；* Section header table：每个节的大小信息；## 5.可执行文件的目标文件格式![](./CSAPP%2013-linking/5.png)* 多了一个程序头表：包含第一条指令的地址；* 少了.rel.txt和.rel.data，因为已经链接完了，无需再重定位；## 6. 重定位* 重定位信息：![](./CSAPP%2013-linking/7.png)### R_386_PC32重定位方式![](./CSAPP%2013-linking/8.png)* 根据重定位前的.o文件，能得到哪些信息？    * main在.text节中偏移为0处开始，占0x12bytes；    * `e8 fc ff ff ff`中，`e8`是`call`的机器码，后面应该存放swap函数的地址，但目前未重定位，所以没有意义，是占位符；    * 下一行的`7: R_386_PC32 swap`也是占位符，用于重定位，7表示需要在地址7(6 + 1，call的机器码占一个字节)处进行重定位，R_386_PC32表示需要计算的是PC相对地址；![](./CSAPP%2013-linking/9.png)* 根据以上信息，问题是：![](./CSAPP%2013-linking/10.png)* main函数从`0x8048380`开始，占0x12bytes，swap紧跟main后，所以其起始地址为`0x8048380 + 0x12 = 0x804892B`，由于其机器代码首地址需要按4字节边界对齐，所以应该是`0x8048394`；* **重定位后，call指令的机器代码应该是什么？**    * 由于采用R_386_PC32相对地址法，转移目标地址 = PC + 偏移地址(重定位值)；    * 在执行call时，PC指向call指令的下一条地址，即`0x8048380 + 0x7 = 0x8048387`；    * 但是，**由于一开始有一个占位的初始偏移值`fc ff ff ff`即-4，链接器在进行重定位之前，会先减掉这个临时的偏移量**，所以，正确的PC地址应该是`0x8048387 - (-4) = 0x804838b`；    * 事实上，这个PC地址就是call指令的下一条语句的地址；    * 重定位值 = 转移目标地址 - PC = `0x8048394 - 0x804838b = 0x9`；    * 然后链接器将call指令的机器代码修正为`e8 09 00 00 00`；（小端法）### R_386_32的重定位方式![](./CSAPP%2013-linking/11.png)# 静态库链接Static Libraries* 将所有相关的目标文件模块打包成一个单独的文件，称为静态库；* 使链接器构造可执行文件时，只要复制静态库里被程序引用的目标模块；* 相比于链接整个模块，减少了可执行文件在磁盘和内存中的大小；```Shell# create static librariesunix&gt; ar rs libc.a \ atoi.o printf.o ... random.o</code></pre><p><img src="12.png" alt></p><pre><code class="lang-Shell"># 与静态库链接unix&gt; gcc -static -o prog2r \ main2.o -L. -lvector</code></pre><p><img src="13.png" alt></p><ul><li>自定义创建静态库文件（ar工具）<br>```Shell<br>gcc -c myproc1.c myproc2.c<br>ar rcs mylib.a myproc1.o myproc2.o</li></ul><p>gcc -c main.c<br>gcc -static -o myproc main.o ./mylib.a # 标准的静态库无需显示给出</p><pre><code>* 在进行符号解析到过程中，按从左往右的顺序进行链接，并将符号分为三个集合：    * E：合并以组成可执行文件的所有目标文件集合；    * U：当前所有未解析的引用符号；    * D：当前所有定义的符号的集合，来更新U和E；* 符号解析的完整过程如下：    1. 扫描到main.o并加入E；    2. 把main.o中未解析的引用myfunc加入U，把main加入D；    3. 扫描到静态库文件mylib.a，将U中的符号与mylib.a中所有目标模块依次匹配，将myfunc从U中删除移到D，将myproc1.o加入E；    4. 此时myproc1.o中发现未定义printf符号，将其加入到U；    5. 不断扫描静态库文件，直至U、D不变；    6. 扫描默认的库文件libc.a时，找到printf.o定义，将printf.o加入到E，并将printf从U移动到D，此时U一定是空的，否则就报错了；    7. 由于未引用myproc2.o的内容，它并不在E中，被丢弃；![](./CSAPP%2013-linking/14.png)* 但是静态库链接的顺序扫描会导致一个问题：![](./CSAPP%2013-linking/15.png)* 所以好的做法是**将静态库放在命令行最后**；* **如果静态库之间并不相互独立，静态库需要重复出现**；![](./CSAPP%2013-linking/16.png)* 静态库的缺陷：    * 主存资源浪费；    * 磁盘空间浪费；    * 更新困难，使用不便；# 动态链接的共享库Shared Libraries* 共享库是一个目标文件（Linux：.so文件；Windows：.dll文件）；* 从程序中分离出来，磁盘和内存中都只有一个备份；* 可以**在程序运行或加载时，加载到内存的任意位置，并和一个内存中的程序链接起来，称为动态链接**；![](./CSAPP%2013-linking/17.png)* `ldd prog`可以打印出可执行文件需要的动态链接库；* 自定义创建动态链接库：（`-fpic`是生成位置无关的共享库代码文件）```Shellunix&gt; gcc -Og -c test1.c test2.cunix&gt; gcc -shared -fpic -o test.so \ test1.o test2.ounix&gt; gcc -c main.cunix&gt; gcc -o test main.o ./test.so</code></pre><ul><li><strong>动态链接库在加载时的链接过程</strong>：<img src="18.png" alt></li><li>在静态链接器ld链接的过程中，生成重定位和符号表信息；</li><li>加载可执行程序时，加载器发现在程序表中的 <strong>.interp 段</strong>，其中包含了动态链接器路径名 ld-linux.so，因而加载器根据指定路径加载并启动动态链接器运行；</li><li>完成重定位后，将控制权交给可执行文件，开始执行程序；</li><li><strong>动态链接库在运行时的链接过程</strong>：<br>```c<h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <dlfcn.h></dlfcn.h></h1>/<em> Dynamically load the shared library that contains addvec() </em>/<br>handle = dlopen(“./libvector.so”, RTLD_LAZY);</li></ul><p>/<em> Get a pointer to the addvec() function we just loaded </em>/<br>addvec = dlsym(handle, “addvec”);</p><p>/<em> Now we can call addvec() just like any other function </em>/<br>addvec(x, y, z, 2);</p><p>/<em> Unload the shared library </em>/<br>dlclose(handle);<br>```<br><img src="19.png" alt></p><ul><li>上述过程也被称为<strong>Lazy Binding (延迟绑定)</strong>，它将函数地址的绑定推迟到<strong>函数第一次被调用时</strong>，而不是在程序加载到内存时立即完成所有函数地址的绑定；</li><li>延迟绑定依赖两种关键的数据结构：<strong>GOT（全局偏移表）</strong> 和 <strong>PLT（过程链接表）</strong>；</li><li>GOT：<ul><li>它是一个包含地址的表，存放在程序的数据段中（.data 或 .bss）。</li><li>每个引用的全局对象（包括全局变量和动态链接函数）在 GOT 中占据一个条目（8 字节）。</li><li>每个目标模块（目标文件或共享库）都会有自己的独立 GOT。</li><li>在程序加载时，动态链接器计算全局变量或函数的绝对地址。将每个 GOT 条目更新为对应全局对象的<strong>绝对地址</strong>。</li></ul></li><li>PLT：<ul><li><strong>PLT 是一段可执行代码</strong>，用来间接调用动态链接的函数。</li><li>每个动态链接的函数在 PLT 中都有一个对应的条目，<strong>每个条目大小为 16 字节</strong>。</li><li>在程序中，<strong>所有对动态函数的调用都会先跳转到对应的 PLT 条目，而不是直接调用函数地址</strong>。</li><li>每个动态函数在 GOT 中都有一个对应的条目，初始状态下，该条目指向动态链接器的解析代码。</li><li><strong>当动态链接器解析了目标函数地址后，会更新对应的 GOT 条目为函数的实际地址</strong>。</li><li><strong>第一次调用函数</strong>：<ul><li>PLT 条目先访问 GOT，发现 GOT 中的地址是动态链接器的入口。</li><li>动态链接器解析函数的实际地址，并更新 GOT 条目。</li></ul></li><li><strong>后续调用函数</strong>：<ul><li>PLT 条目直接跳转到 GOT 条目中存储的函数地址，避免重复解析。<br><img src="20.png" alt></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP 09-machine-advanced</title>
      <link href="/blog/2025/01/05/CSAPP%2009-machine-advanced/"/>
      <url>/blog/2025/01/05/CSAPP%2009-machine-advanced/</url>
      
        <content type="html"><![CDATA[<h1 id="程序运行的内存分配策略"><a href="#程序运行的内存分配策略" class="headerlink" title="程序运行的内存分配策略"></a>程序运行的内存分配策略</h1><ol><li>静态存储分配<ol><li>编译时就能确定每个数据目标在运行时刻的存储空间需求,因而在编译时就可以给他们分配固定的内存空间；</li><li>程序代码中<strong>不允许有可变数据结构(比如可变数组)的存在,也不允许有嵌套或者递归的结构出现</strong>,因为会导致编译程序无法计算准确的存储空间需求</li></ol></li><li>栈式存储分配<ol><li>在编译期间，过程、函数以及嵌套程序块的活动记录大小（最大值）应该是可以确定的（以便进入的时候动态地分配活动记录的空间），这是进行栈式存储分配的必要条件，如果不满足则应该使用堆式存储管理</li></ol></li><li>堆式存储分配<ol><li><strong>数据对象的生存期与创建它的过程/函数的执行期无关</strong></li><li>在任意时刻以任意次序从数据段的堆区分配和释放数据对象的运行时存储空间，分配和释放数据对象的操作是应用程序通过向操作系统提出申请来实现<br><img src="1.png" alt></li></ol></li></ol><h1 id="缓冲区溢出攻击"><a href="#缓冲区溢出攻击" class="headerlink" title="缓冲区溢出攻击"></a>缓冲区溢出攻击</h1><ul><li>一个例子<img src="2.png" alt></li><li>应对之道：<ul><li>Stack Randomization，栈随机化，栈底指针浮动；</li><li>设置金丝雀Canary；</li><li>栈区域规定是不可执行的</li></ul></li></ul><h1 id="金丝雀"><a href="#金丝雀" class="headerlink" title="金丝雀"></a>金丝雀</h1><pre><code class="lang-x86asm">40072f:  sub    $0x18,%rsp    # 分配栈空间24bytes400733:  mov    %fs:0x28,%rax   # Get Canary %fs:0x28是一个只读的内存区域40073c:  mov    %rax,0x8(%rsp)  # Place it on stack(Canary 8byetes)400741:  xor    %eax,%eax  # 自己和自己做异或，即擦除Canary400743:  mov    %rsp,%rdi400746:  callq  4006e0 &lt;gets&gt;40074b:  mov    %rsp,%rdi40074e:  callq  400570 &lt;puts@plt&gt;400753:  mov    0x8(%rsp),%rax  # Get it again from stack400758:  xor    %fs:0x28,%rax   # 重新和只读区域上的值做异或400761:  je     400768 &lt;echo+0x39&gt; # ZF = 0，即说明两者相等，没问题400763:  callq  400580 &lt;__stack_chk_fail@plt&gt; # 否则说明stack上的Canary被顶掉，Fail400768:  add    $0x18,%rsp40076c:  retq</code></pre><h1 id="面向返回攻击Return-Oriented-Programming-Attacks"><a href="#面向返回攻击Return-Oriented-Programming-Attacks" class="headerlink" title="面向返回攻击Return-Oriented Programming Attacks"></a>面向返回攻击Return-Oriented Programming Attacks</h1><ul><li>利用已有的代码Gadget，跳转到Gadgets上逐步执行操作；</li><li>还是防不了金丝雀；<br>  <img src="3.png" alt></li></ul>]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP 08-machine-data</title>
      <link href="/blog/2025/01/05/CSAPP%2008-machine-data/"/>
      <url>/blog/2025/01/05/CSAPP%2008-machine-data/</url>
      
        <content type="html"><![CDATA[<h1 id="Array数组"><a href="#Array数组" class="headerlink" title="Array数组"></a>Array数组</h1><ul><li><code>Type A[L]</code>会在内存中分配连续的$L * sizeof(Type)$个字节；</li><li>其中单独的<code>A</code>表示数组指针；$A + i$事实上是$A + i <em> sizeof(Type)$的地址；<img src="1.png" alt><br>```c<br>int get_digit(int </em>a, int x) {<br>  return a[x];<br>}</li></ul><p>// 翻译成汇编代码<br>// %rdi = a, %rsi = x;<br>movl (%rdi, %rsi, 4), %eax; // a + 4 * x;<br>```</p><ul><li>数组可以视为首项的指针，对于两者混用的情况，做出以下区分：</li></ul><div class="table-container"><table><thead><tr><th>Decl</th><th style="text-align:left"></th><th style="text-align:left">A1, A2</th><th style="text-align:left"></th><th></th><th>*A1, *A2</th><th></th></tr></thead><tbody><tr><td></td><td style="text-align:left">Cmp</td><td style="text-align:left">Bad</td><td style="text-align:left">Size</td><td>Comp</td><td>Bad</td><td>Size</td></tr><tr><td>int A1[3]</td><td style="text-align:left">Y</td><td style="text-align:left">N</td><td style="text-align:left">12</td><td>Y</td><td>N</td><td>4</td></tr><tr><td>int *A2</td><td style="text-align:left">Y</td><td style="text-align:left">N</td><td style="text-align:left">8</td><td>Y</td><td>Y</td><td>4</td></tr></tbody></table></div><ul><li>其中<code>int *A2</code>声明了一个指向整形的指针，但它指向的地址显然没有被指定，即指向一个未被分配的内存空间，是一个坏指针；<img src="2.png" alt></li></ul><div class="table-container"><table><thead><tr><th>Decl</th><th></th><th>An</th><th></th><th></th><th>*An</th><th></th><th></th><th>**An</th><th></th></tr></thead><tbody><tr><td></td><td>Cmp</td><td>Bad</td><td>Size</td><td>Cmp</td><td>Bad</td><td>Size</td><td>Cmp</td><td>Bad</td><td>Size</td></tr><tr><td>int A1[3]</td><td>Y</td><td>N</td><td>12</td><td>Y</td><td>N</td><td>4</td><td>N</td><td>-</td><td>-</td></tr><tr><td>int *A2[3]</td><td>Y</td><td>N</td><td>24</td><td>Y</td><td>N</td><td>8</td><td>Y</td><td>Y</td><td>4</td></tr><tr><td>int (*A3)[3]</td><td>Y</td><td>N</td><td>8</td><td>Y</td><td>Y</td><td>12</td><td>Y</td><td>Y</td><td>4</td></tr><tr><td>int (*A4[3])</td><td>Y</td><td>N</td><td>24</td><td>Y</td><td>N</td><td>8</td><td>Y</td><td>Y</td><td>4</td></tr></tbody></table></div><ul><li>其中<code>int *A2[3]</code>相当于<code>int (*A4[3])</code>，其中，<code>()</code>的优先级最高，<code>[]</code>次之，然后是<code>*</code>；</li><li><code>int *A2[3]</code>表示包含3个整形指针的数组；方括号<code>[]</code>的优先级高于<code>*</code>，所以<code>A2[3]</code>表示A2是一个数组；<code>int *</code>表示数组的每个元素是一个指向int类型的指针。</li><li><code>int (*A3)[3]</code>表示指向一个包含3个整形的数组的指针；<code>()</code>的优先级高于<code>[]</code>，所以 <code>(\*A3)</code>表示<code>A3</code>是一个指针。<img src="3.png" alt></li><li>二维数组按行优先存储；<img src="4.png" alt></li><li>要访问<code>A[i][j]</code>，取<code>A + (i * C + j) * 4</code>即可；</li></ul><h1 id="Structure自定义结构体"><a href="#Structure自定义结构体" class="headerlink" title="Structure自定义结构体"></a>Structure自定义结构体</h1><ul><li>结构体也是一段连续的内存区域；<img src="5.png" alt></li><li>结构体的某个类型对象的<strong>地址必须是k = 2, 4, 8的倍数（对齐）</strong>；原因是：<ul><li><strong>内存访问的单位是块</strong>：<ul><li>在现代计算机中，内存通常是以<strong>固定大小的块</strong>（如 4 字节或 8 字节，依赖于系统架构）进行访问的。</li><li>这种对齐方式是硬件设计的结果，因为大多数处理器一次性加载的数据是 4 字节（32 位）或 8 字节（64 位），以提高性能。</li></ul></li><li><strong>缓存行（Cache Line）的作用</strong>：<ul><li>缓存行是 CPU 缓存与内存之间传输数据的最小单位，典型大小为 <strong>64 字节</strong>。</li><li>当 CPU 访问内存时，会将整块缓存行加载到缓存中，以减少后续访问的延迟。</li></ul></li><li><strong>跨缓存行访问的影响</strong>：如果一个数据（如一个结构体或数组元素）跨越了两个缓存行：<ol><li>CPU 需要加载两个缓存行（额外的内存访问）。</li><li>性能下降，因为需要两次读取操作。</li></ol></li><li><strong>对齐的意义</strong>：<ul><li>数据对齐可以避免跨缓存行的情况，确保数据操作只涉及单个缓存行，从而提高访问效率。</li></ul></li><li><strong>虚拟内存的分页（Page）机制</strong>：现代操作系统的虚拟内存将内存划分为 <strong>页（Page）</strong>，每页通常是 4 KB。<ul><li>页是内存管理的最小单位，每一页可能映射到不同的物理内存区域，或者部分未分配。</li><li><strong>跨页访问的复杂性</strong>：如果一个数据块（如数组或结构体）跨越了两个页：<ol><li>操作系统需要处理两次页表查找，性能下降。</li><li>如果某一页未映射（如缺页错误），会导致额外的开销。</li><li>在某些极端情况下（如页权限不同），可能会引发访问冲突或安全问题。</li></ol></li><li><strong>对齐的重要性</strong>：</li><li>避免数据跨页存储可以减少页表查找和缺页错误，简化虚拟内存管理，提高内存操作效率。</li></ul></li></ul></li><li>所以，倾向于将占字节数大的对象放在前面减小空间浪费；</li></ul><h1 id="浮点代码"><a href="#浮点代码" class="headerlink" title="浮点代码"></a>浮点代码</h1><ul><li>不在教学和考试范围内；</li></ul><h1 id="Union共用体"><a href="#Union共用体" class="headerlink" title="Union共用体"></a>Union共用体</h1><ul><li>根据最大的类型对象所占字节数分配内存；</li><li>一次只能使用一个对象；<br><img src="6.png" alt></li></ul><ol><li>Same as (float) u?<ul><li>不相同：<ul><li><code>(float) u</code>的含义：<ul><li>这是一个类型转换，表示将 unsigned 类型的整数 u 转换为 float 类型。</li><li>转换时，u 的数值会从整数解释为浮点数，改变其表示方式。例如，u = 42 会被转换为浮点数 42.0。</li></ul></li><li><code>bit2float</code>的含义：<ul><li>bit2float 并不改变位模式，而是通过 union 将 unsigned 类型的位模式解释为 float 类型。</li><li>如果传入的 u 并不是有效的浮点数位模式，结果可能是未定义的浮点数。</li></ul></li></ul></li></ul></li><li>Same as (unsigned) f？<ul><li>同理，不相同；</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
            <tag> 汇编代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP 07-machine-procedures</title>
      <link href="/blog/2025/01/04/CSAPP%2007-machine-procedures/"/>
      <url>/blog/2025/01/04/CSAPP%2007-machine-procedures/</url>
      
        <content type="html"><![CDATA[<h1 id="进程机制"><a href="#进程机制" class="headerlink" title="进程机制"></a>进程机制</h1><ol><li>Passing control传递控制，记录函数返回地址，跳转到函数开始地址；</li><li>Passing data传递参数；</li><li>Memory management内存管理；</li></ol><h1 id="运行时的栈和栈帧"><a href="#运行时的栈和栈帧" class="headerlink" title="运行时的栈和栈帧"></a>运行时的栈和栈帧</h1><ul><li>习惯性将栈顶画在底部，从下到上地址增大，栈向低地址生长，即向下生长；</li><li><code>pushq Src</code>，会使得<code>%rsp</code>减小；<code>popq Dest</code>，会使得<code>%rsp</code>增加；</li><li>不会改变具体栈上的内容，只会改变指针的位置；</li><li><code>callq label</code>：<ul><li>push return address to stack；</li><li>jump to label；</li><li>即将栈向下生长一格，将函数返回地址放入，<code>%rsp</code>存的是指向该返回地址的指针；然后<code>%rip</code>变为函数的开始地址；</li></ul></li><li><code>ret</code>：<ul><li>pop address from stack；</li><li>jump to address(即将PC<code>%rip</code>设置为该地址)；</li><li>此时过程内的一切东西都会被释放（除了动态申请的内存）；</li></ul></li><li>label是不占位置的；<br><img src="1.png" alt><br><img src="2.png" alt></li><li><strong>Stack Frames栈帧</strong>：即过程活动记录，每次调用函数分配的一段独立的栈帧，<code>ret</code>时释放栈帧；</li><li>一个常见的调用过程的栈内容如下：（向下生长，往下为低地址）</li></ul><div class="table-container"><table><thead><tr><th></th></tr></thead><tbody><tr><td></td></tr><tr><td>Arg n</td></tr><tr><td>$\cdots$</td></tr><tr><td>Arg 7</td></tr><tr><td>Return Addr(Caller’s %rip)以上部分均为Caller的栈帧</td></tr><tr><td>optional Callee’s %rbp</td></tr><tr><td>Saved Registers + Local Varibles</td></tr><tr><td>Arg Build(optional)，如果该函数内部还要调用其他函数，需要传递的参数在这里进行准备；以上部分为Callee的栈帧</td></tr></tbody></table></div><h1 id="数据传送与局部存储"><a href="#数据传送与局部存储" class="headerlink" title="数据传送与局部存储"></a>数据传送与局部存储</h1><ul><li>以下讨论均为整形，浮点数有另一套东西；</li><li>当传递参数超过6个时，x86-64要求<strong>超过寄存器限制的参数按照从右到左的顺序压入栈（后面的参数先进入栈）</strong>：<img src="3.png" alt></li><li>由于寄存器在所有进程之间进行共享，所以规定Callee被调用者不会覆盖Caller调用者会使用到的寄存器的值：<ul><li>Caller Saved调用者保存：<strong>调用者（Caller）负责保存</strong>在函数调用前需要保留的寄存器值，如果调用者需要在函数调用后继续使用某些寄存器中的值，那么它必须在调用函数之前将这些值保存到栈中或其他地方，并在函数返回后再恢复；<ul><li>通过上述操作，Callee可以在调用过程中使用和改变这些寄存器的值；</li><li>典型的有：<code>%r10，%r11，%rax，%rdi，%rsi，%rdx，%rcx，%r8，%r9</code>，即参数基本器和返回寄存器，调用者需要对自己负责，调用子函数时肯定需要确保这些值不能被被调用者改变；</li></ul></li><li>Callee Saved被调用者保存：<strong>被调用者（Callee）负责保存</strong>在函数调用中需要保护的寄存器值，通常通过压栈来进行（就是上面画的Callee的栈帧中Saved Registers的部分）；<ul><li>典型的有：<code>%rbx，%rbp，%r12，%r13，%r14，%r15</code>，<strong>比较特殊的是<code>%rsp</code>，因为调用子函数时，栈指针会往下移至子函数栈帧的栈顶，当子函数结束时，显然需要子函数来恢复栈顶指针指向调用者栈帧的栈顶</strong>；</li></ul></li></ul></li><li>一个Callee Saved的例子<img src="5.png" alt><ul><li>首先，<code>%rdi</code>作用Caller Saved，需要由该函数保存，由于<code>%rbx</code>为Callee Saved，即被调用者保存，其值在该函数运行过程中不会发生改变，所以将<code>%rdi</code>保存在<code>%rbx</code>中，通过寄存器实现了保存；</li><li>上述操作导致了一个问题，<code>%rbx</code>作为Callee Saved，而该函数作为其上一层（主函数）的被调用者，该函数作为被调用者需要保存<code>%rbx</code>，所以，该函数一开头将<code>%rbx</code>压入栈，再最后又弹回给<code>%rbx</code>，通过在栈上存储，实现了保存；</li></ul></li><li>再看一个递归的例子<img src="6.png" alt><ul><li>在该函数中递归调用时，作为主调函数，需要保存<code>%rdi</code>，与上面的例子类似保存在<code>%rbx</code>中；</li><li>由于<code>%rbx</code>是Callee Saved，pcouter_r作为主函数和上一层pcounter_r的被调用者，所以也需要保存<code>%rbx</code>；</li></ul></li></ul><h1 id="一个函数调用的例子"><a href="#一个函数调用的例子" class="headerlink" title="一个函数调用的例子"></a>一个函数调用的例子</h1><p><img src="4.png" alt></p><ol><li>栈操作不是运用传统的push和pop操作，直接移动指针，两者含义是否相同？<ul><li><strong>功能上相同</strong>：两种方式都用于管理栈上的数据；</li><li><strong>实现上不同</strong>：直接调整<code>%rsp</code>更高效，尤其在需要分配大块连续内存时；而 <code>push/pop</code>更适合操作单个寄存器或简单的栈保存和恢复；</li></ul></li><li>为何多申请了一个8字节空间？<ul><li>System V ABI 规范了函数调用时的堆栈布局，以确保各函数之间的参数传递和返回地址的存储符合标准。<strong>堆栈以 16 字节对齐的方式操作</strong>，从而在调用指令（如<code>CALL</code>和<code>RET</code>）时避免对齐问题；</li></ul></li><li>何时申请栈中局部空间，何时不需要申请？<ol><li><strong>需要申请局部空间的情况：</strong><ol><li><strong>局部变量无法存放在寄存器中</strong>：如果局部变量的数量超过了可用的寄存器，或者局部变量较大（如数组、结构体），必须在栈中分配空间。</li><li><strong>指针操作需要实际内存地址</strong>：如代码中的 &amp;v1 需要将变量地址传递给函数，此时必须为变量分配实际的内存空间。</li><li><strong>函数递归或多层嵌套调用</strong>：每次调用会分配独立的栈帧用于保存局部变量和状态。</li></ol></li><li><strong>不需要申请局部空间的情况：</strong><ol><li><strong>变量可以完全存储在寄存器中</strong>：编译器优化时，会尽可能将局部变量映射到寄存器中，避免占用栈空间。</li><li><strong>无需持久化变量状态</strong>：如果局部变量只在寄存器中临时使用且不需要在函数调用间共享，则不需要分配栈空间。</li></ol></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
            <tag> 汇编代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP 06-machine-control</title>
      <link href="/blog/2025/01/04/CSAPP%2006-machine-control/"/>
      <url>/blog/2025/01/04/CSAPP%2006-machine-control/</url>
      
        <content type="html"><![CDATA[<h1 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h1><p><img src="1.png" alt><br><img src="2.png" alt><br><img src="3.png" alt><br><img src="4.png" alt></p><ul><li><strong>注意<code>cmp</code>实际上做减运算，后减前</strong>；</li></ul><h1 id="Loop循环结构"><a href="#Loop循环结构" class="headerlink" title="Loop循环结构"></a>Loop循环结构</h1><ol><li><p>do-while：</p><pre><code class="lang-c">do &#123; body;&#125; while(test);</code></pre><p>等价于</p><pre><code class="lang-c">Loop: body; t = test; if (t) goto Loop;</code></pre></li><li><p>while：</p><pre><code class="lang-c">while (test) &#123; body;&#125;</code></pre><p>如果开启-O2优化，采用Jump-to-middle翻译方法，即判断在后面，先跳到末尾进行判断，再返回中间执行整体；<br>```c<br> goto test;<br>Loop:<br> body;</p></li></ol><p>test:<br>    t = test;<br>    if (t) goto Loop;</p><pre><code>如果开启-O1优化，采用Guarded-do翻译方法，先进行判断，然后转换为do-while循环；```ct = test;if (!t) goto END;Loop:    body;    t = test;    if (t) goto Loop:END;</code></pre><ol><li>for：<pre><code class="lang-c">for (init; test; update) &#123; body;&#125;</code></pre>转化为while循环：<pre><code class="lang-c">init;while (test) &#123; body; update;&#125;</code></pre>写成goto形式：<pre><code class="lang-c">init;t = test;Loop: body; update; if (t) goto Loop;END;</code></pre></li></ol><h1 id="Switch分支结构"><a href="#Switch分支结构" class="headerlink" title="Switch分支结构"></a>Switch分支结构</h1><ul><li>并非if，通过跳转表来实现，每一个分支被视为一个代码块，代码块的开头的地址被存放在跳转表中；<img src="5.png" alt><pre><code class="lang-x86asm">my_switch:  movq %rax, %rcx  cmpq $6, %rdi // x : 6  ja .L8 // if x &gt; 6, goto default;  jmp *.L4(,%rdi, 8) // *(.L4 + x * 8)的地址上的值，即间接跳转，先计算出跳转表上的索引位置，跳转到该索引上的值处；</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
            <tag> 汇编代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP 05-machine-basics</title>
      <link href="/blog/2025/01/04/CSAPP%2005-machine-basics/"/>
      <url>/blog/2025/01/04/CSAPP%2005-machine-basics/</url>
      
        <content type="html"><![CDATA[<h1 id="指令的概念"><a href="#指令的概念" class="headerlink" title="指令的概念"></a>指令的概念</h1><ul><li>微指令是微程序级命令，属于硬件范畴</li><li>伪指令是由若干机器指令组成的指令序列，属于软件范畴</li><li>机器指令介于二者之间，处于硬件和软件的交界面，本章中提及的指令都指机器指令；<ul><li>汇编指令是机器指令的汇编表示形式，即符号表示</li><li>机器指令（二进制串）和汇编指令一一对应，它们都与具体机器结构有关，都属于机器级指令；</li><li>编译Compiling：<code>gcc -Og -S test.c</code>，<code>-Og</code>为优化选项，得到汇编代码<code>test.s</code>；</li></ul></li></ul><h1 id="机器代码的组成"><a href="#机器代码的组成" class="headerlink" title="机器代码的组成"></a>机器代码的组成</h1><ul><li>操作性质（操作码）、源操作数、目的操作数地址（立即数，寄存器编号，存储地址）；<br><img src="1.png" alt></li><li>通常由以下三部分组成：<ul><li>程序计数器PC(Program Counter)：即<code>%rip</code>(x86-64)，指向当前正在执行指令的下一条指令的地址；</li><li>整数寄存器Register file：分别存储了64位的值（地址，整数数据）；</li><li>状态寄存器Condition codes：最近执行的算术或逻辑指令的状态信息；</li></ul></li><li>注意机器代码不区分无符号整数和有符号整数，不区分函数和指针；</li></ul><h1 id="ISA指令集体系结构"><a href="#ISA指令集体系结构" class="headerlink" title="ISA指令集体系结构"></a>ISA指令集体系结构</h1><p><img src="2.png" alt></p><h1 id="信息访问（保护模式下）"><a href="#信息访问（保护模式下）" class="headerlink" title="信息访问（保护模式下）"></a>信息访问（保护模式下）</h1><ol><li>整数寄存器：<img src="3.png" alt><ol><li><code>%rax</code>，函数返回值；</li><li><code>%rdi</code>，函数调用的第一个参数；</li><li><code>%rsi</code>，函数调用的第二个参数；</li><li><code>%rdx</code>，函数调用的第三个参数；</li><li><code>%rcx</code>，函数调用的第四个参数；</li><li><code>%r8</code>，函数调用的第五个参数；</li><li><code>%r9</code>，函数调用的第六个参数（超过6个参数放在栈空间中）；</li><li><code>%rsp</code>，栈顶指针；</li></ol></li><li>操作数指示符号<ol><li>寄存器：直接调用即可；</li><li>立即数：<code>$ + 整数</code>表示；</li><li>内存引用：<code>(%rax)</code></li><li>基址、比例变址、位移操作：<code>D(Rb, Ri, S)</code>，表示获取Rb + S * Ri + D地址上的数，Rb为段基址，Ri为有效地址(不能是%rsp)，S为比例因子(1、2、4、8)，D为偏移量；<img src="4.png" alt>即算的时候是直接拿寄存器做运算得到地址，但最终的结果应该是该地址上的数；</li></ol></li><li>传送指令：<ol><li>mov：<code>movq src, dest</code>；<ol><li>立即数可以移动到寄存器或内存地址(寄存器的内容，即此时立即数存在内存中，寄存器存的是指向该内存的地址)；<ol><li><code>movq $0x4, %rax</code> $\Leftrightarrow$ <code>temp = 0x4</code>；</li><li><code>movq $-147, (%rax)</code>$\Leftrightarrow$ <code>*p = -147</code>；</li></ol></li><li>寄存器可以移动到寄存器或内存地址；</li><li>内存只能移动到寄存器，内存之间不能移动；</li><li><code>movl</code>指令以寄存器为目的是，不但会更新低32位的值，还会将高位4字节都设置为0；</li><li><code>movs</code>符号扩展；<code>movz</code>零扩展；</li></ol></li><li>lea：加载有效地址，<code>leaq (%rdi, %rdi, 2), %rax</code>；<ol><li><strong>注意与<code>mov</code>区别，<code>lea</code>虽然加了括号，但实际上取的是内存的地址，且结果也是内存的地址，而非地址的指向</strong>，所以上面那句指令等价于<code>t = x + x * 2</code>；</li></ol></li></ol></li><li>二元运算指令：<img src="5.png" alt><ul><li>注意<code>sarq</code>为算术右移，<code>shrq</code>为逻辑右移；</li><li><strong>除了乘除，都不区分有符号和无符号</strong>；</li><li><strong>加减影响所有标志</strong>；</li><li><strong>递增递减影响除进位借位CF以外的标志</strong>；</li><li><strong>取负NEG影响标志：对0取负得到0，CF = 0；其余情况CF = 1</strong>；</li><li><strong>比较运算：做减法得到标志，不会改变寄存器的值</strong>；</li></ul></li><li>一元运算指令：<img src="6.png" alt><ul><li>逻辑运算中，<code>not</code>不会影响标志，其余OF = CF = 0，ZF和SF根据结果设置；</li><li><strong><code>test</code>做“与”操作，但不会改变寄存器的值，仅影响标志位</strong>；</li></ul></li></ol><h1 id="GCC的使用举例"><a href="#GCC的使用举例" class="headerlink" title="GCC的使用举例"></a>GCC的使用举例</h1><ol><li><code>gcc -Og -S test.c</code>得到汇编代码<code>test.s</code>；</li><li><code>gcc -O1 test.c -o test</code>得到可执行文件<code>test</code>；</li><li><code>objdump -d test.o &gt; test.txt</code>得到反汇编代码；</li><li>注意可重定位目标文件和可执行目标文件的差异，可重定位目标文件还没有经过链接器链接：<img src="7.png" alt></li></ol>]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
            <tag> 汇编代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP 04-float</title>
      <link href="/blog/2025/01/04/CSAPP%2004-float/"/>
      <url>/blog/2025/01/04/CSAPP%2004-float/</url>
      
        <content type="html"><![CDATA[<h1 id="二进制表示方法"><a href="#二进制表示方法" class="headerlink" title="二进制表示方法"></a>二进制表示方法</h1><ul><li>引入负指数即可；</li><li>缺陷是无法平衡整数部分的范围和小数范围的精度；</li></ul><h1 id="IEEE标准"><a href="#IEEE标准" class="headerlink" title="IEEE标准"></a>IEEE标准</h1><p><img src="2.png" alt><br><img src="1.png" alt></p><ul><li>exp：阶码；</li><li>frac：尾数；</li></ul><ol><li>规格化Normalized：exp不全为0且不全为1；<ol><li>$E = exp - Bias = exp - (2^{k-1} - 1),Bias  = 2^{k - 1} - 1$ ；<ol><li>32bits：$Bias = 2^7 -1 = 127,exp\in [1,254]\rightarrow E\in [-126,127]$；</li><li>64bits：$Bias = 2^{10} - 1 = 1023,exp \in [1, 2023]\rightarrow E\in [-1022,1023]$；</li></ol></li><li>$M = 1.frac_{(2)}$；</li></ol></li><li>非规格化Denormalized：exp全为0；<ol><li>$E = 1 - Bias$；</li><li>$M = frac$；</li></ol></li><li>特殊值Special Values：exp全为1；<ol><li>exp全为1，frac全为0，s = 0表示正无穷$+\infty$，s = 1表示负无穷$-\infty$；</li><li>exp全为1，frac不为0，表示NaN，不是一个数；<br><img src="3.png" alt></li></ol></li></ol><ul><li>分布特点：在0附近均匀分布，到外面扩大（指数分布）；</li><li>舍入规则：4舍6入5向偶；（不在考试范围内）；</li><li>类型转换：<ul><li>$double/float\rightarrow int$<ul><li>直接对实际存储的二进制串进行位截断；</li><li>体现为向0舍入；</li><li>超界的情况转化为$T_{min}$；</li></ul></li><li>$int \rightarrow float$<ul><li>位数相同，不会截断，但可能会发生舍入；</li></ul></li><li>$int/float \rightarrow double$<ul><li>double的有效位数更多，所以能保留精确度；</li></ul></li><li>$double \rightarrow float$<ul><li>能表达的范围变小，可能溢出为$\infty$，并且精度降低，可能发生舍入；</li></ul></li></ul></li></ul><p><img src="4.png" alt><br>解答：</p><ol><li>x如果很大，(float)x会发生舍入；</li><li>double表示范围大于int，所以能精确表示；</li><li>同理2；</li><li>(float)d会发生溢出或舍入；</li><li>没问题，-f或者-d就是符号位取反即可；</li></ol><ul><li>同时，注意浮点数加法运算不满足结合律；</li></ul>]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP 02-Bits-ints-part2</title>
      <link href="/blog/2025/01/04/CSAPP%2002-Bits-ints-part2/"/>
      <url>/blog/2025/01/04/CSAPP%2002-Bits-ints-part2/</url>
      
        <content type="html"><![CDATA[<h1 id="Addition加法"><a href="#Addition加法" class="headerlink" title="Addition加法"></a>Addition加法</h1><ol><li>无符号数加法：$s = UAdd_w(u,v) = (u +v)\% 2^w$；结果寄存器会截断溢出的1位；<ol><li>溢出时，结果一定小于任何一个加数；</li></ol></li><li>有符号数加法：$s = (int)((unsigned)u + (unsigned)v)$；<ol><li>正溢出：$x + y \ge 2^{w-1}$，截断后结果为$x + y - 2^w$；</li><li>负溢出：$x + y &lt; 2^{w-1}$，截断后结果为$x + y + 2^w$；</li><li>正 + 负：不可能溢出；</li></ol></li><li>用加法实现减法：$(A - B)_{\text{补}} = (A)_\text{补} + (-B)_\text{补}$<ol><li>如何求$(-B)_\text{补}$<pre><code> $(B)_\text&#123;补&#125; + (-B)_\text&#123;补&#125; = 11\cdots 1$ $\sim(B)_\text&#123;补&#125; + (B)_\text&#123;补&#125; + 1 = 11\cdots 1 + 1 = 0$ $(-B)_\text&#123;补&#125; = \sim (B)_\text&#123;补&#125; + 1$</code></pre></li></ol></li><li>加法逆元：<ol><li>无符号数：$-x = 2^w - x(x \ne 0)$，0的逆元是0；</li><li>有符号数：$x + (-x) = 0$，注意特例$T_{min},10\cdots 0 + 10\cdots 0 = 0$，即$-T_{min} = T_{min}$；</li></ol></li></ol><h1 id="Adder加法器"><a href="#Adder加法器" class="headerlink" title="Adder加法器"></a>Adder加法器</h1><p><img src="1.png" alt></p><ul><li>当做减法(Sub = 1)或产生进位(Co = 1)时，CF = 1，表示发生借位或进位；</li><li>SF = 运算结果的符号位；</li><li>ZF = 1 if Sum = 0；</li><li>OF = 1 if 两个加数同号但与Sum异号(即上述发生溢出的情形)；<br><img src="2.png" alt><br>以上题为例：<br>```c<br>unsigned int x = 1000 0110;<br>unsigned int y = 1111 0110; // -y_补 = 00001010</li></ul><p>int m = x = 1000 0110 = -122;<br>int n = y = 1111 0110 = -10;</p><h1 id="CF-1-减法有借位-，OF-0-并没有溢出），SF-1；"><a href="#CF-1-减法有借位-，OF-0-并没有溢出），SF-1；" class="headerlink" title="CF = 1(减法有借位)，OF = 0(并没有溢出），SF = 1；"></a>CF = 1(减法有借位)，OF = 0(并没有溢出），SF = 1；</h1><p>unsigned int z1 = x - y = 1000 0110 + 00001010 = 10010000 = 144;<br>int k1 = m - n = 10010000 = -112 = -112 - (-10);</p><h1 id="CF-1-有进位-，OF-1-发生溢出-，SF-0；"><a href="#CF-1-有进位-，OF-1-发生溢出-，SF-0；" class="headerlink" title="CF = 1(有进位)，OF = 1(发生溢出)，SF = 0；"></a>CF = 1(有进位)，OF = 1(发生溢出)，SF = 0；</h1><p>unsigned int z2 = x + y = 1000 0110 + 11110110 = 01111100 = 124 = (134 + 246) % 256;<br>int k2 = m + n = 01111100 = 124 = -122 - 10 + 256;<br>```</p><h1 id="Multiplication"><a href="#Multiplication" class="headerlink" title="Multiplication"></a>Multiplication</h1><ol><li>无符号数乘法：和加法类似进行截断；</li><li>补码乘法：先按无符号数进行乘法运算截断，然后将结果转化为有符号数；</li><li>变量与常数之间的乘运算（左移）：<img src="3.png" alt></li><li>变量与常数之间的除运算（算术右移）：<img src="4.png" alt></li><li>如果负数要向0取整，记得加偏移量；即：$x = (x + 1&lt;<k-1)>&gt;k$；</k-1)></li></ol>]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP 02-Bits-ints-part1</title>
      <link href="/blog/2025/01/04/CSAPP%2002-Bits-ints-part1/"/>
      <url>/blog/2025/01/04/CSAPP%2002-Bits-ints-part1/</url>
      
        <content type="html"><![CDATA[<h1 id="Word-Size-字长"><a href="#Word-Size-字长" class="headerlink" title="Word Size 字长"></a>Word Size 字长</h1><ul><li>32位(bits)机器，字长为4Bytes(32/8)，寻址空间为$2^{32} = 4 * 2^{30} = 4GB$；</li><li>内存中的管理方式如下，32位的机器最小连续字间隔4Byte，64位的机器最小连续字间隔8Byte，字节Byte是最基本存储单元；<img src="1.png" alt></li></ul><h1 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h1><ul><li>int可以跨平台兼容，long和pointer一样：<br><img src="2.png" alt></li></ul><h1 id="数据的存储排列"><a href="#数据的存储排列" class="headerlink" title="数据的存储排列"></a>数据的存储排列</h1><p><img src="8.png" alt><br>解答：0x08000100；</p><h1 id="字的存放问题"><a href="#字的存放问题" class="headerlink" title="字的存放问题"></a>字的存放问题</h1><ul><li>大端法（高对低，最低有效字节在高低址）；</li><li>小端法（低对低，最低有效字节在最前（低地址））</li><li>以<code>int x = 0x01234567, &amp;x = 0x100</code>为例：</li></ul><div class="table-container"><table><thead><tr><th>Address</th><th>0x100</th><th>0x101</th><th>0x102</th><th>0x103</th></tr></thead><tbody><tr><td>Big Endian</td><td>01</td><td>23</td><td>45</td><td>67</td></tr><tr><td>Little Endian</td><td>67</td><td>45</td><td>23</td><td>01</td></tr></tbody></table></div><pre><code class="lang-c">#include &lt;stdio.h&gt;typedef unsigned char *pointer;void show_bytes(pointer start, size_t len)&#123; // 从数据的指针开始打印数据，即从低地址开始打印    size_t i;    for (i = 0; i &lt; len; i++)        printf(&quot;%p\t0x%.2x\n&quot;,start+i, start[i]);    printf(&quot;\n&quot;);&#125;int main(void) &#123;    int a = 15213; // 15213 = 00 00 3b 6d;    printf(&quot;int a = 15213;\n&quot;);    show_bytes((pointer) &amp;a, sizeof(int));    int b = -15213;    printf(&quot;int b = -15213;\n&quot;);    show_bytes((pointer) &amp;b, sizeof(int));    char s[6] = &quot;18213&quot;;    printf(&quot;string s = \&quot;18213\&quot;\n&quot;);    show_bytes((pointer) &amp;s, sizeof(s));    return 0;&#125;</code></pre><ul><li>注意对于字符数组，存储时每个字符按照小端法存储，所以表现出来的结果是整个字符串小端法和大端法没有区别；</li></ul><h1 id="字的边界对齐问题"><a href="#字的边界对齐问题" class="headerlink" title="字的边界对齐问题"></a>字的边界对齐问题</h1><ul><li>按边界对齐：（以32位机器为例，按字节编址，4个字节同时读写）<ul><li>字地址：4的倍数；</li><li>半字地址：2的倍数；</li><li>字节地址：任意；</li></ul></li><li>浪费了一些空间，但减少了访存次数；<br><img src="3.png" alt></li></ul><h1 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h1><h2 id="布尔运算"><a href="#布尔运算" class="headerlink" title="布尔运算"></a>布尔运算</h2><ul><li>按位与，按位取反； </li><li>$\sim 0x41(01000001) \rightarrow 10111110 = 0xBE$；</li><li>$\sim 0x00\rightarrow 0xFF$；</li><li>$0x69 \&amp; 0x55 \rightarrow 01101001 \&amp; 01010101 = 01000001$</li></ul><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><ul><li><code>||, &amp;&amp;, !</code>，注意与布尔运算区别，运算的结果只有0或1（运算结果只要不为0false，就是1true）；</li></ul><h2 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h2><ul><li>只需注意算术右移左边填充符号位即可；</li></ul><h1 id="无符号数和有符号数的位级表示"><a href="#无符号数和有符号数的位级表示" class="headerlink" title="无符号数和有符号数的位级表示"></a>无符号数和有符号数的位级表示</h1><ul><li>运算时，有符号数优先转化为无符号数；</li></ul><div class="table-container"><table><thead><tr><th>关系表达式</th><th>运算类型</th><th>结果</th><th>说明</th></tr></thead><tbody><tr><td>$0 == 0U$</td><td>unsigned</td><td>True</td><td></td></tr><tr><td>$-1 &lt; 0$</td><td>signed</td><td>True</td><td></td></tr><tr><td>$-1 &lt; 0U$</td><td>unsigned</td><td>False</td><td>$-1 = 1\cdots 1_2 = U_{max} &gt; 0$</td></tr><tr><td>$2147483647(2^{31} - 1) &gt; -2147483637 - 1$</td><td>signed</td><td>True</td><td></td></tr><tr><td>$2147483647U &gt; -2147483637 - 1$</td><td>unsigned</td><td>False</td><td>$-2147483637 - 1 = T_{min} \rightarrow 1\cdots 0U = 2^{31} &gt; 2^{31} - 1$</td></tr><tr><td>$2147483647 &gt; (int)2147483648U$</td><td>signed</td><td>True</td><td>$(int)2147483648U = 1\cdots 0 = -2^{31}$</td></tr><tr><td>$-1 &gt; -2$</td><td>signed</td><td>True</td><td></td></tr><tr><td>$(unsigned)-1 &gt; -2$</td><td>unsigned</td><td>True</td><td>$(unsigned)-1 = U_{max}$</td></tr></tbody></table></div><ul><li>数据类型只决定读取方式，不改变存储方式(01串)；</li><li>一些另外的注意点：<img src="4.png" alt><code>sizeof()</code>返回的类型为unsigned int，所以以下代码会导致死循环：<img src="5.png" alt></li></ul><h1 id="位扩展和位截断"><a href="#位扩展和位截断" class="headerlink" title="位扩展和位截断"></a>位扩展和位截断</h1><h2 id="Sign-Extension"><a href="#Sign-Extension" class="headerlink" title="Sign Extension"></a>Sign Extension</h2><ul><li>根据最高位决定补0或者补1；</li></ul><h2 id="Sign-Truncation"><a href="#Sign-Truncation" class="headerlink" title="Sign Truncation"></a>Sign Truncation</h2><ul><li>无符号数截断$B2U_k(x_{k-1}\cdots x_0) = B2U_w(x_{w-1}\cdots x_k x_{k-1}\cdots x_0) \% 2^k$</li><li>有符号数截断$B2T_k(x_{k-1}\cdots x_0) = U2T_w(B2U_w(x_{w-1}\cdots x_k x_{k-1}\cdots x_0)\%2^k)$，即先截断，再重新解释；</li><li>例子：<br><img src="6.png" alt><br>解答：<pre><code class="lang-c">short si = 0x 80 00 = -32768;unsigned short usi = 0x 80 00 = 32768;int i = 0x FF FF 80 00 = -32768;unsigned ui = 0x 00 00 80 00 = 32768;</code></pre><img src="7.png" alt><br>解答：<pre><code class="lang-c">int i = 0x 00 00 80 00 = 32768;short si = (short)i = 0x 80 00 = -32768;int j = si = 0x FF FF 80 00 = -32768;</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP 01-Overview</title>
      <link href="/blog/2025/01/03/CSAPP%2001-Overview/"/>
      <url>/blog/2025/01/03/CSAPP%2001-Overview/</url>
      
        <content type="html"><![CDATA[<h1 id="程序的执行过程"><a href="#程序的执行过程" class="headerlink" title="程序的执行过程"></a>程序的执行过程</h1><p><img src="1.png" alt></p><ul><li>编辑代码：高级程序语言阶段</li><li>Compiler编译器：汇编代码（指令操作用助记符表示）</li><li>Assembler汇编器：将汇编代码转为机器指令（01字符串）</li><li>执行机器代码，调度硬件，运行程序；</li></ul><h1 id="8086CPU"><a href="#8086CPU" class="headerlink" title="8086CPU"></a>8086CPU</h1><p><img src="2.png" alt></p><blockquote><p>通用寄存器组GPRS</p><blockquote><p>数据寄存器：</p><blockquote><p>AX：累加器；<br>BX：基地址(Base)；<br>CX：计数寄存器(Counter)；<br>DX：数据寄存器；<br>地址寄存器：<br>SP：堆栈指针Stack Pointer；<br>BP：基址指针Base Pointer；<br>DI：目标地址Dest；<br>SI：源地址Source；</p></blockquote></blockquote><p>内部寄存器</p><blockquote><p>CS：代码段code；和IP一起得到下一条指令的地址；<br>DS：数据段data；<br>SS：堆栈段；函数调用时的返回地址、局部变量和参数等；<br>ES：附加段：<br>IP：指令指针；总是指向<strong>当前正在执行的指令的下一条指令的偏移地址</strong>；</p></blockquote><p>标志寄存器：</p><blockquote><p>OF：溢出标志Overflow；<br>DF：方向Direction；<br>IF：中断允许；<br>SF：符号（ = 运算结果的最高位）；<br>ZF：零标志（运算结果 = 0时，ZF = 1）；<br>AF：辅助进位；<br>PF：奇偶（低8位满足偶校验，PF = 1）；<br>CF：进位/借位；</p></blockquote></blockquote><ul><li>8086的地址总线为20，总共可寻址空间为$2^{20} = 2MB$；</li></ul><h1 id="一个完整程序的执行过程"><a href="#一个完整程序的执行过程" class="headerlink" title="一个完整程序的执行过程"></a>一个完整程序的执行过程</h1><ol><li>从键盘上读取hello命令，即从键盘到I/O中继器再到CPU；<img src="3.png" alt></li><li>从磁盘(外存)加载可执行文件到主存(内存)，在这之前CPU先向主存发送读取的指令；<img src="4.png" alt></li><li>执行程序，将输出字符串从存储器写到显示器，即CPU先从内存上获取字符串的地址存入寄存器，再控制I/O设备输出到图形化窗口；<img src="5.png" alt></li></ol>]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP算法</title>
      <link href="/blog/2024/12/26/KMP%E7%AE%97%E6%B3%95/"/>
      <url>/blog/2024/12/26/KMP%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="next数组"><a href="#next数组" class="headerlink" title="next数组"></a>next数组</h1><blockquote><p><code>next[j]=k</code>：k是当模式串中第j个字符与主串中相应字符 “失配”时，在模式串中需重新和主串中该字符进行比较的字符的位置。</p></blockquote><script type="math/tex; mode=display">\left.{next[j]=}\left\{\begin{array}{ll}\mathbf{0} & \text{当 j=1 时(代表下一趟比较}\mathrm{i=i+1,j=1})\\\\\mathbf{max\{k\mid1<k<j}\text{且前k - 1个元素和后k-1个元素一致}\}&\text{此集合不为空时,下一趟比较i = i ,j = k}\\\\\mathbf{1}&\text{其它情況(即$j \ne 1且上述集合为空$)}\end{array}\right.\right.</script><blockquote><p><strong>快速填写记法：</strong></p><p>（1）字符串从1开始标号；</p><p>（2）next[1]默认为0；</p><p>（3）next[i] = 前 i -1 位字符串公共前后缀的长度 + 1；</p><p><strong>Notice：</strong></p><p>前缀：除最后一个字符外，一个字符串的全部头部组合；</p><p>后缀：除第一个字符外，一个字符串全部的尾部组合；所以，<code>&quot;aaa&quot;</code>的公共前缀和长度为2。</p></blockquote><pre><code class="lang-c">void GetNext(const char *T, int *next) &#123;    int j = 1, k = 0; // j 表示模式串位置, k 是前缀长度    next[1] = 0;      // 初始化 next 数组    while (j &lt; strlen(T)) &#123;        if (k == 0 || T[j] == T[k]) &#123;            j++;            k++;            next[j] = k; // 更新 next[j]        &#125; else &#123;            k = next[k]; // 回退        &#125;    &#125;&#125;</code></pre><h1 id="nextval数组"><a href="#nextval数组" class="headerlink" title="nextval数组"></a>nextval数组</h1><blockquote><p><strong>引入原因</strong>：next数组中，前后两个相邻的字母如果相同，在匹配过程中遇到需要回退的情况，可以跳过回退到该字母。</p></blockquote><script type="math/tex; mode=display">\begin{array}{l}nextval[i] & = 1\\nextval[i] & = \left\{\begin{array}{ll}nextval[i] = nextval[next[i]] & \text{当$Pattern_i = Pattern_{next[i]}$时}\\\\nextval[i] = next[i] & \text{当$Pattern_i \ne Pattern_{next[i]}$时}\end{array}\right.\end{array}</script><p><img src="KMP.png" alt></p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre><code class="lang-c">#include &lt;stdio.h&gt;#include &lt;string.h&gt;void GetNextVal(const char *T, int *nextval) &#123;    int j = 1, k = 0; // j 表示模式串位置, k 是前缀长度    nextval[1] = 0;   // 初始化 nextval 数组    while (j &lt; strlen(T)) &#123;        if (k == 0 || T[j] == T[k]) &#123;            j++;            k++;            if (T[j] != T[k]) &#123;                nextval[j] = k; // 当 T[j] ≠ T[next[j]] 时，直接赋值            &#125; else &#123;                nextval[j] = nextval[k]; // 当 T[j] == T[next[j]] 时，优化跳跃            &#125;        &#125; else &#123;            k = nextval[k]; // 回退        &#125;    &#125;&#125;int Index_KMP(const char *S, const char *T, int pos) &#123;    int nextval[100]; // 假设模式串长度不超过 100    GetNextVal(T, nextval); // 生成 nextval 数组    int i = pos; // 主串的当前指针    int j = 1;   // 模式串的当前指针    printf(&quot;i\tj\n&quot;);    while (i &lt;= strlen(S) &amp;&amp; j &lt;= strlen(T)) &#123;        printf(&quot;%d\t%d\n&quot;, i, j); // 输出当前的 i 和 j 值        if (j == 0 || S[i - 1] == T[j - 1]) &#123;            i++;            j++;        &#125; else &#123;            j = nextval[j]; // 模式串向右移动        &#125;    &#125;    if (j &gt; strlen(T)) &#123;        return i - strlen(T); // 匹配成功，返回匹配位置    &#125; else &#123;        return 0; // 匹配失败    &#125;&#125;int main() &#123;    const char S[] = &quot;abcaacabcab&quot;; // 主串    const char T[] = &quot;abcab&quot;;       // 模式串    printf(&quot;主串: %s\n&quot;, S);    printf(&quot;模式串: %s\n&quot;, T);    printf(&quot;匹配过程:\n&quot;);    int pos = Index_KMP(S, T, 1); // 从第一个字符开始匹配    if (pos &gt; 0) &#123;        printf(&quot;匹配成功，位置: %d\n&quot;, pos);    &#125; else &#123;        printf(&quot;匹配失败\n&quot;);    &#125;    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构Review</title>
      <link href="/blog/2024/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Review/"/>
      <url>/blog/2024/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Review/</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter1-概论"><a href="#Chapter1-概论" class="headerlink" title="Chapter1 概论"></a>Chapter1 概论</h2><ul><li>数据、数据元素、数据项、数据对象、数据结构等基本概念<img src="概论概念.png" alt><img src="概论概念2.png" alt><img src="概论概念3.png" alt></li><li>逻辑结构，存储结构及数据运算的含义及其相互关系<img src="存储结构.png" alt><img src="相互关系.png" alt></li><li>算法评价标准：正确性、可读性、健壮性、效率与存储量需求、支持分布式和并行处理的算法在大数据场景下更有优势。</li></ul><h2 id="Chapter2-线性表"><a href="#Chapter2-线性表" class="headerlink" title="Chapter2 线性表"></a>Chapter2 线性表</h2><h3 id="2-2链表"><a href="#2-2链表" class="headerlink" title="2.2链表"></a>2.2链表</h3><ul><li>头节点的使用：头节点的指针域指向第一个数据节点的地址<img src="头节点.png" alt></li></ul><h2 id="Chapter3-栈、队列"><a href="#Chapter3-栈、队列" class="headerlink" title="Chapter3 栈、队列"></a>Chapter3 栈、队列</h2><h3 id="3-1-栈"><a href="#3-1-栈" class="headerlink" title="3.1 栈"></a>3.1 栈</h3><h4 id="3-1-1-顺序栈"><a href="#3-1-1-顺序栈" class="headerlink" title="3.1.1 顺序栈"></a>3.1.1 顺序栈</h4><ul><li>非空栈中的栈顶指针<strong>top来指向栈顶元素的下一个位置</strong>；</li><li>空栈时top = base，栈中元素的数量 = top - base；<h4 id="3-1-2-链栈"><a href="#3-1-2-链栈" class="headerlink" title="3.1.2 链栈"></a>3.1.2 链栈</h4></li><li>链表指针方向是从栈顶指向栈底；</li></ul><h4 id="3-1-3-应用"><a href="#3-1-3-应用" class="headerlink" title="3.1.3 应用"></a>3.1.3 应用</h4><ul><li>括弧匹配检验</li><li>中缀表达式：左括号在栈外时优先级最高，在栈内时优先级很 低，仅高于栈外的右括号；</li><li>后缀表达式；<img src="中缀后缀转换.png" alt></li><li>尾递归：递归调用出现在函数中的最后一行，并且没有任何局部变量参与最后一行代码的计算。此时支持“尾递归优化”的编程语言就可以在执行尾递归代码时不进行入栈操作；</li></ul><h3 id="3-2-队列"><a href="#3-2-队列" class="headerlink" title="3.2 队列"></a>3.2 队列</h3><h4 id="3-2-1-顺序队列"><a href="#3-2-1-顺序队列" class="headerlink" title="3.2.1 顺序队列"></a>3.2.1 顺序队列</h4><ul><li>队空是front  = rear = 0；非空队列头指针始终指向队列头元素，而尾指针始终指向<strong>队列尾元素的下一个位置</strong>。</li><li>循环队列：解决“假溢出”；判空采用：front == rear；判满采用：少用一个元素空间，当队尾指针加1就会从后面赶上队头指针，这种情况下队满的条件是：(rear+1) % MAXSIZE  == front；<h4 id="3-2-2-链队"><a href="#3-2-2-链队" class="headerlink" title="3.2.2 链队"></a>3.2.2 链队</h4></li></ul><h2 id="Chapter4-串"><a href="#Chapter4-串" class="headerlink" title="Chapter4 串"></a>Chapter4 串</h2><h3 id="4-1-串的基本操作"><a href="#4-1-串的基本操作" class="headerlink" title="4.1 串的基本操作"></a>4.1 串的基本操作</h3><pre><code class="lang-c">Concat(&amp;T, S1, S2); // 用T返回由S1和S2连接而成的新串两串SubString(&amp;Sub, S, pos, len); // 用Sub返回S字符串第pos个位置开始的长度为len的子串StrCompare(S, T); // 两串比较S &gt; T，返回值 &gt; 0；S = T，返回值 = 0；S &lt; T，返回值 &lt; 0；Index(S, T, pos); // 在S中第pos个位置开始后的部分找到与T相同的子串，返回第一次出现的位置，未找到则返回 0Replace(&amp;S, T, V); // 用V替换S中与T相等的不重叠子串StrInsert(&amp;S, pos, T); // 在S的第pos个位置前插入TStrDelete(&amp;S, pos, len); // 在S中的第pos个位置开始删除长度为len的子串</code></pre><h3 id="4-2-串的模式匹配算法"><a href="#4-2-串的模式匹配算法" class="headerlink" title="4.2 串的模式匹配算法"></a>4.2 串的模式匹配算法</h3><h4 id="4-2-1-简单模式匹配算法Brute-Force"><a href="#4-2-1-简单模式匹配算法Brute-Force" class="headerlink" title="4.2.1 简单模式匹配算法Brute Force"></a>4.2.1 简单模式匹配算法Brute Force</h4><p>逐个遍历字符串的每个字母，并逐个检查从它开始的长为len个的字符是否匹配；</p><pre><code class="lang-c">int Index(SString S, SString T, int pos) &#123;    i = pos;  j = 1;    while (i &lt;= S[0] &amp;&amp; j &lt;= T[0]) &#123;        if (S[i] == T[j]) &#123;             ++i;            ++j;         &#125;        // 继续比较后继字符        else &#123;             i = i-j+2;            j = 1;        &#125;         // 指针后退重新开始匹配    &#125;    if (j &gt; T[0])         return i-T[0];    else return 0;&#125; // Index</code></pre><p>最好情况下平均时间复杂度为$O(m + n)$，最坏情况下为$O(m * n)$。</p><h4 id="4-2-2-KMP算法"><a href="#4-2-2-KMP算法" class="headerlink" title="4.2.2 KMP算法"></a>4.2.2 KMP算法</h4><p>见<a href="https://yokumii.github.io/blog/2024/12/26/KMP%E7%AE%97%E6%B3%95/">KMP算法</a>。</p><h2 id="Chapter5-数组与广义表"><a href="#Chapter5-数组与广义表" class="headerlink" title="Chapter5 数组与广义表"></a>Chapter5 数组与广义表</h2><h3 id="5-1-数组"><a href="#5-1-数组" class="headerlink" title="5.1 数组"></a>5.1 数组</h3><ul><li>数组是线性表的扩展，其数据元素本身也是线性表；</li><li>数组中各元素都具有统一的类型；<h3 id="5-2-矩阵的压缩存储"><a href="#5-2-矩阵的压缩存储" class="headerlink" title="5. 2 矩阵的压缩存储"></a>5. 2 矩阵的压缩存储</h3></li><li>目的是为了节省空间；<h4 id="5-2-1-对称矩阵"><a href="#5-2-1-对称矩阵" class="headerlink" title="5.2.1 对称矩阵"></a>5.2.1 对称矩阵</h4><h4 id="5-2-2-带状矩阵"><a href="#5-2-2-带状矩阵" class="headerlink" title="5.2.2 带状矩阵"></a>5.2.2 带状矩阵</h4><h4 id="5-2-3-随机稀疏矩阵"><a href="#5-2-3-随机稀疏矩阵" class="headerlink" title="5.2.3 随机稀疏矩阵"></a>5.2.3 随机稀疏矩阵</h4>（1）顺序存储方法：三元表法<br>（2）链式存储方法：十字链表法<br>在行、列两个方向上，将非零元素链接在一起。克服三元组表在矩阵的非零元素位置或个数经常变动时的使用不便。<img src="十字链表法.png" alt><h3 id="5-3-广义表"><a href="#5-3-广义表" class="headerlink" title="5.3 广义表"></a>5.3 广义表</h3></li><li>广义表是由零个或多个原子或者子表组成的有限序列；<ul><li>原子：逻辑上不能再分解的元素；</li><li>子表：作为广义表中元素的广义表；</li></ul></li><li>广义表中的元素全部为原子时即为线性表，线性表是广义表的特例，广义表是线性表的推广；</li><li>一般用大写字母表示广义表的名称，用小写字母表示原子；</li><li>表的长度：表中的（第一层）元素个数；</li><li>表的深度：表中元素的最深嵌套层数；</li><li>表头：表中的第一个元素；</li><li>表尾：除第一个元素外，剩余元素<strong>构成的广义表</strong>。 任何一个非空广义表的表尾必定仍为广义表；</li></ul><h2 id="Chapter-6-树和二叉树"><a href="#Chapter-6-树和二叉树" class="headerlink" title="Chapter 6 树和二叉树"></a>Chapter 6 树和二叉树</h2><h3 id="6-1-树"><a href="#6-1-树" class="headerlink" title="6.1 树"></a>6.1 树</h3><h3 id="6-2-二叉树"><a href="#6-2-二叉树" class="headerlink" title="6.2 二叉树"></a>6.2 二叉树</h3><h3 id="6-3-线索二叉树"><a href="#6-3-线索二叉树" class="headerlink" title="6.3 线索二叉树"></a>6.3 线索二叉树</h3><ul><li>如果无左孩子，那利用左孩子指针指向直接前驱节点；如果无右孩子，那利用右孩子指针指向直接后继节点；</li></ul><h3 id="6-4-树和森林"><a href="#6-4-树和森林" class="headerlink" title="6.4 树和森林"></a>6.4 树和森林</h3><ul><li>孩子兄弟链表表示法：左孩子，右兄弟；<h4 id="6-4-1-树转化为二叉树"><a href="#6-4-1-树转化为二叉树" class="headerlink" title="6.4.1 树转化为二叉树"></a>6.4.1 树转化为二叉树</h4></li></ul><ol><li>在所有兄弟结点之间加一条连线；</li><li>对每个结点，除了保留与其长子的连线外，去掉该结点与其他孩子的连线；</li><li>以根为轴心将整棵树顺时针转45度；<br>特点：无右子树、左支是孩子、右支是兄弟；<h4 id="6-4-2-森林转化为二叉树"><a href="#6-4-2-森林转化为二叉树" class="headerlink" title="6.4.2 森林转化为二叉树"></a>6.4.2 森林转化为二叉树</h4></li><li>先将森林的每一个树转化为二叉树；</li><li>从后一棵树开始，将后一棵树作为前一棵树的右子；<h4 id="6-4-3-二叉树转化为树-森林"><a href="#6-4-3-二叉树转化为树-森林" class="headerlink" title="6.4.3 二叉树转化为树/森林"></a>6.4.3 二叉树转化为树/森林</h4></li><li>把双亲节点的左孩子的右孩子、右孩子的右孩子、……和双亲节点连接起来；</li><li>删除所有双亲节点与右孩子的连线；</li></ol><h4 id="6-4-4-树的遍历"><a href="#6-4-4-树的遍历" class="headerlink" title="6.4.4 树的遍历"></a>6.4.4 树的遍历</h4><p><img src="树的遍历.png" alt></p><h4 id="6-4-5-森林的遍历"><a href="#6-4-5-森林的遍历" class="headerlink" title="6.4.5 森林的遍历"></a>6.4.5 森林的遍历</h4><ul><li>先序遍历：逐棵先序遍历每棵子树/对应二叉树的先序遍历；</li><li>中序遍历：逐棵中序遍历每棵子树/对应二叉树的中序遍历；</li><li><h2 id="Chapter7-图"><a href="#Chapter7-图" class="headerlink" title="Chapter7 图"></a>Chapter7 图</h2><h3 id="7-1-一些基本概念："><a href="#7-1-一些基本概念：" class="headerlink" title="7.1 一些基本概念："></a>7.1 一些基本概念：</h3><img src="路.png" alt><br><img src="连通.png" alt><br><img src="强连通.png" alt><br><img src="连通分量.png" alt><br><img src="子图.png" alt></li></ul><h3 id="7-2-图的基本存储结构"><a href="#7-2-图的基本存储结构" class="headerlink" title="7.2 图的基本存储结构"></a>7.2 图的基本存储结构</h3><p><img src="图的存储结构比较.png" alt><br><img src="十字表法.png" alt></p><h3 id="7-3-最小生成树"><a href="#7-3-最小生成树" class="headerlink" title="7.3 最小生成树"></a>7.3 最小生成树</h3><p><img src="最小生成树.png" alt></p><h3 id="7-4-拓扑排序"><a href="#7-4-拓扑排序" class="headerlink" title="7.4 拓扑排序"></a>7.4 拓扑排序</h3><h4 id="7-4-1-无前驱的顶点优先算法"><a href="#7-4-1-无前驱的顶点优先算法" class="headerlink" title="7.4.1 无前驱的顶点优先算法"></a>7.4.1 无前驱的顶点优先算法</h4><p><img src="无前驱的顶点优先算法.png" alt></p><h4 id="7-4-2-无后继的顶点优先"><a href="#7-4-2-无后继的顶点优先" class="headerlink" title="7.4.2 无后继的顶点优先"></a>7.4.2 无后继的顶点优先</h4><p><img src="无后继的顶点优先.png" alt></p><h3 id="7-5-关键路径"><a href="#7-5-关键路径" class="headerlink" title="7.5 关键路径"></a>7.5 关键路径</h3><h4 id="7-5-1-AOE网"><a href="#7-5-1-AOE网" class="headerlink" title="7.5.1 AOE网"></a>7.5.1 AOE网</h4><p><img src="AOE网.png" alt><br><img src="AOE网2.png" alt></p><h4 id="7-5-2-关键术语"><a href="#7-5-2-关键术语" class="headerlink" title="7.5.2 关键术语"></a>7.5.2 关键术语</h4><p><img src="AOE网关键概念.png" alt></p><h4 id="7-5-3-求解方法"><a href="#7-5-3-求解方法" class="headerlink" title="7.5.3 求解方法"></a>7.5.3 求解方法</h4><p>希望求解关键路径，即源点到汇点最长的路径；</p><ol><li>对于事件<ol><li>最早发生时间：源点为0，其他点 = Max(源点到该事件的路径长度)；</li><li>最迟发生时间：（倒着算）汇点 = 最早发生时间，其他点 = Min(下一个点最早发生时间 - 边权)；（为了保证下一个事件能最早发生，所以取最小的那个时间）</li></ol></li><li>对于活动<ol><li>最早发生时间：等于起始点事件的最早发生时间；</li><li>最迟发生时间：等于终点时间的最迟发生时间 - 边权；<br>关键路径为最迟发生时间 - 最早发生时间 = 0的边；</li></ol></li></ol><h2 id="Chapter9-查找"><a href="#Chapter9-查找" class="headerlink" title="Chapter9 查找"></a>Chapter9 查找</h2><h3 id="9-1-顺序查找"><a href="#9-1-顺序查找" class="headerlink" title="9.1 顺序查找"></a>9.1 顺序查找</h3><pre><code class="lang-c">int Search_Seq(SSTable ST, KeyType key) &#123;    ST.elem[0].key = key; // 用作哨兵；    for (int i = ST.length; key != ST.elem[i].key; i--) &#123;        return i; // 找到了就返回正确的位置，没找到返回0；    &#125;&#125;</code></pre><p>监视哨的好处：无需进行边界检测，提高效率；</p><p>平均查找长度ASL：</p><p>（1）成功ASL：$(1 + n)<em> n /2 </em> \frac{1}{n} = \frac{n+1}{2}$；</p><p>（2）失败ASL：$1 + n$；</p><h3 id="9-2-折半查找"><a href="#9-2-折半查找" class="headerlink" title="9.2 折半查找"></a>9.2 折半查找</h3><h4 id="9-2-1-构建步骤"><a href="#9-2-1-构建步骤" class="headerlink" title="9.2.1 构建步骤"></a>9.2.1 构建步骤</h4><p>（1）mid = (1 + n)/2 作为根节点，(1 + mid - 1)/2 作为它的左孩子，(mid + 1 + n)/2 作为右孩子；<br>（2）如此构建折半查找树；</p><h4 id="9-2-2-平均查找长度ASL"><a href="#9-2-2-平均查找长度ASL" class="headerlink" title="9.2.2 平均查找长度ASL"></a>9.2.2 平均查找长度ASL</h4><ol><li>成功ASL：待查找的节点在第$x$层，需要比较的次数就是$x$，加权求和即可；</li></ol><h3 id="9-3-二叉排序树"><a href="#9-3-二叉排序树" class="headerlink" title="9.3 二叉排序树"></a>9.3 二叉排序树</h3><h4 id="9-3-1-构建步骤"><a href="#9-3-1-构建步骤" class="headerlink" title="9.3.1 构建步骤"></a>9.3.1 构建步骤</h4><p>（1）给定序列，第一个节点作为根节点；<br>（2）如果比上一个节点小，则放在它的左子树；比上一个节点大，则放在它的右子树；</p><h4 id="9-3-2-调整（删除节点-p）"><a href="#9-3-2-调整（删除节点-p）" class="headerlink" title="9.3.2 调整（删除节点*p）"></a>9.3.2 调整（删除节点*p）</h4><p>（1）p是叶子结点：修改双亲指针即可；<br>（2）p只有左（右）孩子：用它左（右）孩子的指针代替它即可；<br>（3）p有两个孩子：用它的中序后继（或前驱）代替它；其实就是<strong>左子树中最右或者右子树中最左</strong>的节点代替它。</p><h3 id="9-4-平衡二叉树"><a href="#9-4-平衡二叉树" class="headerlink" title="9.4 平衡二叉树"></a>9.4 平衡二叉树</h3><h4 id="9-4-1-维持平衡操作"><a href="#9-4-1-维持平衡操作" class="headerlink" title="9.4.1 维持平衡操作"></a>9.4.1 维持平衡操作</h4><blockquote><p><strong>最小不平衡子树</strong>：最下往上，第一个出现左右子树深度之差 &gt; 1的节点。</p></blockquote><h5 id="1-LL型"><a href="#1-LL型" class="headerlink" title="1. LL型"></a>1. LL型</h5><blockquote><p>新插入的节点在最小不平衡子树的左孩子的左子树；</p><p>调整方法：左孩子向右上旋转；<img src="LL.png" alt></p></blockquote><h5 id="2-RR型"><a href="#2-RR型" class="headerlink" title="2. RR型"></a>2. RR型</h5><blockquote><p>新插入的节点在最小不平衡子树的右孩子的右子树；</p><p>调整方法：右孩子向左上旋转；（和LL型刚好相反）<img src="RR.png" alt></p></blockquote><h5 id="3-LR型"><a href="#3-LR型" class="headerlink" title="3.LR型"></a>3.LR型</h5><blockquote><p>新插入的节点在最小不平衡子树的左孩子的右子树；</p><p>调整方法：左孩子的右子树先左上旋，再右上旋；<img src="LR.png" alt></p></blockquote><h5 id="4-RL型"><a href="#4-RL型" class="headerlink" title="4. RL型"></a>4. RL型</h5><blockquote><p>新插入的节点在最小不平衡子树的右孩子的左子树；</p><p>调整方法：右孩子的左子树先右上旋，再左上旋；（和LR型刚好相反）<img src="RL.png" alt></p></blockquote><h3 id="9-5-B-树"><a href="#9-5-B-树" class="headerlink" title="9.5 B-树"></a>9.5 B-树</h3><p>B-树是一种多叉平衡搜索树。</p><p>对于$m$叉树，要求：</p><ul><li>每个节点最多有$m$个分支，$m-1$个元素；</li><li>根节点最少有$2$个分支，$1$个元素；</li><li>其他节点最少有$\left \lceil \frac{m}{2} \right \rceil$个分支，$\left \lceil \frac{m}{2} \right \rceil - 1$个节点；</li></ul><h4 id="9-5-1-B-树的构建和插入"><a href="#9-5-1-B-树的构建和插入" class="headerlink" title="9.5.1 B-树的构建和插入"></a>9.5.1 B-树的构建和插入</h4><ol><li>先查找到插入到位置进行插入；</li><li>如果没有上溢出，无需调整；</li><li>如果发生上溢出，将第$\left \lceil \frac{m}{2} \right \rceil$个元素（中间元素）向上移动，两边分裂（直至不发生上溢出）；</li></ol><h4 id="9-5-2-B-树的删除"><a href="#9-5-2-B-树的删除" class="headerlink" title="9.5.2 B-树的删除"></a>9.5.2 B-树的删除</h4><p>B-树的根结点可以始终置于内存中；其余非叶结点放置在外存上，每一结点可作为一个读取单位（页/块）；<br>选取较大的阶次m，降低树的高度，减少外存访问次数；</p><h3 id="9-6-B-树"><a href="#9-6-B-树" class="headerlink" title="9.6 B+树"></a>9.6 B+树</h3><h2 id="Chapter-10-内部排序"><a href="#Chapter-10-内部排序" class="headerlink" title="Chapter 10 内部排序"></a>Chapter 10 内部排序</h2><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt; // 用于 sort 函数#define MAXSIZE 20using namespace std;typedef int KeyType;typedef struct &#123;    KeyType r[MAXSIZE+1];  //r[0]闲置或作哨兵    int length;&#125;SqList;void CinList(SqList &amp;L) &#123;    cin&gt;&gt;L.length;    for (int i = 1; i &lt;= L.length; i++) &#123;        cin&gt;&gt;L.r[i];    &#125;&#125;void CoutList(SqList L) &#123;    for (int i = 1; i &lt;= L.length; i++) &#123;        cout&lt;&lt;L.r[i]&lt;&lt;&quot; &quot;;    &#125;&#125;// 基于比较的内部排序// 直接插入排序void InsertSort(SqList &amp;L) &#123;    for (int i = 2; i &lt;= L.length; i++) &#123; // 循环 n - 1 次        if (L.r[i] &lt; L.r[i - 1]) &#123;            L.r[0] = L.r[i]; // 用作监视哨            L.r[i] = L.r[i - 1]; // 算一次移动            int j;            for (j = i - 2; L.r[0] &lt; L.r[j]; j--) &#123;                L.r[j + 1] = L.r[j]; // 后移一位            &#125;            L.r[j + 1] = L.r[0]; // 算一次移动        &#125;    &#125;    // 稳定排序；    // 排序过程中，数据前一部分逐渐有序，不过可能出现最后一趟之前数据均未在最终位置（最后一个数据为最小值，前 n - 1）个数据均需后移；    // 最好情况：只需比较 n - 1 次（即循环趟数），移动 0 次，时间复杂度为 O(n)；    // 最坏情况：第 i 趟需要比较 i 次（从 i - 1 比较到 0 ），移动 i + 1 次（前 i - 1 个均后移一次，监视哨放置 1 次，监视哨后移 1 次）；        // 比较次数 = (n + 2)(n - 1)/2，移动次数 = (n + 4)(n - 1)/2，时间复杂度为 O(n^2)；    // 平均时间 O(n^2)；    // 优化操作：        // （1）折半插入排序：在找插入位置时采用二分查找，减少了比较次数，移动次数不变；&#125;// 希尔排序void ShellSort(SqList &amp;L) &#123;    // 间隔步长d选点作为一组子表进行插排，不断缩小步长，代码略，不太可能考写代码；    // 不稳定排序；    // 最好情况和最坏情况和直接插排一样；    // 平均时间 O(n^1.3)；&#125;// 冒泡排序void BubbleSort(SqList &amp;L) &#123;    bool isSorted = true;    for (int i = 0; i &lt; L.length - 1 &amp;&amp; isSorted; i++) &#123; // 最多排 n - 1 趟        isSorted = false;        for (int j = 1; j &lt; L.length - i; j++) &#123;            if (L.r[j] &gt; L.r[j + 1]) &#123; // 下沉                L.r[0] = L.r[j];                L.r[j] = L.r[j + 1];                L.r[j + 1] = L.r[0]; // 交换过程，记为3次移动                isSorted = true; // 标志进行交换；            &#125;        &#125;    &#125;    // 稳定排序    // 最好情况：只需比较 n - 1 次，无需移动，时间复杂度为 O(n)；    // 最坏情况：需要 n - 1 趟，第 i 趟需要比较 n - i 次，移动 3 * (n - i) 次；        // 比较次数 = n(n - 1) /2，移动次数 = 3n(n - 1)/2，时间复杂度为 O(n^2)；    // 平均时间 O(n^2)；    // 特点是，在排序过程中，每一趟中最大的元素逐渐下沉至尾部，即最终位置上；&#125;// 快速排序的划分过程int Partition(SqList &amp;L, int low, int high) &#123;    KeyType pivotkey = L.r[low];    L.r[0] = L.r[low]; // 选择low作为支点，同时将low移动到辅助空间，low的位置空出来放下一个找到的元素；    while (low &lt; high) &#123; // low和high相遇时停止        while (low &lt; high &amp;&amp; L.r[high] &gt;= pivotkey) &#123; // 从后往前，找到第一个小于支点的元素，将它放到支点原来的位置；            high--;        &#125;        L.r[low] = L.r[high];        while (low &lt; high &amp;&amp; L.r[low] &lt;= pivotkey) &#123; // 从前往后，找到第一个大于支点的元素，将它放到刚刚空出来的位置；            low++;        &#125;        L.r[high] = L.r[low];    &#125;    L.r[low] = L.r[0]; // 将支点移回去；    return low; // 返回支点位置，用于划分不同序列；&#125;// 快速排序递归的辅助函数void Qsort(SqList &amp;L,int low, int high) &#123;    if (low &lt; high) &#123;        int pivotloc = Partition(L, low, high); // 进行划分，确定支点位置；        Qsort(L, low, pivotloc - 1);        Qsort(L, pivotloc + 1, high); // 对支点左右两部分继续进行划分；    &#125;&#125;// 快速排序void QuickSort(SqList &amp;L) &#123;    Qsort(L, 1, L.length);    // 不稳定排序    // 划分时，比较次数 &lt;= n 次，时间复杂度为O(n)，移动次数为 4 次（支点移到辅助空间，大于支点的节点移动，小于节点的支点移动，支点移回去）；    // 最好情况：划分时划分为左右两个等长子序列，需要排序的趟数 &lt;= log_2(n)，所以时间复杂度为 O(nlogn)；    // 最坏情况：初始完全逆序，每次划分只能将最大的，即支点移动到最后面，得到一个子序列，时间复杂度为 O(n^2)；    // 快速排序通常被认为是同数量级中时间复杂度为 O(nlogn) 中平均性能最好的；    // 采用递归实现的快排，递归层数 = 二叉树深度，即排序的趟数，所以理想空间开销为 O(logn) ，最坏开销为 O(n)；    // 特点是，每一趟排完后，支点的位置就在最终文字；&#125;// 选择排序void SelectSort(SqList &amp;L) &#123;    for (int i = 1; i &lt;= L.length - 1; i++) &#123; // n - 1 趟；        int k = i; // 记录待替换的元素位置；        for (int j = i + 1; j &lt;= L.length; j++) &#123; // 找到 i + 1 位置到结尾处最小的元素放到 i 位置；            if (L.r[j] &lt; L.r[k]) &#123;                k = j;            &#125;        &#125;        if (i != k) &#123;            L.r[0] = L.r[i];            L.r[i] = L.r[k];            L.r[k] = L.r[0];            // 交换元素，记为 3 次移动；        &#125;    &#125;    // 不稳定排序，找到最小的过程中，选择的是下标最大的最小值；    // 排序过程中，前一部分数据逐渐有序，且放置在最终位置上；    // 排序趟数为 n - 1 趟，第 i 趟的比较次数为，n - i，总比较次数为 (1 + n - 1)(n - 1)/2 = n(n - 1)/2；    // 每趟排序交换 1 次，记为 3 次移动，移动次数为 3(n - 1)次；    // 时间复杂度为 O(n^2)；&#125;// 完全二叉堆的概念：    // 小顶堆：每个节点的值都小于等于左右孩子的值；    // 大顶堆：每个节点的值都大于等于左右孩子的值；// 输出堆顶元素后调整堆的操作——筛选：    // （1）将堆底元素移到堆顶，此时堆的性质被破坏，但左右子树仍保持堆的局部性质；    // （2）将此时的堆顶元素与左右孩子中较大的元素交换，如此做，直到满足了堆的性质；// 堆的构建：给定某一序列后，从最后一个非叶子结点的子树开始从下往上调整；    // 对于完全二叉树，最后一个非叶子结点序号为 n/2；// 筛选void HeapAdjust(SqList &amp;L, int root, int end) &#123; // root 是待调整的子树根节点的序号，end 是待调整的子树的最后一个节点    L.r[0] = L.r[root]; // 存储当前堆顶元素    for (int j = 2 * root; j &lt;= end &amp;&amp; j + 1 &lt;= end; j *= 2) &#123;        if (L.r[j] &lt; L.r[j + 1]) &#123;            j++; // j 表示左右孩子中较大的节点；        &#125;        if (L.r[0] &gt;= L.r[j]) &#123;            break; // 父节点大于左右孩子，满足大顶堆的性质；        &#125;        L.r[root] = L.r[j]; // 孩子节点换到根节点        root = j; // 此时根节点指向交换下去的节点    &#125;    L.r[root] = L.r[0];&#125;// 堆排序void HeapSort(SqList &amp;L) &#123;    // 建立堆    for (int i = L.length / 2; i &gt; 0; i--) &#123; // 从最后一个非叶子结点开始，逐步从下往上调整；        HeapAdjust(L, i, L.length);    &#125;    // 每次取出最大的元素（堆顶），和堆底元素交换，重新调整堆；    for (int i = L.length; i &gt; 1; i--) &#123;        L.r[0] = L.r[1];        L.r[1] = L.r[i];        L.r[i] = L.r[0]; // 交换堆顶和堆底，记为 3 次移动；        HeapAdjust(L, 1, i - 1); // 调整剩余部分 1 ～ i - 1；    &#125;    // 不稳定排序    // 对于二叉树，树高 k = 「log_2(n)」+ 1；    // 每次筛选，从根到叶子结点，最多经过 2(k - 1) 次比较（左右孩子比较，较大者与父节点比较，共 2 次），最多经过 k 次交换，即 3 * k 次移动；    // 堆排序需要经过 n - 1 次筛选；    // 时间复杂度为 O(nlogn)；    // 排序过程中，序列后面的数据逐渐有序，并且在最终位置；    // 对记录数较大的文件很有效；&#125;// 2-路归并排序基本思想：    // 含有一个元素的子表总是有序的，所以对相邻的含有一个元素的子表进行合并，得到表长 = 2 的有序表；如此做直至生成表长 = n 的有序表；共需要 「log_2(n)」 趟；// 合并两张子表(left表示第一张表的开头，mid表示第一张表的结尾，mid + 1表示第二张表的开头，right表示第二张表的结尾)void Merge(int Source[], int* Dest, int left, int mid, int right) &#123;    int i = left, j = mid + 1, k = left;    while (i &lt;= mid &amp;&amp; j &lt;= right) &#123;        if (Source[i] &lt; Source[j]) &#123; // 先判断小于条件，保证排序稳定性！！！            Dest[k] = Source[i];            i++;        &#125;        else &#123;            Dest[k] = Source[j];            j++;        &#125;        k++;    &#125;    // 此时一个数组已空，另一个数组非空，将剩余元素放入Dest；    while (i &lt;= mid) &#123;        Dest[k] = Source[i];        k++, i++;    &#125;    while (j &lt;= mid) &#123;        Dest[k] = Source[j];        k++, j++;    &#125;&#125;// 归并排序的递归辅助函数void MSort(int Source[], int* Dest, int start, int end) &#123;    if (start == end) &#123; // 当数组长度为 1 时，该数组已经有序的，不用再分解；        Dest[start] = Source[start]; // 改成 Return 也一样；    &#125;    else &#123;        int mid = (start + end) / 2;        int Temp[MAXSIZE]; // 辅助数组；        MSort(Source, Temp, start, mid); // 将 Source[start:mid] 归并为有序的 Temp[start:mid]；        MSort(Source, Temp, mid + 1, end); // 将 Source[mid + 1:end]归并为有序的 Temp[mid + 1:end]；        Merge(Temp, Dest, start, mid, end); // 将有序子表 Temp[start:mid] 和 Temp[mid + 1:end] 合并为 Dest[start:end]    &#125;&#125;// 归并排序void MergeSort(SqList &amp;L) &#123;    MSort(L.r, L.r, 1, L.length);    // 稳定排序    // 空间复杂度为 O(n)；    // 归并趟数 = 「log_2(n)」，每趟归并需要移动 n 次，时间复杂度为 O(nlogn)；&#125;// 基于比较的内部排序总结：    // 插入排序：直接插入排序、希尔排序（特点是移动次数较多）；    // 交换排序：冒泡排序、快速排序（相邻元素之间作比较，比较次数较多）；    // 选择排序：简单选择排序、堆排序（比较次数较多）；    // 归并排序；    // 稳定排序有：直接插入排序、冒泡排序、归并排序；    // 快速排序是目前基于比较的内部排序中最好的方法；    // 关键字随机分布时，快速排序的平均时间最短，堆排序次之，但后者所需的辅助空间少；    // 当 n 较小时，可采用直接插入或简单选择排序，前者是稳定排序，但后者通常记录移动次数少于前者（插入排序可能会导致 n - 1 个元素都需要移动，而选择排序每次只需要交换 1 次）；    // 当 n 较大时，应采用时间复杂度为 O(nlogn) 的排序方法(主要为快速排序和堆排序)或者基数排序的方法，但基数排序对关键字的结构有一定要求；    // 假设有 n 个值不同的元素存于顺序结构中，要求不经排序选出前 k (k &lt;= n) 个最小元素，问哪些方法可用，哪些方法比较次数最少？这 k 个元素也要有序如何？        // 选择排序或冒泡排序：k 趟（数据比较次数约为 k * n 次）；        // 快速排序：每次仅对第一个子序列划分，直至子序列长度小于等于k；长度不足k，则再对其后的子序列划分出补足的长度即可；        // 堆排序：先建小根堆，k-1 次堆调整（数据比较次数约为 4n + (k-1)logn）；// 基于分配的内部排序// 桶排序void BucketSort(SqList &amp;L) &#123;    // 找到数组中的最大值和最小值    KeyType maxVal = L.r[1], minVal = L.r[1];    for (int i = 2; i &lt;= L.length; i++) &#123;        if (L.r[i] &gt; maxVal) maxVal = L.r[i];        if (L.r[i] &lt; minVal) minVal = L.r[i];    &#125;    // 计算桶的数量和范围    int bucketCount = L.length;    vector&lt;vector&lt;KeyType&gt;&gt; buckets(bucketCount);    // 将元素分配到对应的桶中    double range = (double)(maxVal - minVal + 1) / bucketCount; // 每个桶的范围    for (int i = 1; i &lt;= L.length; i++) &#123;        int index = (L.r[i] - minVal) / range; // 根据范围计算桶索引        if (index &gt;= bucketCount) index = bucketCount - 1;        buckets[index].push_back(L.r[i]);    &#125;    // 对每个桶内部进行排序    for (int i = 0; i &lt; bucketCount; i++) &#123;        sort(buckets[i].begin(), buckets[i].end()); // 使用 STL 的 sort 排序    &#125;    // 将排序后的数据从桶中取出，放回原数组    int idx = 1;    for (int i = 0; i &lt; bucketCount; i++) &#123;        for (KeyType val : buckets[i]) &#123;            L.r[idx++] = val;        &#125;    &#125;    // 稳定排序；    // 空间复杂度为 O(n + k)，其中 n 为元素数量，k 为桶的数量；    // 平均时间复杂度为 O(n + klogk)，最坏情况时间复杂度为 O(n^2)（所有元素都落在同一个桶中）；    // 适合待排序数据值域较大但分布比较均匀；&#125;// 计数排序void CountSort(SqList &amp;L) &#123;    int maxVal = L.r[1], minVal = L.r[L.length];    // 查找最大值和最小值    for (int i = 2; i &lt;= L.length; i++) &#123;        if (L.r[i] &gt; maxVal) &#123;            maxVal = L.r[i];        &#125;        if (L.r[i] &lt; minVal) &#123;            minVal = L.r[i];        &#125;    &#125;    // 计数数组    int* C = new int[maxVal - minVal + 1]();    // 计数    for (int i = 1; i &lt;= L.length; i++) &#123;        C[L.r[i] - minVal]++;    &#125;    int k = 1;    for (int i = minVal; i &lt;= maxVal; i++) &#123;        for (int j = 0; j &lt; C[i - minVal]; j++) &#123;            L.r[k] = i;            k++;        &#125;    &#125;    // 稳定排序（上述实现过程简略，没有体现稳定排序）；    // 当输入的元素是 n 个 0 到 k 之间的整数时，时间复杂度是 O(n+k)，空间复杂度也是 O(n+k)，其排序速度快于任何比较排序算法；    // 当 k 不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。当 k &gt; n 时，效率下降；&#125;// 基数排序void RadixSort(SqList &amp;L) &#123;    // 稳定排序；    // 设记录数为 n ，关键字位数为 d ，基数为 r；    // 每一趟，分配复杂度为 O(n)，收集复杂度为 O(r)；    // 共需要排 d 趟，所以时间复杂度 O(d * (n + r)) = O(n)（r 和 d 均为常数）；    // 辅助空间：n 个记录游标，队头指针数组[0:r - 1]和队尾指针数组[0:r - 1]，空间复杂度为 O(n + r)；&#125;int main() &#123;    SqList L;    // 测试数据 6 0 -4 8 1 -4 -6    // 答案 -6 -4 -4 0 1 8    CinList(L);    // InsertSort(L);    // BubbleSort(L);    // QuickSort(L);    // SelectSort(L);    // HeapSort(L);    // MergeSort(L);    // BucketSort(L);    CountSort(L);    CoutList(L);    return 0;&#125;</code></pre><h2 id="Chapter-11-外部排序"><a href="#Chapter-11-外部排序" class="headerlink" title="Chapter 11 外部排序"></a>Chapter 11 外部排序</h2><h3 id="11-1-置换选择法"><a href="#11-1-置换选择法" class="headerlink" title="11.1 置换选择法"></a>11.1 置换选择法</h3><p>意义是<strong>在内存工作区容量的限制下，获得尽可能长的初始归并段</strong>。<br>假设内存中用到的优先队列WA规模为$5$，初始待排序文件FI：</p><p><code>5, 20, 26, 46, 31, 25, 16, 51, 17, 28, 1</code></p><p>文件放入内存工作区：<br>WA：<code>5,20,26,46,31</code>；</p><p>第一趟：<br>WA：<code>25,20,26,46,31</code>，第一个归并段：<code>5</code>；</p><p>第二趟：<br>WA：<code>25,16,26,46,31</code>，第一个归并段：<code>5,20</code>；</p><p>第三趟：（不能出最小的16，要出一个比20大的）<br>WA：<code>51,16,26,46,31</code>，第一个归并段：<code>5,20,25</code>；</p><p>第四趟：<br>WA：<code>51,16,17,46,31</code>，第一个归并段：<code>5,20,25,26</code>；</p><p>第五趟：<br>WA：<code>51,16,17,46,28</code>，第一个归并段：<code>5,20,25,26,31</code>；</p><p>第六趟：<br>WA：<code>51,16,17,1,28</code>，第一个归并段：<code>5,20,25,26,31,46</code>；</p><p>第七趟：<br>WA：<code>16,17,1,28</code>，第一个归并段：<code>5,20,25,26,31,46,51</code>；</p><p>第八趟～第十一趟：（此时剩余待排序文件无法放入第一个归并段，生成第二个归并段）<br>第二个归并段：<code>1,16,17,28</code>；</p><h3 id="11-2-最佳归并树"><a href="#11-2-最佳归并树" class="headerlink" title="11.2 最佳归并树"></a>11.2 最佳归并树</h3><p>最佳归并树即$k$叉(阶)哈夫曼树。设初始归并段为$m$个，进行$k-$路归并。<br>需要补充$y$个虚段（用元素$0$表示）：$(k - 1) * x + k = m + y$。<br>注意虚段在画哈夫曼树之前先添加。 </p><h3 id="11-3-败者树"><a href="#11-3-败者树" class="headerlink" title="11.3 败者树"></a>11.3 败者树</h3><p>对于初始为升序的归并段进行多路归并，败者树中记录的冠军节点保存的是<strong>最小关键字所在的归并段号</strong>，分支节点保存的是失败者所在的归并段号。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>匹配问题</title>
      <link href="/blog/2024/12/17/%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/"/>
      <url>/blog/2024/12/17/%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="匹配-对集问题"><a href="#匹配-对集问题" class="headerlink" title="匹配/对集问题"></a>匹配/对集问题</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p><img src="匹配定义.png" alt><br>翻译成人话就是，匹配要求边集中任何两条边不相邻，最大匹配要求边数最多，完全匹配要求所有顶点都包含。</p></blockquote><h2 id="霍尔婚姻定理-HALL’S-MARRIAGE-THEOREM"><a href="#霍尔婚姻定理-HALL’S-MARRIAGE-THEOREM" class="headerlink" title="霍尔婚姻定理 HALL’S  MARRIAGE  THEOREM"></a>霍尔婚姻定理 HALL’S  MARRIAGE  THEOREM</h2><blockquote><p><img src="霍尔婚姻定理.png" alt></p></blockquote><h1 id="稳定匹配问题"><a href="#稳定匹配问题" class="headerlink" title="稳定匹配问题"></a>稳定匹配问题</h1><blockquote><p><strong>问题描述</strong>：给出一个$n$个男性的集合$M$和$n$个女性的集合$W$，找到一个“稳定”匹配。</p><blockquote><p>每位男性根据对女性的心仪程度从高至低进行排名；<br>每位女性根据对男性的心仪程度从高至低进行排名；</p></blockquote><p><strong>不稳定对</strong>：给出一个完美匹配$S$，男性$m$和女性$w$是不稳定的，如果同时满足下列条件：</p><blockquote><p>$m$相比起当前配偶，更喜欢$w$；<br>$w$相比起当前配偶，更喜欢$m$；</p></blockquote><p><strong>稳定匹配</strong>：一个不包含不稳定对的完美匹配。</p></blockquote><h3 id="Gale-Shapley-算法（延迟决定法）"><a href="#Gale-Shapley-算法（延迟决定法）" class="headerlink" title="Gale-Shapley 算法（延迟决定法）"></a>Gale-Shapley 算法（延迟决定法）</h3><p><img src="Gale-Shapley算法%20.png" alt></p><pre><code class="lang-cpp">#include&lt;iostream&gt;using namespace std;const int N = 10005;int M[N] = &#123;0&#125;, W[N] = &#123;0&#125;; // 第0个元素表示已经配对的男性/女性个数；男性和女性集合，0表示目前还单身，&gt;0表示已经和该数字对应的异性配对int M_pri[N][N] = &#123;0&#125;, W_pri[N][N] = &#123;0&#125;; // 第0个元素记录的是男生 m 在寻找心仪女生时的进度；男性和女性对异性的心仪程度排名void getPri(int n);void G_S(int num);void output(int num);bool lovemore(int m,int w,int num);// 获取心仪程度输入void getPri(int n) &#123;    for (int i = 1; i &lt;= n; i++) &#123;        for (int j = 1; j &lt;= n; j++) &#123;            cin &gt;&gt; M_pri[i][j]; // 表示第i位男性对女性心仪程度排名，M_pri[i][j]位女生排名第j名；        &#125;    &#125;    for (int i = 1; i &lt;= n; i++) &#123;        for (int j = 1; j &lt;= n; j++) &#123;            cin &gt;&gt; W_pri[i][j]; // 表示第i位女性对男性心仪程度排名，W_pri[i][j]位男生排名第j名；        &#125;    &#125;&#125;// Gale-Shapley 算法void G_S(int num) &#123;    int m, w;    while (M[0] != num) // 男生们还未完成配对    &#123;        w = m = 0;        while (M[++m] != 0) ; // 找到第一个出现的还没有配对的男生m        w = M_pri[m][++M_pri[m][0]]; // 找到第m位男生心中剩下排名第一的女生w        if (W[w])    //如果女生已经在约会了        &#123;            if (lovemore(m,w,num)) // 如果w更爱m            &#123;                M[W[w]] = 0; // w 甩了当前和她配对的                M[m] = w;                W[w] = m;                &#125;            else                 continue;        &#125;        else // 如果女生没有约会还是自由状态，成功配对        &#123;            M[m]=w;            M[0]++;            W[w]=m;            W[0]++;        &#125;    &#125;&#125;// 判断w是不是更爱mbool lovemore(int m,int w,int num) &#123;    for (int i = 0; i &lt; num; i++) &#123; // 按排名从高到低往下找        if (W_pri[w][i] == W[w]) &#123; // 先找到和w配对的那个            return false;        &#125;        if (W_pri[w][i] == m) &#123; // 先找到m，说明更爱m            return true;        &#125;    &#125;&#125;void output(int num) &#123;    for (int i = 1;i &lt;= num; i++)        cout&lt;&lt;&quot;(&quot;&lt;&lt;i&lt;&lt;&quot;, &quot;&lt;&lt;M[i]&lt;&lt;&quot;)&quot;&lt;&lt;endl;&#125;void solve() &#123;    int n;    cin&gt;&gt;n;    getPri(n);    G_S(n);    output(n);&#125;int main() &#123;    solve();    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论题型</title>
      <link href="/blog/2024/12/17/%E5%9B%BE%E8%AE%BA%E9%A2%98%E5%9E%8B/"/>
      <url>/blog/2024/12/17/%E5%9B%BE%E8%AE%BA%E9%A2%98%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="10-1-1-度序列可简单图化"><a href="#10-1-1-度序列可简单图化" class="headerlink" title="10.1.1 度序列可简单图化"></a>10.1.1 度序列可简单图化</h1><blockquote><p><strong>可简单图化的充要条件</strong>：<img src="Havel定理.png" alt></p><p><strong>例题</strong>：<img src="可简单图化例题.png" alt></p><blockquote><p><strong>解法</strong>：每次度序列按非递增顺序排列，删除度最大的节点，更新其他节点的度，重新排列，继续重复上述过程。有2种不合理的情况：<br>（1）某次对剩下序列排序后，最大的度数（设为d1）超过了剩下的顶点数；<br>（2）对最大度数后面的d1个数各减1后，出现了负数。</p></blockquote><p><strong>应用</strong>：<strong>Frogs’ Neighborhood</strong></p><blockquote><p><strong>Description</strong></p><blockquote><p>未名湖附近共$N$个大小湖泊$L_1, L_2, \cdots, L_n$(其中包括未名湖)，每个湖泊$L_i$里住着一只青蛙$F_i(1 \le i \le N)$。如果湖泊$L_i$和$L_j$之间有水路相连，则青蛙$F_i$和$F_j$互称为邻居。现在已知每只青蛙的邻居数目$x_1, x_2, \cdots, x_n$，请你给出每两个湖泊之间的相连关系。</p></blockquote><p><strong>Input</strong></p><blockquote><p>第一行是测试数据的组数$T(0 \le T \le 20)$。每组数据包括两行，第一行是整数$N(2 &lt; N &lt; 10)$，第二行是$N$个整数，$x_1, x_2,\cdots, x_n(0 \le x_i \le N)$。</p></blockquote><p><strong>Output</strong></p><blockquote><p>对输入的每组测试数据，如果不存在可能的相连关系，输出”NO”。否则输出”YES”，并用$N\times N$的矩阵表示湖泊间的相邻关系，即如果湖泊$i$与湖泊$j$之间有水路相连，则第$i$行的第$j$个数字为$1$，否则为$0$。每两个数字之间输出一个空格。如果存在多种可能，只需给出一种符合条件的情形。相邻两组测试数据之间输出一个空行。</p></blockquote><p><strong>Source</strong></p><blockquote><p><a href="http://poj.org/searchproblem?field=source&amp;key=POJ+Monthly--2004.05.15+Alcyone%40pku">POJ Monthly—2004.05.15 Alcyone@pku</a></p></blockquote><p><strong>参考代码</strong></p></blockquote></blockquote><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct node &#123;    int degree, id; // 顶点的度数和标号&#125; v[20];int map[20][20];bool cmp(node a, node b) &#123;    return a.degree &gt; b.degree; // 按度数降序排序&#125;int main() &#123;    int t, n, flag;    scanf(&quot;%d&quot;, &amp;t);  // 输入测试数据组数    while (t--) &#123;        scanf(&quot;%d&quot;, &amp;n);  // 输入当前测试的顶点数量        for (int i = 0; i &lt; n; i++) &#123;            scanf(&quot;%d&quot;, &amp;v[i].degree);  // 输入每个顶点的度数            v[i].id = i;  // 记录顶点编号        &#125;        memset(map, 0, sizeof(map));  // 初始化邻接矩阵        flag = 1;        // 贪心算法：依次处理每个顶点，尝试连接符合要求的邻接顶点        for (int k = 0; k &lt; n; k++) &#123;            sort(v + k, v + n, cmp);  // 对剩余的顶点按度数排序            int i = v[k].id;  // 当前要连的顶点编号            int d1 = v[k].degree;  // 当前节点的度数            if (d1 &gt; n - k - 1) &#123;  // 如果当前节点的度数大于剩余顶点数，无法构图                flag = 0;                break;            &#125;            // 从当前顶点开始，逐步连接其邻居，并减少相应邻居的度数            for (int r = 1; r &lt;= d1 &amp;&amp; flag; r++) &#123;                int j = v[k + r].id;  // 当前要连接的顶点编号                if (v[k + r].degree &lt;= 0) &#123;  // 如果有度数为负的节点，说明构图失败                    flag = 0;                    break;                &#125;                v[k + r].degree--;  // 减少邻居的度数                map[i][j] = map[j][i] = 1;  // 在邻接矩阵中标记连接            &#125;        &#125;        if (flag) &#123;            printf(&quot;YES\n&quot;);            // 输出邻接矩阵            for (int i = 0; i &lt; n; i++) &#123;                for (int j = 0; j &lt; n; j++) &#123;                    if (j) printf(&quot; &quot;);                    printf(&quot;%d&quot;, map[i][j]);                &#125;                printf(&quot;\n&quot;);            &#125;        &#125; else &#123;            printf(&quot;NO\n&quot;);        &#125;        if (t) printf(&quot;\n&quot;);  // 如果不是最后一组数据，输出空行    &#125;    return 0;&#125;</code></pre><h1 id="10-1-2-计算两点之间长度为k的通路数Counting-Paths-by-Adjacency-Matrices"><a href="#10-1-2-计算两点之间长度为k的通路数Counting-Paths-by-Adjacency-Matrices" class="headerlink" title="10.1.2 计算两点之间长度为k的通路数Counting Paths by Adjacency Matrices"></a>10.1.2 计算两点之间长度为k的通路数Counting Paths by Adjacency Matrices</h1><p><img src="计算两点间通路数.png" alt><br>类似求传递闭包。<img src="计算两点间通路数2.png" alt></p><h1 id="10-1-3"><a href="#10-1-3" class="headerlink" title="10.1.3"></a>10.1.3</h1>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平面图</title>
      <link href="/blog/2024/12/10/%E5%B9%B3%E9%9D%A2%E5%9B%BE/"/>
      <url>/blog/2024/12/10/%E5%B9%B3%E9%9D%A2%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h1><ul><li>如果一个图能画在平面上使得它的边仅在端点相交，则称这个图为可嵌人平面的，或称为<strong>平面图</strong>。平面图G的这样一种画法称为G的一个<strong>平面嵌人</strong>。<br><img src="平面图定义.png" alt="平面图定义"></li><li>一个平图$G$把平面划分成若干个连通区域，这些区域的闭包称为$G$的<strong>面</strong>。面边界回路的长度称为<strong>面的次数</strong>，记为$Deg(f)$或$d(f)$。</li><li>每个平图恰有一个无界的面，称为<strong>外部面</strong>。</li></ul><h1 id="二、相关性质和定理"><a href="#二、相关性质和定理" class="headerlink" title="二、相关性质和定理"></a>二、相关性质和定理</h1><h2 id="2-1-面的次数之和与边数关系"><a href="#2-1-面的次数之和与边数关系" class="headerlink" title="2.1 面的次数之和与边数关系"></a>2.1 面的次数之和与边数关系</h2><blockquote><p>$\sum {d(f)} = 2\varepsilon$</p></blockquote><h2 id="2-2-Euler公式"><a href="#2-2-Euler公式" class="headerlink" title="2.2 Euler公式"></a>2.2 Euler公式</h2><blockquote><p>若$G$是连通平图，则有：$\nu - \varepsilon + \phi = 2$</p><p><strong>简单平面图存在一个度数小于5的顶点</strong>；</p><h1 id="三、判断方法"><a href="#三、判断方法" class="headerlink" title="三、判断方法"></a>三、判断方法</h1><h1 id="3-1-必要条件"><a href="#3-1-必要条件" class="headerlink" title="3.1 必要条件"></a>3.1 必要条件</h1><ol><li><p>若$G$是$v \ge 3$的简单平面图，则$\varepsilon \le 3\nu - 6$。</p></li><li><p>Euler公式</p></li></ol></blockquote><h2 id="3-2-Kuratowski’s-Theorem-库拉托夫斯基定理"><a href="#3-2-Kuratowski’s-Theorem-库拉托夫斯基定理" class="headerlink" title="3.2 Kuratowski’s Theorem(库拉托夫斯基定理)"></a>3.2 Kuratowski’s Theorem(库拉托夫斯基定理)</h2><blockquote><p>一个图是平面图当且仅当它不包含$K_{3,3}$或$K_5$的剖分图.</p><blockquote><p><strong>剖分图</strong>：把$G$的边进行一系列剖分得到的图<br><img src="K4剖分图.png" alt="K4剖分图"><br>剖分图也可以这么理解：即用Path代替Edge。<br>把边$(u, v)$删除，添加一个点$w$，再添加两条边$(u,w)$和$(w, v)$，称之为<strong>初等细分</strong>；<br>得到的新图和原图称之为是<strong>同胚(Homeomorphic)的</strong>；</p><p><strong>Platonic Solids(柏拉图体)</strong>:<img src="柏拉图体1.png" alt="柏拉图体1"><br><strong>顶点数、边数(棱数)、面数的关系</strong>：<br>其中，$v$表示顶点数，$e$表示棱数，$f$表示面数，$k$为每个顶点的出发边的数目，$l$为每个面上边的数目，$\sum deg(v) = 2e = fl = kv$.<img src="柏拉图体2.png" alt="柏拉图体2"></p></blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机导论与程序设计复习</title>
      <link href="/blog/2024/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AF%BC%E8%AE%BA%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/"/>
      <url>/blog/2024/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AF%BC%E8%AE%BA%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、程序语言概述"><a href="#一、程序语言概述" class="headerlink" title="一、程序语言概述"></a>一、程序语言概述</h2><ul><li>可编程<img src="可编程.png" alt></li><li><strong>计算机信息处理本质</strong>是: 接收输入的数据、对输入的数据进行加工和处理、产生结果并输出。</li><li>程序可以预先存储在计算机中调度运行。计算机的操作是在程序的控制下进行的。</li><li>可编程结构、图灵机都是计算机模型。</li><li>冯诺依曼机</li><li>程序的运行就是不断地取指令、分析指令、执行指令的过程，这3个步骤均由控制单元来控制。控制单元取指令、分析指令，产生操作控制信号发给输入输出设备、运算部件或者主存，完成指令的执行。</li><li><strong>指令</strong>由“0”和“1”的二进制码组成 ,是指挥计算机工作的命令，是计算机<strong><em>唯一可以直接识别</em></strong>的语言；</li><li><strong>指令系统</strong>：计算机能直接识别和执行的全部指令的集合， 称为该种计算机的指令系统。</li><li><strong>程序</strong>是按事先设计的功能和性能要求编制的指令序列。</li><li><strong>算法</strong>：完成一个任务或者解决一个问题的步骤 序列（操作序列）。</li><li><strong>符号语言</strong>：用符号或助记符来表示不同的机器语言指令(包括操作码和和操作数地址）。符号语言又称汇编语言。</li><li><strong>过程化的程序设计</strong>即是实现某一计算的操作过程和操作步骤，然后用编程语言来描述这些操作过程和步骤。</li><li><strong>程序要素</strong>：数据与运算表达式、输入输出、控制结构、子程序(函数)</li><li><strong>C编程活动</strong>：编辑程序-编译程序-链接程序-运行程序</li></ul><h2 id="二、程序设计初步：数据类型、常量、变量"><a href="#二、程序设计初步：数据类型、常量、变量" class="headerlink" title="二、程序设计初步：数据类型、常量、变量"></a>二、程序设计初步：数据类型、常量、变量</h2><ul><li>最小的存储单元是<strong>位</strong>（bit）</li><li><strong>字</strong> （word）是设计计算机时运算单元给定的整数运算的数据通路的宽度。因此，计算机中每个数据的二进制位数都是固定长度的。</li><li>汉字数字化<img src="汉字数字化.png" alt></li><li>数据类型包括两层含义：定义了值的集合(属于该类型的数据能够<strong>取值的范围</strong>）以及能应用于这些数值上的操作集合（<strong>数据操作</strong>）。</li></ul><h2 id="三、算数运算-逻辑运算"><a href="#三、算数运算-逻辑运算" class="headerlink" title="三、算数运算/逻辑运算"></a>三、算数运算/逻辑运算</h2><ul><li>C语言中默认的算术运算符的结合方向为“自左至右”,即先左后右。但是<strong>赋值运算符是右结合，即从右到左计算</strong>。</li><li><p><strong>命名常量</strong>：不能改写的变量(命名常量)。有些变量一旦定义并初始化,便不允许程序去改变该存储空间中的数据。例如，C语言中：</p><pre><code class="lang-c">const float pi = 3.14;</code></pre></li><li><p>小数转化为整数：</p><ul><li>小数四舍五入取整：(int)(2.5+0.5); (int)(-2.3-0.5);</li><li>小数向上取整：ceil函数返回大于等于参数的最小整数</li><li>小数向下取整：floor函数返回小于等于参数的最大整数</li></ul></li><li>逻辑非运算最高，然后是算术运算和关系运算，其他逻辑运算的优先级仅高于赋值运算。<strong>逻辑运算的结合性默认是左结合，只有非运算是右结合</strong>。<img src="运算符优先级.png" alt></li><li>发生意外或错误，程序无法继续处理时，需要终止，操作系统提供了exit()函数。</li></ul><pre><code class="lang-c">/*功 能: 关闭所有文件，终止正在执行的进程。exit(0)表示正常退出；exit(x)（x不为0）都表示异常退出，这个x是返回给操作系统的，以供其他程序使用；*/void exit(int status); // 参数status，程序退出的返回值</code></pre><ul><li>注意++和—有前缀和后缀的区别：<ul><li>++i，—i(在使用ｉ之前,先使 i 的值加(减)１)</li><li>i++，i—(在使用ｉ之后,使ｉ的值加(减)１) </li></ul></li></ul><h2 id="四、有限自动状态机"><a href="#四、有限自动状态机" class="headerlink" title="四、有限自动状态机"></a>四、有限自动状态机</h2><ul><li>有限状态机可以简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。<ul><li>状态：存储关于过去的信息，它反映从系  统开始到现在时刻的输入变化。</li><li>转移:指示状态变更，并且用必须满足来  确使转移发生的条件来描述它。</li><li>动作:在给定时刻要进行的活动的描述。</li></ul></li></ul><h2 id="五、子程序"><a href="#五、子程序" class="headerlink" title="五、子程序"></a>五、子程序</h2><ul><li>子程序是封装并给以命名的一段程序代码，这段程序代码完成子程序所定义的功能，可供调用。</li><li>封装：子程序可以独立完成功能，调用者只需知道如何调用子程序（即子程序接口）</li><li>引入子程序的目的：</li></ul><ol><li>程序”复用”，避免在程序中使用重复代码；</li><li>结构化程序设计的需要：自顶向下、逐步细化，将复杂问题分解为相对简单的子问题，这些子问题用子程序实现，从而提高主程序结构的清晰性和易读性。</li><li>使程序的调试和 维护变得更加容易。</li></ol><ul><li>子程序设计原则<ul><li>高内聚：功能相对独立和完整；</li><li>低耦合：与外界（调用者）的关系尽量松散，不要太紧密，使其能方便地被重用；</li></ul></li><li>子程序在C语言中的实现机制：C语言中的函数机制</li><li>return语句中返回值表达式的类型要和返回值的类型说明一致。如果不一致，则以<strong>返回值类型</strong>为准(进行类型转换，参数类型的转换有可能是低类型向高类型转换，也可能是高类型向低类型转换。高类型向低类型转换可能会导致不正确的结果（如long类型向short类型的转换）。)。<br><img src="常见函数设计错误.png" alt><br><img src="常见函数设计错误2.png" alt></li><li>函数的调用：函数的调用和执行的实质是<strong>控制转移</strong>，调用函数时，将控制转到被调用的函数，被调函数执行结束时，则将控制转回主调函数，继续执行后续的操作 。</li><li>子程序参数传递两种方式：<strong>按值传递</strong>和<strong>按引用传递</strong>。</li><li>函数原型的作用：是对被调用函数的<strong>接口声明</strong>，它告诉编译器函数返回的数据类型、函数所要接收的参数个数、参数类型和参数顺序，编译器用函数原型校验函数调用是否正确。</li><li>数据在内存中的存储：<ul><li>系统区：用于存放系统软件和运行需要的数据，如操作系统。只要机器一运行，这部分空间就必须保留给系统软件使用</li><li>用户程序代码区：存放用户程序代码</li><li>静态存储区：存放程序运行期间不释放的数据（静态局部变量、全局变量）</li><li>栈区：存放程序运行期间会被释放的数据（函数参数、非静态局部变量）以及活动的控制信息</li><li>堆区：用户可以在程序运行过程中根据需要动态地进行存储空间的分配，这样的分配在堆区进行<br><img src="数据存储.png" alt></li></ul></li></ul><p><img src="函数的活动记录.png" alt></p><h2 id="六、数组"><a href="#六、数组" class="headerlink" title="六、数组"></a>六、数组</h2><ul><li>线性表是具有相同数据类型的$n(n&gt;=0)$个数据元素的有限序列。线性表数据元素之间为线性关系，即任意两个元素之间都可比较大小。</li><li>线性表有两种存储结构：连续（顺序表）、随机（链表）。</li><li>数组初始化是在编译阶段进行的。这样将减少运行时间，提高效率。</li><li>若在定义一个数组的同时赋初值，如果初始化值的个数小于数组元素的个数，剩余的元素被自动初始化为0。(整型数组各元素不会自动初始化为0，至少要把第一个数组元素初始化为0，才能使剩下的元素自动初始化为0。)</li><li>二维数组做形参，第2个下标必须给出，使编译器能确定元素内存地址；多维数组做函数形参时，需要给出除了第1个下标之外的其他所有的下标<img src="二维数组.png" alt></li></ul><h2 id="七、字符串"><a href="#七、字符串" class="headerlink" title="七、字符串"></a>七、字符串</h2><ul><li>scanf函数读取用户键入的字符到字符数组，直到遇到空格、回车、或文件结束符为止。空格、回车、或文件结束符被丢弃，最后一个字符读入后往字符数组中写入结束符‘\0’。</li><li>gets()函数简单易用，它读取整行输入，直至遇到换行符，然后丢弃换行符，存储其余字符，并在这些字符的末尾添加一个空字符使其成为一个C字符串。它经常和puts()函数配对使用，该函数用于显示字符串，并在末尾添加换行符。成功则返回所读字符串指针，失败返回空指针.<pre><code class="lang-c">char * gets(char * str);</code></pre></li><li>将str所指向的字符串输出到文件或显示器上，字符串结束标记‘\0’ 不会被输出。成功则返回字符长度，失败返回-1。puts输出字符串时，会将字符数组中所有内容输出，直到‘\0’，但会在末尾自动追加输出‘\n’ 。<pre><code class="lang-c">int puts(const char * str);</code></pre></li><li>fgets从文件或键盘读取字符到str所指向的数组中，直到<strong>读够n-1个字符</strong>，或读到换行符‘\n’ ，但<strong>不会丢弃换行符</strong>，或者读到文件末尾。最后一个字符读入后自动写入一个 ‘\0’ 。若成功则返回str，若无字符读入数组或者读取失败返回空指针NULL。<pre><code class="lang-c">char * fgets(char *str, int n, FILE *stream);</code></pre></li><li>将str所指向的字符串输出到文件或显示器上，字符串结束标记‘\0’ 不会被输出。<pre><code class="lang-c">int fputs(const char * str, FILE *stream);</code></pre></li></ul><h1 id="八、自定义结构体"><a href="#八、自定义结构体" class="headerlink" title="八、自定义结构体"></a>八、自定义结构体</h1><ul><li>结构是用其他类型的对象构造出来的派生数据类型（注意：结构是一种数据类型）；</li><li>结构既可以在函数外定义，也可以在函数内定义。但函数内定义的结构只能在本函数中使用；</li><li>同一结构中的成员不能同名，不同结构中的成员可以同名；</li><li>嵌套结构：结构中的数据项，可以是另一个已经定义的结构变量；</li><li>如果初始化的个数少于结构中的成员数目，剩余成员被自动化初始为0（整型、浮点型）、‘\0’（字符或者字符串型）、NULL（指针）；<br><img src="指针运算符.png" alt></li><li>传递结构变量方法：传递结构、还是指向结构的指针？<ul><li>传递指针<ul><li>优点：既可以工作在较早的C实现上，也可以工作在较新的C实现上；执行速度快：只需要传递一个地址。</li><li>缺点：缺少对数据的保护（可以使用const限定词解决这个问题）。</li></ul></li><li>传递结构：</li><li>优点：安全性。函数处理的是原始数据的副本。</li><li>缺点： 早期的C实现不处理这种代码，浪费时间和空间；</li></ul></li></ul><h1 id="九、计算机原理"><a href="#九、计算机原理" class="headerlink" title="九、计算机原理"></a>九、计算机原理</h1><ul><li>计算的定义：<ul><li>以数字为基础、遵循一定的计算规则进行; 如：数的加减乘除，函数的微分、积分、方程的求解、定理的证明推导;</li><li>广义：计算就是把一个符号串f变换成另一个符号串g；</li><li>更广义：计算就是对信息的变换 ；</li><li>由于计算规则的机械化、公式化，可以借助计算工具来实现计算。</li></ul></li><li>图灵机：<img src="图灵机.png" alt></li><li>图灵机模型被认为是计算机的基本理论模型：计算机是使用相应的程序来完成任何设定好的任务。图灵机是一种<strong>离散的、有穷的、构造性</strong>的问题求解思路，一个问题的求解可以通过构造其图灵机(即程序)来解决。图灵认为：凡是能用算法方法解决的问题也一定能用图灵机解决; 凡是图灵机解决不了的问题任何算法也解决不了——图灵可计算性问题。</li><li>巴贝奇的分析机由四部分构成：<ul><li>第一部分：保存数据的齿轮式”存贮仓库”(Store)；</li><li>第二部分：对数据进行各种运算的装置(“作坊”)；</li><li>第三部分：对操作顺序进行控制、并对所要处理的数据及输出结果加以选择的装置；</li><li>第四部分：送入和取出数据、以及在”存贮仓库”和”作坊”之间运输数据的输入输出部件。</li><li>分析机工作过程：通过输入部件将要处理的数据输入并存储到”存储仓库”中，在控制装置控制下，从存储仓库依次取出数据运输到运算装置进行运算，最终运算结果由输出部件进行输出。</li></ul></li><li>冯.诺依曼机体系结构的特点：<ul><li>指令和数据采用二进制表示，从而简化机器的逻辑线路；－－指令和数据的表示</li><li>指令和数据一样存储在主存储器中；－－指令和数据的存储</li><li>计算机由运算器、控制器、存储器、输入设备、输出设备五大部分组成。</li></ul></li><li>程序的运行就是不断地<strong>取指令、分析指令、执行指令</strong>的过程，这3个步骤均由控制器来控制。控制器取指令、分析指令，产生操作控制信号发给输入输出设备、运算部件或者主存，完成指令的执行。</li><li>计算机系统由硬件和软件两大部分组成；</li><li>操作系统是最基本、最重要的系统软件，直接运行在<strong>裸机（硬件）</strong> 上，只有在操作系统的支持下，才可以运行其他软件，故操作系统是计算机软件的核心和基础。</li><li>操作系统的基本功能：<strong>作业管理、进程管理、内存管理、设备管理、文件管理</strong>；</li><li>进程是一个<strong>具有一定独立功能的程序关于某个数据集合的一次运行活动</strong>。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。</li><li>程序与进程的关系<ul><li>进程是动态的，强调执行过程，而程序是静态的；</li><li>进程具有并发性(宏观上同时运行)，程序没有；</li><li>不同的进程可以对应同一程序，只是该程序对应的数据集不同。</li></ul></li><li>进程状态转换：<ol><li>运行：当一个进程在处理机上运行时，则称该进程处于运行状态。处于此状态的进程的数目小于等于处理器的数目，对于单处理机系统，处于运行状态的进程只有一个。在没有其他进程可以执行时（如所有进程都在阻塞状态），通常会自动执行系统的空闲进程。 </li><li>就绪：当一个进程获得了除处理机以外的一切所需资源，一旦得到处理机即可运行，则称此进程处于就绪状态。就绪进程可以按多个优先级来划分队列。例如，当一个进程由于时间片用完而进入就绪状态时，排入低优先级队列；当进程由I／O操作完成而进入就绪状态时，排入高优先级队列。 </li><li>阻塞：也称为等待或睡眠状态，一个进程正在等待某一事件发生（例如请求I/O而等待I/O完成等）而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态。</li></ol></li></ul><h1 id="汇总简答题"><a href="#汇总简答题" class="headerlink" title="汇总简答题"></a>汇总简答题</h1><ol><li><strong>什么是计算？</strong><ul><li>以数字为基础、遵循一定的计算规则进行；如：数的加减乘除，函数的微分、积分、方程的求解、定理的证明推导；</li><li>广义：计算就是把一个符号串f变换成另一个符号串g；</li><li>更广义：计算就是对信息的变换；</li></ul></li><li><strong>什么是冯诺依曼结构？</strong><ul><li>冯诺依曼结构是一种计算机设计模型，其核心思想是将数据和程序存储在同一存储器中，并通过控制器统一管理。其组成包括：<ul><li>输入设备</li><li>输出设备</li><li>控制器</li><li>运算器</li><li>存储器</li></ul></li></ul></li><li><strong>什么是内存？什么是外存？两者的区别是什么？</strong><ul><li><strong>内存</strong>：存储程序和数据的高速存储设备，直接与CPU交互，断电后数据丢失。</li><li><strong>外存</strong>：如硬盘、U盘，用于长期存储数据，断电后数据不会丢失。</li><li><strong>区别</strong>：内存速度快但容量小；外存容量大但速度慢。</li></ul></li><li><strong>什么是指令？什么是指令系统？什么是程序？</strong><ul><li><strong>指令</strong>：由“0”和“1”的二进制码组成 ,是指挥计算机工作的命令，是计算机<strong><em>唯一可以直接识别</em></strong>的语言；</li><li><strong>指令系统</strong>：计算机能直接识别和执行的全部指令的集合， 称为该种计算机的指令系统。</li><li><strong>程序</strong>：<strong>程序</strong>是按事先设计的功能和性能要求编制的指令序列。</li></ul></li><li><strong>简述计算机的组成结构与工作原理。</strong><ul><li><strong>组成结构</strong>：包括输入设备、输出设备、存储器、运算器、控制器。</li><li><strong>工作原理</strong>：通过输入设备获取数据，存储器存储数据和程序，控制器按照指令系统控制运算器完成数据处理，结果通过输出设备输出。</li></ul></li><li><strong>计算机系统由哪两大部分组成？</strong><ul><li><strong>硬件系统</strong>：如CPU、内存、硬盘等。</li><li><strong>软件系统</strong>：如操作系统、应用程序等。</li></ul></li><li><strong>什么是操作系统？它具有哪些管理功能？</strong><ul><li><strong>操作系统</strong>：管理计算机硬件与软件资源的系统软件，提供用户与计算机交互的接口。</li><li><strong>管理功能</strong>：<ol><li>进程管理</li><li>内存管理</li><li>文件管理</li><li>设备管理</li><li>作业管理</li></ol></li></ul></li><li><strong>什么是机器语言、符号语言和高级语言？它们各自有什么特点？</strong><ul><li><strong>机器语言</strong>：由0和1组成的二进制代码，可直接被计算机识别；执行效率高但难以编写和理解。</li><li><strong>符号语言</strong>：使用助记符（如MOV、ADD）代替机器码，通过汇编程序翻译成机器语言；较容易理解。</li><li><strong>高级语言</strong>：接近自然语言，易读易写，通过编译或解释器转换成机器语言；跨平台且开发效率高。</li></ul></li><li><strong>计算机唯一可以直接识别的是什么语言？</strong><ul><li>计算机唯一可以直接识别的是<strong>机器语言</strong>。</li></ul></li><li><strong>简述预处理程序和翻译程序各自的功能。</strong><ul><li><strong>预处理程序</strong>：处理源代码中的指令（如宏定义、头文件引入），生成预处理后的代码。</li><li><strong>翻译程序</strong>：将源代码翻译为机器语言，生成目标文件。</li></ul></li><li><strong>链接程序的目的是什么？</strong><ul><li>链接程序的目的在于将多个目标文件和库文件连接成一个可执行文件，同时解决跨文件函数调用和变量引用的问题。</li></ul></li><li><strong>载入程序的功能是什么？</strong><ul><li>载入程序负责将可执行文件从外存加载到内存，并为其分配运行所需的资源，使程序可以被CPU执行。</li></ul></li><li><strong>程序是如何运行的？</strong><ul><li>程序的运行就是不断地<strong>取指令、分析指令、执行指令</strong>的过程，这3个步骤均由控制单元来控制。控制单元取指令、分析指令，产生操作控制信号发给输入输出设备、运算部件或者主存，完成指令的执行。</li></ul></li><li><strong>什么是标识符？</strong><ul><li>标识符是程序中用来标识变量、常量、函数、数组等名称的字符序列。</li></ul></li><li><strong>什么是常量？使用命名常量和符号常量有哪些好处？</strong><ul><li><strong>常量</strong>：程序中值固定不变的量，例如数字3.14或字符’A’。</li><li><strong>好处</strong>：<ol><li>增强代码的可读性，例如PI比3.14更具意义。</li><li>方便修改，只需更改定义处即可在全局生效。</li><li>避免代码中出现“魔法数”（即难以理解的硬编码值）。</li></ol></li></ul></li><li><strong>什么是函数？</strong><ul><li>函数是一个具有特定功能的代码块，用于完成某种任务。它通过调用来执行，可以提高代码的复用性和可读性。</li></ul></li><li><strong>函数声明的作用是什么？</strong><ul><li>函数声明（也称为函数原型）用于向编译器声明函数的名称、返回类型和参数类型，使编译器在函数调用时能进行正确的检查。</li></ul></li><li><strong>函数定义包括哪几部分内容？</strong><ul><li>函数定义通常包括以下部分：<ol><li><strong>返回类型</strong>：函数执行完后返回的值的类型，例如int、float。</li><li><strong>函数名</strong>：用于标识函数的名称，例如add。</li><li><strong>参数列表</strong>：函数接收的输入参数，包含类型和变量名，例如int a, int b。</li><li><strong>函数体</strong>：包含具体实现功能的代码块，用{}括起来。</li></ol></li></ul></li><li><strong>什么是算法?</strong></li><li><strong>结构化程序设计的主要内容是？</strong><ol><li><strong>程序控制结构：</strong><ul><li><strong>顺序结构</strong>：程序按照语句的书写顺序依次执行。</li><li><strong>选择结构</strong>：根据条件判断选择执行某一分支（如if-else、switch-case）。</li><li><strong>循环结构</strong>：重复执行某一代码块，直到满足特定条件（如for、while、do-while）。</li></ul></li><li><strong>模块化设计：</strong><ul><li>将程序划分为若干功能模块，每个模块完成一个独立的功能。</li><li>模块之间通过函数接口进行通信，减少相互依赖。</li></ul></li><li><strong>自顶向下设计：</strong><ul><li>从问题的整体出发，逐步细化，依次设计各子模块，最终实现整个程序。</li></ul></li><li><strong>封装与复用：</strong><ul><li>每个模块应具有独立性，其内部实现细节对外部隐藏，只通过定义好的接口与其他模块交互。</li><li>提高代码复用性，减少重复开发。</li></ul></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欧拉环游和哈密尔顿环游</title>
      <link href="/blog/2024/12/06/%E6%AC%A7%E6%8B%89%E7%8E%AF%E6%B8%B8%E5%92%8C%E5%93%88%E5%AF%86%E5%B0%94%E9%A1%BF%E7%8E%AF%E6%B8%B8/"/>
      <url>/blog/2024/12/06/%E6%AC%A7%E6%8B%89%E7%8E%AF%E6%B8%B8%E5%92%8C%E5%93%88%E5%AF%86%E5%B0%94%E9%A1%BF%E7%8E%AF%E6%B8%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="欧拉环游"><a href="#欧拉环游" class="headerlink" title="欧拉环游"></a>欧拉环游</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p><strong>欧拉回路</strong>：我们称一个通过图的每条边恰好一次的闭途径为欧拉环游 (Eulertour)；<br><strong>欧拉通路</strong>：我们称一个通过图的每条边恰好一次的路为欧拉通路；<br><strong>欧拉图</strong>：如果一个图包含一个欧拉环游，就称它是欧拉的(Eulerian)；</p></blockquote><h2 id="判断的充要条件"><a href="#判断的充要条件" class="headerlink" title="判断的充要条件"></a>判断的充要条件</h2><blockquote><p>对于无向连通图，一个连通图是欧拉的<strong>当且仅当它的每个顶点度是偶数</strong>。<br>连通图$G$是存在从$a$到$b$的欧拉路径，当且仅当$G$是连通的，并且除$a$和$b$($a \ne b$)的度为奇数(odd)之外，没有度为奇数(odd)的顶点；</p><p>对于有向连通图，一个连通图是欧拉的当且仅当$G$是连通的，且每个顶点的出度 = 入度；<br>有向连通图$G$含有欧拉通路，当且仅当$G$是连通的，并且$G$中除两个顶点(节点不相等)外，其余每个顶点的入度=出度，且此两点满足$\left |deg^+{(u)} - deg^-{(v)}\right | = 1$</p></blockquote><h1 id="哈密尔顿通路"><a href="#哈密尔顿通路" class="headerlink" title="哈密尔顿通路"></a>哈密尔顿通路</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><blockquote><p><strong>哈密尔顿回路</strong>：图$G$的哈密顿回路(Hamiltonian circuit)指的是遍历$G$中每一个点且只遍历一次的回路, 这样的轨迹称为哈密顿环游(Hamiltonian tour)；<br><strong>哈密尔顿通路</strong>：1. 图G的哈密顿路径(Hamiltonian path)指的是遍历G中每一个点且只遍历一次的路径, 这样的轨迹称为哈密顿轨迹(Hamiltonian trail)；</p></blockquote><h2 id="一些充分条件"><a href="#一些充分条件" class="headerlink" title="一些充分条件"></a>一些充分条件</h2><h3 id="Dirac’s-theorem狄拉克定理"><a href="#Dirac’s-theorem狄拉克定理" class="headerlink" title="Dirac’s theorem狄拉克定理"></a>Dirac’s theorem狄拉克定理</h3><blockquote><p>对于简单连通图$G$，如果$G$的顶点数$n \ge 3$，且所有顶点的度都$\ge \frac{n}{2}$，那么$G$存在哈密尔顿回路；</p></blockquote><h3 id="Ore’s-theorem欧尔定理"><a href="#Ore’s-theorem欧尔定理" class="headerlink" title="Ore’s theorem欧尔定理"></a>Ore’s theorem欧尔定理</h3><blockquote><p>对于简单连通图$G$，如果$G$的顶点数$n \ge 3$，且对于每一对不相邻的顶点$u, v$，都有$deg(u) + deg(v) \ge n$，那么$G$存在哈密尔顿回路；</p></blockquote><h2 id="必要条件-可以用来判断不是哈密尔顿通路"><a href="#必要条件-可以用来判断不是哈密尔顿通路" class="headerlink" title="必要条件(可以用来判断不是哈密尔顿通路)"></a>必要条件(可以用来判断不是哈密尔顿通路)</h2><blockquote><p>设无向图$G = (V,E)$，非空子集$V_1 \subset V$，则$P(G - V_1)\le \left | V_1 \right |$，其中$p(G - V_1)$为图$G$删除$V_1$中的节点后的连通分支数；</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论基本概念</title>
      <link href="/blog/2024/12/05/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/blog/2024/12/05/%E5%9B%BE%E8%AE%BA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="图论中的基本概念"><a href="#图论中的基本概念" class="headerlink" title="图论中的基本概念"></a>图论中的基本概念</h1><h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><ul><li><strong>图</strong>：具有顶点集$V$的图亦称为$V$上的图(a graph on V)，图$G$的顶点集记为$V(G)$, 边集记为$E(G)$；</li><li><strong>邻接Adjacency</strong>：如果${x,y}$是$G$的一条边，则称两个顶点$x$和$y$是相邻的(adjacent)或邻点 (neighbour)，$x,y$称为边的endpoint；如果两条边$e \ne f$有一个公共端点，则称$e$和$f$是相邻的；</li><li><strong>领域、邻点集Neiborhood</strong>：The set of all neighbors of a vertex $v$ of $G = (V,E)$, denoted by $N(v)$, is called the neighborhood of $v$. 即顶点$v$的所有邻点构成的集合。If $A$ is a subset of $V$ , we denote by $N(A)$ the set of all vertices in G that are adjacent to at least one vertex in $A$. So,$N(A)=\bigcup_{\nu\in A}N(\nu)$.</li><li><strong>度</strong>：A vertex with degree $0$ is called isolated.(孤立点); A vertex of degree $1$ is called pendant.(悬挂点);</li><li><strong>生成子图Spanning subgraph</strong>：删边不删点；</li><li><strong>导出子图Induced subgraph</strong>：若$G’ \subset G$且$G’$包含了$E$中所有满足$x,y \in E$的边$xy$,则称$Q$是$G$的导出子图(induced subgraph)；（人话，删点不删边）；</li><li><strong>图的收缩The contraction of G</strong>：<img src="图的收缩.png" alt></li><li><strong>补图Graph complement</strong>：相对于完全图的补<img src="补图.png" alt></li><li><strong>关联矩阵Incidence matrices</strong>：<img src="关联矩阵.png" alt>即第$i$行表示第$i$个顶点与哪些边连接，第$j$列表示第$j$条边连接哪些顶点。</li></ul><blockquote><p><strong>握手定理Handshaking Theorem</strong>：<img src="握手定理.png" alt><br>无向图中，如果有度为奇数的点，那么这些点的个数必为偶数个。</p></blockquote><ul><li><strong>有向图的度</strong>：The in-degree of $v$, $deg^- (v)$, is the number of edges going to $v$(入度); The out-degree of $v$, $deg^+ (v)$, is the number of edges coming from $v$(出度); The degree of $v$, $deg(v):deg^-(v)+deg^+ (v)$, is the sum of v’s in-degree and out-degree.</li></ul><blockquote><p><strong>有向图握手定理</strong>：<img src="有向图握手定理.png" alt></p></blockquote><ul><li><strong>阶</strong>：一个图的顶点个数称为它的阶(order),记为$\left | G \right |$，它的边数记为$\Vert G \Vert$；</li><li><strong>平凡图</strong>：阶为0或1的图称为平凡的 (trivial)；</li><li><strong>独立</strong>：互不相邻的顶点/边称独立顶点/独立边(independent vertex/edge)。若一个顶点集或边集中没有两个元素是相邻的，则该集合称为<strong>独立集</strong>(independent set)；独立的顶点集也称作<strong>稳定集</strong>(stable set)；</li></ul><h2 id="一些特殊的图结构Special-Graph-Structures"><a href="#一些特殊的图结构Special-Graph-Structures" class="headerlink" title="一些特殊的图结构Special Graph Structures"></a>一些特殊的图结构Special Graph Structures</h2><ul><li><strong>完全图$K^n$</strong>：若$G$的所有顶点都是两两相邻的，则称$G$是完全的(complete)，n个顶点的完全图记为$K^n$；<img src="完全图.png" alt></li><li><strong>环图$C^n$</strong>：<img src="环图.png" alt></li><li><strong>轮图$W^n$</strong>：<img src="轮图.png" alt>$W^n$有$n+1$个顶点，中心点度为$n-1$，边上$n$个点度为$3$。</li><li><strong>n维体图 n-Cubes/hypercubes$Q^n$</strong>：<img src="n维体图.png" alt></li><li><strong>Plato graphs（柏拉图图）</strong>：<img src="柏拉图图.png" alt></li><li><strong>彼德森图（Petersen）</strong>：<img src="彼得森图.png" alt></li><li><strong>Bipartite Graphs二分图</strong>：<img src="二分图.png" alt>判断方法：1. 可以用两种颜色染色； 2. 图中不存在长度为奇数的回路；</li><li><strong>Complete Bipartite Graphs 完全二分图</strong>：<img src="完全二分图.png" alt></li></ul><h2 id="图的同构Graph-Isomorphism"><a href="#图的同构Graph-Isomorphism" class="headerlink" title="图的同构Graph Isomorphism"></a>图的同构Graph Isomorphism</h2><ul><li><strong>图的同构</strong>：<img src="图的同构.png" alt></li><li></li><li><strong>图不变量graph invariants</strong>：对于图上的一个映射，如果对每个同构图它均取相同的值，则这样的映射称为一个图不变量(graph invariant)。一个图的顶点数和边数就是两个简单的图不变量；图中两两相邻的最大顶点数也是图不变量。</li></ul><h2 id="图的连通性Connectivity"><a href="#图的连通性Connectivity" class="headerlink" title="图的连通性Connectivity"></a>图的连通性Connectivity</h2><ul><li><strong>路</strong>：这里所有的$x_i$均互不相同，顶点$x_0和$$x_n$由路$P$连接(link)，并称它们为路的端点(endvertex)或顶端(end)；而$x_1,x_2,\dots,x_{n-1}$称为$P$的内部(inner)顶点。一条路上的边数称为路的长度(length)，长度为k的路记为$P^k$；</li><li><strong>简单路</strong>：A path is simple if it contains no edge more  than once.</li><li><strong>独立路</strong>：如果其中任意一条路不包含另一条路的内部顶点, 则称它们是独立路(independent path)；</li><li><strong>连通图</strong>：如果非空图$G$中的任意两个顶点之间均有一条路相连，我们称$G$是连通的(connected)；</li><li><strong>连通分支/独立子图Connected component</strong>：设$G = (V,E)$是一个图，则它的极大连通子图称为分支(component)；</li><li><strong>割点cut vertex</strong>：the removal from a graph of a vertex and all incident edges produces a subgraph with  more connected components. </li><li><strong>割边cut edge</strong>：an edge whose removal produces a graph with more connected components；</li><li><strong>点连通度</strong>：使得G是k-连通的最大整数k称为G的连通度(connectivity)，并记为$\kappa (G)$；</li><li><strong>边连通度</strong>：记为$\lambda(G)$；<br><img src="连通度例子.png" alt><br><img src="连通度定理.png" alt></li><li><strong>有向图中的强连通、弱连通</strong>：强连通要求A directed graph is strongly connected if there is a path from a to b and  from b to a whenever a and b are  vertices in the graph. 弱连通与无向图类似；</li><li><strong>圈</strong>：$x_0x_1\dots x_{k-1}x_0$；</li><li><strong>围长和圈长</strong>：图$G$中最短圈的长度叫做围长(girth),记为$g(G)$,而$G$中最长圈的长度称为周长(circumference)；</li><li><strong>弦</strong>：图中不在圈上但连接圈中两个顶点的边称为这个圈的弦(chord)；</li><li><strong>导出圈</strong>：$G$的导出圈(induced cycle)是不含弦的圈，即$G$的导出子图是个圈；<br><img src="导出圈.png" alt="导出圈"></li><li><strong>距离、直径、中心点、半径</strong>：暂略；</li><li><strong>树、森林</strong>：暂略；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU Bomb Lab 个人题解</title>
      <link href="/blog/2024/11/05/BombLab/"/>
      <url>/blog/2024/11/05/BombLab/</url>
      
        <content type="html"><![CDATA[<h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h2><p>1.理解C语言程序的机器级表示。</p><p>2.初步掌握GDB调试器的用法。</p><p>3.阅读C编译器生成的x86-64机器代码，理解不同控制结构生成的基本指令模式，过程的实现。</p><h2 id="二、实验环境"><a href="#二、实验环境" class="headerlink" title="二、实验环境"></a>二、实验环境</h2><ol><li>作业服务器</li><li>MacOS终端工具</li><li>Linux</li><li>Objdump命令反汇编</li><li>GDB调试工具</li><li>积分榜</li></ol><h2 id="三、实验内容"><a href="#三、实验内容" class="headerlink" title="三、实验内容"></a>三、实验内容</h2><p>登录作业服务器，在home目录下可以找到Evil博士专门为你量身定制的一个bomb，当运行时，它会要求你输入一个字符串，如果正确，则进入下一关，继续要求你输入下一个字符串；否则，炸弹就会爆炸，输出一行提示信息并向计分服务器提交扣分信息。因此，本实验要求你必须通过反汇编和逆向工程对bomb执行文件进行分析，找到正确的字符串来解除这个的炸弹。</p><p>本实验通过要求使用课程所学知识拆除一个“binary bombs”来增强对程序的机器级表示、汇编语言、调试器和逆向工程等方面原理与技能的掌握。 “binary bombs”是一个Linux可执行程序，包含了5个阶段（或关卡）。炸弹运行的每个阶段要求你输入一个特定字符串，你的输入符合程序预期的输入，该阶段的炸弹就被拆除引信；否则炸弹“爆炸”，打印输出 “BOOM!!!”。炸弹的每个阶段考察了机器级程序语言的一个不同方面，难度逐级递增。  </p><p>为完成二进制炸弹拆除任务，需要使用gdb调试器和objdump来反汇编bomb文件，可以单步跟踪调试每一阶段的机器代码，也可以阅读反汇编代码，从中理解每一汇编语言代码的行为或作用，进而设法推断拆除炸弹所需的目标字符串。</p><h2 id="四、实验步骤及实验分析"><a href="#四、实验步骤及实验分析" class="headerlink" title="四、实验步骤及实验分析"></a>四、实验步骤及实验分析</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li>首先通过 <code>ls</code> 命令查看文件，找到炸弹文件包 <code>bomb. tar</code>；</li><li>然后通过命令 <code>tar -xvf bomb.tar</code> 解压得到三个文件；</li></ul><h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><ul><li>使用 <code>gdb</code> 运行<code>bomb</code>；</li><li>设置断点在函数 <code>phase_1</code> 处，开始运行，输入测试字符串<code>12345</code>；</li><li>用<code>\disas</code> 显示<code>phase_1</code> 部分的汇编代码开始分析；</li></ul><p><img src="1.png" alt="phase_1汇编代码"></p><ul><li>观察到调用了一个 <code>strings_not_equal</code> 函数，根据函数名，其功能很可能是比较输入字符和正确字符是否匹配的函数；</li><li>在<code>strings_not_equal</code> 函数处设置断点，直接<code>continue</code>运行进入该函数；</li><li>显示<code>strings_not_equal</code> 的汇编代码开始分析；</li></ul><p><img src="2.png" alt="strings_not_equal 函数汇编代码"></p><p><strong>Note! <code>%rdi</code> 存放函数的第一个输入，<code>%rsi</code> 存放函数的第二个输入，<code>%eax</code> 存放函数的返回值。</strong></p><ul><li>观察到调用了 <code>string_length</code> 函数，根据函数名，其功能很可能是获取输入字符数量的函数；</li><li>在 <code>string_length</code> 函数处设置断点，直接<code>continue</code>运行进入该函数；</li><li>分析可得其先比较字符串长度，二者不相等则在 <code>%eax</code> 中存 1 返回；若相等，则比较具体内容，若不相等则在 <code>%eax</code> 中存 1 返回；</li><li>结合寄存器功能和汇编代码可以得到函数比较的字符串内容分别存放在 <code>%rdi</code> 和 <code>%rsi</code> 中，分别打印寄存器的值如下：</li></ul><p><img src="3.png" alt="字符串内容"></p><ul><li>得到 <code>%rdi</code> 存放的是我们输入的字符串， <code>%rsi</code> 是目标字符串。函数中，<code>%rsi</code> 的值被赋给 <code>%rbp</code>， <code>%rbp</code> 和 <code>%rdi</code> 上的字符串进行比较。所以 <code>phase_1</code> 需要我们输入与其相同的字符串即可通过。</li></ul><h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><ul><li>在 <code>phase_2</code> 入口处设置断点，运行程序，输入 <code>phase_1</code> 答案，进入阶段 2；同上操作得到汇编代码进行分析；</li></ul><p><img src="4.png" alt="第二阶段开始"></p><ul><li>观察发现其调用<code>read_six_numbers</code>函数，设置断点进入，显示该函数的汇编代码，观察到将地址<code>$0x402a31</code>存入 <code>%esi</code> 后调用 <code>scanf</code> 函数，打印该地址的值，验证了该函数的需要输入6个整数。也可以由下面的 <code>cmp</code> 语句得到，如果<code>scanf</code> 的返回值小于等于5会触发爆炸。</li></ul><p><img src="5.png" alt="第二阶段输入格式确定"></p><p><strong>Note! <code>%rsp</code> 存放堆栈指针，括号表示获取地址上的值。<code>%rbp</code> 存放的是栈的基址。</strong></p><ul><li>继续回到 <code>phase_2</code>，由 <code>cmpl</code> 语句可见第一个输入的整数(<code>%rsp</code>存的地址上的值)需要 &gt;= 1，将其存放到 <code>%eax</code> 上，并将其变为2倍后继续存在 <code>%eax</code>，再与输入的第二个整数比较，要求结果相等，否则触发爆炸。然后检查当前栈指针是否到达栈的基址<code>%rbp</code>，如果顺利到达则跳出，成功通过。</li><li>可以推测出 <code>phase_2</code> 是一种循环结构，依次比较每个输入整数是否符合是前一个输入的2倍，推出一个答案为<code>1 2 4 8 16 32</code>。</li></ul><h3 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h3><ul><li>同上操作，此处不再赘述，进入<code>phase_3</code>并得到汇编代码如下：</li></ul><p><img src="6.png" alt="第三阶段汇编代码1"></p><p><img src="7.png" alt="第三阶段汇编代码2"></p><ul><li>第三阶段代码较为冗长，先通过打印 <code>scanf</code> 函数的调用值得到输入格式为两个整数和一个字符。</li></ul><p><img src="8.png" alt="第三阶段输入格式"></p><ul><li>分析在 <code>0x400fe4</code> 处的 <code>cmpl $0x7, 0x10(%rsp)</code> 指令以及下一条指令 <code>ja 0x4010ef</code> ，得出<code>0x10(%rsp)</code> 处的值，即输入的第一个整数（占 2<sup>4</sup> = 0x10 个字节） ≤  7。</li><li><code>0x400ff3</code> 处的指令 <code>jmpq \*0x4027a0(,%rax,8)</code> 表示跳转到 <code>0x4027a0+输入的第一个整数 *8</code> 所存储的地址处，打印出所有可能的跳转地址如下：</li></ul><p><img src="9.png" alt="所有可能地址"></p><p><strong>Note！<code>*</code> 表示间接跳转，<code>0x4027a0</code> 是一个基地址（立即数），语句应跳转到计算得到的地址上存的地址值。</strong></p><ul><li>此时，再结合 <code>phase_3</code> 整体代码，进行拆分，可以推测其为 <code>switch</code> 分支结构，选择 <code>case 0</code> 进行分析。（每个case结构都基本相同）：</li></ul><p><img src="10.png" alt="case 0结构"></p><ul><li>分析可得，首先比较输入的第二个整数与<code>0x2d7（727）</code>，相等则跳至 <code>4010eb &lt;+318&gt;:    cmp 0xf(%rsp),%al</code>，将输入的字符与 <code>%al (0x77)</code>，对应 ASCII 码 <code>w</code>比较，相等则通过。</li></ul><p><strong>Note！<code>%al</code> 和 <code>%eax</code> 为同一个寄存器，<code>%al</code> 是 <code>%rax</code> 寄存器的最低 8 位。<code>%eax</code> 是低 32 位。</strong></p><ul><li>以此类推，得到所有可能答案如下：</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>第一个整数</strong></th><th style="text-align:center"><strong>字符</strong></th><th style="text-align:center"><strong>第二个整数</strong></th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">w</td><td style="text-align:center">727</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">u</td><td style="text-align:center">786</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">g</td><td style="text-align:center">63</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">f</td><td style="text-align:center">363</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">s</td><td style="text-align:center">117</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">d</td><td style="text-align:center">602</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">q</td><td style="text-align:center">818</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">e</td><td style="text-align:center">197</td></tr></tbody></table></div><h3 id="第四阶段"><a href="#第四阶段" class="headerlink" title="第四阶段"></a>第四阶段</h3><ul><li>同上操作，此处不再赘述，进入 phase_4 并得到汇编代码如下。</li></ul><p><img src="11.png" alt="第四阶段汇编代码"></p><ul><li>先通过打印 <code>scanf</code> 函数的调用值得到输入格式为两个整数。</li></ul><p><img src="12.png" alt="第四阶段输入格式"></p><ul><li>发现 <code>phase_4</code> 调用了 <code>func4</code>函数，在这之前，先检查了输入是否为2个整数，再将第二个输入的整数赋给 <code>%eax</code>，减2后和2比较大小，如果小于等于2则继续。得到第二个整数 &lt;= 4。</li><li>在进入函数之前，观察得到 <code>%esi</code>（第二个输入的整数）和 <code>%rdi (8)</code>作为参数被传入 <code>func4</code>。</li><li>进入函数，打印其汇编代码如下：</li></ul><p><img src="13.png" alt="func4汇编代码"></p><ul><li>大致观察即可发现其为递归函数，分析汇编指令画出大致流程图如下：</li></ul><p><img src="14.png" alt="个人绘制的大致流程图"></p><ul><li>分析得到递归函数如下：<code>func4(n, x) = x + func4(n – 1, x) + func4(n – 2, x), n &gt; 1；func4(1, x) = x, func4(0, x) = 0</code>。</li><li>如果第二个输入为2，那么可以推出<code>func4(8, 2) = 108</code>，再根据函数结束后中<code>cmp 0x4(%rsp),%eax</code>可以判断返回值需要和第一个输入相等，所以一个答案为<code>108 2</code>。</li></ul><p><img src="15.png" alt="递归树状图"></p><h3 id="第五阶段"><a href="#第五阶段" class="headerlink" title="第五阶段"></a>第五阶段</h3><ul><li>同上操作，此处不再赘述，进入 <code>phase_5</code> 并得到汇编代码如下：</li></ul><p><img src="16.png" alt="第五阶段汇编代码"></p><ul><li>同样发现其调用 <code>strings_length</code> 函数，由第一阶段分析可知，输入的字符串长度应为6。并且函数尾部调用 <code>strings_not_equal</code> 函数，比较输入字符串（<code>%rdi</code>）和目标字符串（<code>%rsi</code>）是否相等。</li><li>由 <code>0x401204 &lt;+76&gt;: mov $0x40278f,%esi</code>语句可知目标字符串的地址，打印内容可得：</li></ul><p><img src="17.png" alt="目标字符串内容"></p><ul><li>再分析中间对字符串的操作部分。先将输入字符串存入 <code>%rbx</code> 中，然后通过指令 <code>movzbl (%rbx,%rax,1),%edx</code> 取出输入字符的第一位存到 <code>%edx</code> 中。</li></ul><p><strong>Note! <code>movzbl</code> 从源操作数读取一个 8 位值，并将其扩展到 32 位，填充高 24 位为零，然后存入目标寄存器。</strong></p><p><strong>Note! <code>(%rbx, %rax, 1)</code>是内存地址的计算方式，表示从 <code>(%rbx + %rax * 1)</code> 地址处读取一个字节的数据。其中 <code>%rbx</code> 是基地址寄存器，<code>%rax</code> 是索引寄存器，1是偏移量。</strong></p><ul><li>对于取出的字符，执行 <code>and  $0xf,%edx</code>，分析可得其作用是将其低四位保留下来，其余位清零。</li><li>接着执行<code>movzbl 0x4027e0(%rdx),%edx</code>，表示从 <code>0x4027e0 + %rdx</code> 处取出 1 字节数据扩展后存储 到 <code>%edx</code> 中，然后将 <code>%dl</code> 中的数据存储在 <code>(%rbx + %rax \* 1)</code> 处；</li><li>上述操作重复 6 次直到 <code>%rax</code> 等于 6，即字符串操作完毕。</li><li>打印 <code>0x4027e0</code>上的内容：</li></ul><p><img src="18.png" alt="密钥内容"></p><ul><li>分析可得，该阶段是在 <code>0x4027e0</code> 处挑选第 <code>%rdx</code> 个字符，然后这些挑选出的字符组合成一个字符串，即目标字符串 <code>bruins</code>；</li><li><p>但是我们要进行的是解密操作，<code>bruins</code> 在密钥中对应的索引为 <code>13，6，3，4，8，7</code>，所以只需要输入的字符的低四位符合对应的索引即可，一个答案是 <code>MFCDHG</code> 。</p></li><li><p>简述一下<code>phase_6</code>和<code>secret_phase</code>，两者都涉及到对自定义结构体的操作，<code>phase_6</code>是对链表按照数据大小进行重排，而<code>secret_phase</code>是一个二叉搜索树。</p></li></ul><p><img src="19.png" alt="答案汇总"></p><p><img src="20.png" alt="通过截图"></p>]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
            <tag> 汇编代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.4 Group 群</title>
      <link href="/blog/2024/11/04/9.4%20Groups%20%E7%BE%A4/"/>
      <url>/blog/2024/11/04/9.4%20Groups%20%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Inverse"><a href="#Inverse" class="headerlink" title="Inverse"></a><em>Inverse</em></h1><blockquote><p><strong><em>Defination:</em></strong> 令$(S, <em>)$是一个幺半群，$x \in S$。当$\exists y \in S, x </em> y = y <em> x = e$，则称$y$为$x$的逆元，记为$x^{-1}$。<br>单位元一定是可逆的。<br>逆元是唯一的。<br>**</em>Prove:<em>** 设$(S, </em>)$是一个幺半群，$x \in S$可逆，若$\exists y_1,y_2$为$x$的逆元，<br>有$y_1 = y_1 <em> e = y_1 </em> (x <em> y_2) = (y_1 </em> x) <em> (y_2) = e </em> y_2 = y_2$</p></blockquote><h1 id="Group-群"><a href="#Group-群" class="headerlink" title="Group 群"></a><em>Group 群</em></h1><blockquote><p><strong><em>Defination1:</em></strong> 由上面引出，若$(S, <em>)$是一个幺半群，如果每一个元素均可逆，则$(S, </em>)$构成一个群。<br><strong><em>Defination2:</em></strong> 拓展半群的定义：</p><blockquote><ol><li><strong><em>Closure</em></strong> 运算封闭性；</li><li><strong><em>Associativity</em></strong> 结合律</li><li><strong><em>Identity</em></strong> 存在单位元</li><li><strong><em>Inverse</em></strong> 每个元素都有逆元<br><strong><em>引理:</em></strong> $(S, <em>)$是幺半群，令$G$是其所有可逆元素构成的子集，则$(G, </em>)$是群。<br><strong><em>Properties:</em></strong> </li><li>$(a^{-1})^{-1} = a$</li><li>$(ab)^{-1} = b^{-1}a^{-1}$</li><li>$ab = ac \rightarrow b = c$（左消去律）</li><li>$ba = ca \rightarrow b = c$（右消去律）<br>事实上，群的定义可以减弱为$\textbf{ea = a}$<br><strong><em>Prove:</em></strong> $ae = aa^{-1}(a^{-1})^{-1} = e(a^{-1})^{-1} = ea$</li></ol></blockquote></blockquote><h1 id="几类特殊的群"><a href="#几类特殊的群" class="headerlink" title="几类特殊的群"></a><em>几类特殊的群</em></h1><h2 id="Abelian-Group-阿贝尔群-交换群"><a href="#Abelian-Group-阿贝尔群-交换群" class="headerlink" title="Abelian Group 阿贝尔群/交换群"></a><em>Abelian Group 阿贝尔群/交换群</em></h2><blockquote><p><strong><em>Defination:</em></strong> $(G, <em>),\forall x,y \in G, x </em> y = y * x$。</p></blockquote><h2 id="平凡群"><a href="#平凡群" class="headerlink" title="平凡群"></a><em>平凡群</em></h2><blockquote><p><strong><em>Defination:</em></strong> $(\{e\}, *)$</p></blockquote><h2 id="General-Linear-Group-n阶一般线性群"><a href="#General-Linear-Group-n阶一般线性群" class="headerlink" title="General Linear Group n阶一般线性群"></a><em>General Linear Group n阶一般线性群</em></h2><blockquote><p><strong><em>Defination:</em></strong> $n * n$阶可逆实矩阵构成的乘法群，$GL_n(R) = \{A \in M_n(R):det(A)\neq0\}$</p></blockquote><h1 id="Subgroup-子群"><a href="#Subgroup-子群" class="headerlink" title="Subgroup 子群"></a><em>Subgroup 子群</em></h1><blockquote><p><strong><em>Defination:</em></strong> $H$是$G$的子群，记作$H &lt; G，满足：</p><blockquote><ol><li>$e \in H$</li><li>封闭性</li><li>都有逆元<br>还可以压缩为：</li><li>非空$H \subset G$</li><li>$\forall x,y \in H,ab^{-1} \in H$<br>上述也可以作为<strong><em>判定方法</em></strong>。</li></ol></blockquote></blockquote><h1 id="Homomorphism-群同态"><a href="#Homomorphism-群同态" class="headerlink" title="Homomorphism 群同态"></a><em>Homomorphism 群同态</em></h1><blockquote><p><strong><em>Defination:</em></strong> $(G, <em>),(G’,</em>‘)$ 是两个群，$f:G \rightarrow G’$是一个群同态，那么有</p><blockquote><ol><li>$f(e) = e’$；</li><li>$f(a^{-1})=(f(a))^{-1}$；</li><li>$H$是$G$的一个子群，那么$f(H) = \{f(h)|h \in H\}$也是$G’$的一个子群；<br><strong><em>命题:</em></strong> $det:GL_n(R)\rightarrow (R, <em>)$是一个乘法群同态，即行列式是一般线性群到实数乘群的一个群同态。<br>对$SL_n(R)=\{A \in GL_n(R):det(A) = 1\}$，显然1是$(R, </em>)$的单位元，那么，<br>$SL_n(R) = det^{-1}(1)=det^{-1}(\{1\})$，翻译成人话，特殊线性群是那些映射到单位元元素的矩阵的集合，即它是实数乘群中单位元的一个原象，也是下面提到的<strong><em>正规子群</em></strong>。<br><strong><em>满同态，单同态</em></strong><br><strong><em>Note!</em></strong> 单同态当且仅当$Ker(f) = \{e\}$，要证明群同态是单射，只需证$Ker(f) = \{e\}$。</li></ol></blockquote></blockquote><h2 id="Kernal-Image-核-像"><a href="#Kernal-Image-核-像" class="headerlink" title="Kernal, Image 核/像"></a>Kernal, Image 核/像</h2><blockquote><p><strong><em>Defination:</em></strong> $f:G \rightarrow G’$是一个群同态，$Ker(f) = \{a\in G|f(a)=e’\},Im(f)=f(G)=\{y\in G:\exists x\in G,y = f(x)\}$</p></blockquote><h2 id="同态基本定理"><a href="#同态基本定理" class="headerlink" title="同态基本定理"></a>同态基本定理</h2><p><strong><em>Defination:</em></strong> 设$f:G \rightarrow G’$是同态，$R$是$G$上的关系且被定义为$aRb \iff f(a) = f(b)$，那么有：</p><blockquote><p>1）$R$是同余关系；<br>2）$G’$和$G/R$同构；<img src="img/Wondershare%20PDFelement%202024-11-05%2012.08.43.png" alt></p></blockquote><h1 id="Isomorphism-同构"><a href="#Isomorphism-同构" class="headerlink" title="Isomorphism 同构"></a><em>Isomorphism 同构</em></h1><blockquote><p><strong><em>Defination:</em></strong> 双射的同态。</p></blockquote><h1 id="Direct-Product-群的直积"><a href="#Direct-Product-群的直积" class="headerlink" title="Direct Product 群的直积"></a><em>Direct Product 群的直积</em></h1><blockquote><p><strong><em>Defination:</em></strong> $(x, y)*(x’,y’)=(x \circ_1 x’, y \circ_2 y’)$</p></blockquote><h1 id="Finate-Group-有限群"><a href="#Finate-Group-有限群" class="headerlink" title="Finate Group 有限群"></a><em>Finate Group 有限群</em></h1><blockquote><p><strong><em>Defination:</em></strong> $G\space is\space Finate\space Group \iff G$是一个有限集合<br><strong><em>The Order of Group 群的阶</em></strong></p><blockquote><p><strong><em>Defination:</em></strong> 若$x \in G$，如果$\exists 最小正整数n \in N,s.t.x^n=e$，则$|G|=n$，若不存在，则$|G|=\infty$<br><strong><em>命题1:</em></strong> 有限群的每一个元素经过有限次自乘都可以得到单位元。 </p></blockquote></blockquote><h1 id="Cyclic-Group-循环群"><a href="#Cyclic-Group-循环群" class="headerlink" title="Cyclic Group 循环群"></a><em>Cyclic Group 循环群</em></h1><blockquote><p><strong><em>命题1:</em></strong> 令$G=<x>$是有限循环群，假设$|x| = n$，则$G = \{e,x^2,……,x^n\}$，其中元素是两两不同的，则称有限群$G$的阶为$n$。<br>可以用<strong><em>Cayley图</em></strong>进行可视化表示：<img src="img/Google%20Chrome%202024-11-05%2008.56.29.png" alt><strong><em>命题2:</em></strong> 任意n阶循环群互相同构，无限循环群也是互相同构的。<br><strong><em>命题3:</em></strong> 任意循环群都是交换群。<br><strong><em>命题4:</em></strong> 令$G = <x>$为无限循环群，G只有两个生成元分别为$x,x^{-1}$。<br><strong><em>几类特殊的循环群:</em></strong> </x></x></p><blockquote><p>$(Z, +) = <1>,1$或$-1$是它的生成元，无限循环群；<br><strong><em>Lagrange定理:</em></strong> 若$H$是$G$的子群，则$|H|\space |\space |G|$。</1></p></blockquote></blockquote><h1 id="Coset-陪集"><a href="#Coset-陪集" class="headerlink" title="Coset 陪集"></a>Coset 陪集</h1><blockquote><p><strong><em>左陪集</em></strong></p><blockquote><p><strong><em>Defination:</em></strong> $H$是$G$的一个子群，$aH = \{ah|h \in H\},a \in G$，陪集一般不是子群。<br>定义$f:H \rightarrow aH,f(x)=ax$，显然是双射，则$|H|=|aH|$。<br><strong><em>命题1:</em></strong> 两个左陪集要么相等要么无交，所有陪集构成群的一个分拆。<br>可以定义为商集$G/H$<br><strong><em>右陪集</em></strong><br>如何赋予商集一个群的结构？</p></blockquote></blockquote><h1 id="Normal-Group-正规子群"><a href="#Normal-Group-正规子群" class="headerlink" title="Normal Group 正规子群"></a><em>Normal Group 正规子群</em></h1><blockquote><p><strong><em>Defination:</em></strong> $N&lt;G,\forall a \in G,aN = Na$，记作$H \lhd G$，此时$(G/N,\circ)$称为商群。其单位元为$eN = N$，逆元为$a^{-1}N$<br><strong><em>商群:</em></strong> 可以通过正规子群来生成商集，并定义二元运算为$(aN) \times (bN)=[a]\circ [b] = [a <em> b] = abN$<br>同时有函数定义为$f_R:G \rightarrow G/R, f_R(a) = aN$,则$f_R$是由$G \rightarrow G/R$的同态，一般记为$G/N$。<br>**</em>定理:<em>*</em> 设$G$的正规子群$N$，设定义在$G$上的关系$R: aRb \iff ab^{-1} \in N$，那么有：</p><blockquote><ol><li>$R$是$G$上的同余关系；</li><li>$N = [e]$；<br><strong><em>Prove:</em></strong> $证明自反性: aa^{-1}=e \in N \Rightarrow aRa$<br>$证明对称性, if\space aRb, then\space ab^{-1}\in N,由于其存在逆元，则(ab^{-1})^{-1}=ba^{-1}\Rightarrow bRa$<br>$证明传递性,if\space aRb,bRc,then\space ab^{-1},bc^{-1}\in N,由封闭性,ab^{-1}bc^{-1} = ac^{-1}\in N\Rightarrow aRc$<br>$证明同余关系,$</li></ol></blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 群论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 群论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.3 Products and Quotients of Semigroups 乘积半群、商半群</title>
      <link href="/blog/2024/11/04/9.%203%20Products%20and%20Quotients%20of%20Semigroups%20%E4%B9%98%E7%A7%AF%E5%8D%8A%E7%BE%A4%E3%80%81%E5%95%86%E5%8D%8A%E7%BE%A4/"/>
      <url>/blog/2024/11/04/9.%203%20Products%20and%20Quotients%20of%20Semigroups%20%E4%B9%98%E7%A7%AF%E5%8D%8A%E7%BE%A4%E3%80%81%E5%95%86%E5%8D%8A%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Products-Semigroups-积半群（半群的笛卡尔积）"><a href="#Products-Semigroups-积半群（半群的笛卡尔积）" class="headerlink" title="Products Semigroups 积半群（半群的笛卡尔积）"></a><em>Products Semigroups 积半群（半群的笛卡尔积）</em></h1><blockquote><p><strong><em>定理1:</em></strong> 两个半群的笛卡尔积也是半群。<img src="img/Wondershare%20PDFelement%202024-11-04%2018.29.31.png" alt><br><strong><em>定理2:</em></strong> 类似，两个幺半群的笛卡尔积也是幺半群且其幺元为$(e_S,e_T)$。<img src="img/Wondershare%20PDFelement%202024-11-04%2018.31.58.png" alt></p></blockquote><h1 id="Congruence-relation-同余关系"><a href="#Congruence-relation-同余关系" class="headerlink" title="Congruence relation 同余关系"></a><em>Congruence relation 同余关系</em></h1><blockquote><p><strong><em>Defination:</em></strong> 在半群$(S,∗)$上的等价关系R，如果满足：任意$a R a’$并且$b R b’$ $\Rightarrow$ $(a∗b) R (a’∗ b’)$，则称$R$为半群上的同余关系。<br><strong><em>回忆:</em></strong> 等价关系满足自反性、对称性、传递性。<br><strong><em>解题法:</em></strong></p><blockquote><p><strong><em>Prove Step:</em></strong> R是半群上的同余关系？</p><ol><li>等价关系显然（已知给出）。</li><li>根据$a R a’$和$b R b’$可以推出 $(a∗b) R (a’∗ b’)$。<br><strong><em>Note!</em></strong> 等价关系不一定是同余关系。反例：<img src="img/Wondershare%20PDFelement%202024-11-04%2018.53.08.png" alt></li></ol></blockquote></blockquote><h1 id="Quotients-Semigroups-商半群"><a href="#Quotients-Semigroups-商半群" class="headerlink" title="Quotients Semigroups 商半群"></a>Quotients Semigroups 商半群</h1><blockquote><p><strong><em>Defination:</em></strong> <img src="img/Wondershare%20PDFelement%202024-11-04%2019.01.38.png" alt><br>其实就是按照以下步骤定义了一种二元运算：</p><blockquote><ol><li>$S = \{a,b,c,……,a’,b’,c’,……\}$</li><li>设定价类$[a] = \{a, a’,……\},[b] = \{b, b’,……\},[c] = \{c, c’,……\},……$</li><li>$S/R = \{[a],[b],[c],……\}$</li><li>$S/R \times S/R = \{([a],[a]),([a],[b]),([a],[c]),……\}$</li><li>$f:S/R \times S/R \rightarrow S/R$</li><li>$f([a],[b]) = [c] \leftrightarrow [a] \otimes [b] = [c]$<br><strong><em>Note!</em></strong> 注意$\otimes$是等价类之间的运算，可以用代入等价类中的元素进行计算，即$[a] \otimes [b] = [a <em> b]$<br>**</em>幺半群导出的商半群也是幺半群<strong><em> <img src="img/Wondershare%20PDFelement%202024-11-04%2019.43.44.png" alt></em></strong>Prove:<em>**<br>$[a] \otimes [e] = [a </em> e] = [a]=[e * a] = [e] \otimes [a]$</li></ol></blockquote></blockquote><h1 id="Natural-Homomorphism-自然同态"><a href="#Natural-Homomorphism-自然同态" class="headerlink" title="Natural Homomorphism 自然同态"></a><em>Natural Homomorphism 自然同态</em></h1><blockquote><p><strong><em>Defination:</em></strong> $f_R:S \rightarrow S/R\space defined\space by\space f_R(a) = [a]$，显然满射(onto)。<img src="img/Wondershare%20PDFelement%202024-11-04%2019.51.57.png" alt></p></blockquote><h1 id="Fundamental-Homomorphism-同态基本定理"><a href="#Fundamental-Homomorphism-同态基本定理" class="headerlink" title="*Fundamental Homomorphism 同态基本定理"></a>*Fundamental Homomorphism 同态基本定理</h1><blockquote><p><strong><em>Defination:</em></strong> 设$f:S \rightarrow T$是同态，$R$是$S$上的关系且被定义为$aRb \iff f(a) = f(b)$，那么有：<br>1）$R$是同余关系；<br>2）$T$和$S/R$同构；<img src="img/Wondershare%20PDFelement%202024-11-04%2020.17.07.png" alt></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 群论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 群论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.2 Semigroups 半群、同态、同构</title>
      <link href="/blog/2024/11/03/9.2%20Semigroups%20%E5%8D%8A%E7%BE%A4%E3%80%81%E5%90%8C%E6%80%81%E3%80%81%E5%90%8C%E6%9E%84/"/>
      <url>/blog/2024/11/03/9.2%20Semigroups%20%E5%8D%8A%E7%BE%A4%E3%80%81%E5%90%8C%E6%80%81%E3%80%81%E5%90%8C%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="Semigroups"><a href="#Semigroups" class="headerlink" title="Semigroups"></a><em>Semigroups</em></h1><ul><li><p><strong><em>Defination</em></strong></p><blockquote><p>非空集合<br>结合性（自然满足封闭性）<br>如果可交换，则为Abel半群</p></blockquote></li><li><p><strong><em>自由半群</em></strong></p><blockquote><p>操作符 · 是指连接运算，显然其具有结合律。<br>称 $(A^∗, · )$ 为由 A 生成的自由半群 (free semigroup generated by A)。<img src="img/Wondershare%20PDFelement%202024-11-03%2019.35.46.png" alt></p></blockquote></li><li><p><strong><em>Identity 单位元，幺元</em></strong></p><blockquote><p>单位元若存在必唯一。<br><strong><em>Prove:</em></strong></p><pre><code>假设$e, e&#39;$都是单位元，由单位元性质可得$e = e * e&#39; = e&#39;$。</code></pre></blockquote></li><li><p><strong><em>Monoid——独异点，幺半群</em></strong></p><blockquote><p>半群 $(S, *)$ 中存在单位元，则称为独异点。</p></blockquote></li><li><p><strong><em>定理 1 半群的卡特兰律（广义结合律）</em></strong></p><blockquote><p>如果 $a_1, a_2, …, a_n$ 是半群的任意元素（其中 $n ≥ 3$），那么在任意元素的乘积中插入有意义的括号形成的乘积是相等的。<br><strong><em>翻译成人话就是，任意加括号都成立</em></strong><br><strong><em>引理1:</em></strong>$(x_1……x_n) <em> (y_1……y_n) = x_1……x_ny_1……y_n$成立<br>**</em>Prove:<em>*</em>（数学归纳法）</p><pre><code>取定$n \in N$,对$n$做数学归纳：1）若$m = 1$$(x_1……x_n)y_1 = x_1……x_ny_1$2）由$m \rightarrow m + 1$$$\begin&#123;align&#125;</code></pre><p>(x_1……x_n) <em> (y_1……y_{m+1})\ <br>&amp;= (x_1……x_n) </em> ((y_1……y_m) <em> y_{m + 1})\ <br>&amp;= ((x_1……x_n) </em> (y_1……y_{m})) <em> y_{m + 1}\ <br>&amp;= (x_1……x_ny_1……y_{m+1}) </em> y_{m + 1}\ <br>&amp;= x_1……x_ny_1……y_{m+1}<br>\end{align}$$至于为什么要说这个，就是这个才保证了下面的定义。</p></blockquote></li><li><p><strong><em>Powers of A 幂</em></strong> </p><blockquote><p><strong><em>Defination:</em></strong> $x^n = x^{n - 1} <em> x = x </em> x <em> …… </em>x$，规定$x^0 = e$。<br>显然，不规定也行，$x^m <em> x^n = x^{m+n}, \forall m,n \ge 1$是显然的，如果我们希望更完备呢？<br>$x^m </em> x^0 = x^m$如果成立，那么$x^0$不就等于单位元吗？<br>有了这个规定自然又得到了以下性质。</p></blockquote></li><li><p><strong><em>生成半群/生成子幺半群</em></strong></p><blockquote><p><strong><em>Defination:</em></strong> 设$(S, *)$是幺半群，而$A \subset S$，则$A$生成的子幺半群记作$&lt; A &gt; = \cap T,T \supset A, T &lt; S$<br>人话，$&lt; A &gt;$是所有$S$中包含了$A$的子幺半群的交集。<br>子半群和子幺半群可以按照如下方式生成。<img src="img/Wondershare%20PDFelement%202024-11-03%2022.48.18.png" alt></p></blockquote></li></ul><h1 id="Subsemigroup"><a href="#Subsemigroup" class="headerlink" title="Subsemigroup"></a><em>Subsemigroup</em></h1><ul><li><p><strong><em>Defination</em></strong></p><blockquote><p>子集<br>运算封闭（一定满足结合性）</p></blockquote></li><li><p><strong><em>Submonoid——子独异点</em></strong></p><blockquote><p>子集<br>运算封闭<br>幺元属于T<br><strong><em>Note! T的幺元必须和S的幺元相同</em></strong><img src="img/Wondershare%20PDFelement%202024-11-03%2019.50.28%201.png" alt><br>T 是 S 的子集，并且 $(T, <em>)$ 同样满足独异点定义，同时 $e∈T$；<br>显然，半群$(S, </em>)$ 本身也是$S$的子半群；独异点$(S, <em>)$ 本身也是$S$的子独异点；<br>$T = \{e\}$一定是群$(S, </em>)$ 的子独异点。</p></blockquote></li></ul><h1 id="Homomorphism-同态"><a href="#Homomorphism-同态" class="headerlink" title="Homomorphism 同态"></a><em>Homomorphism 同态</em></h1><blockquote><p><strong><em>Defination:</em></strong> 人话，保持运算，保持特殊元素。<br>如果$S$和$T$的满足<strong><em>幺半群同态</em></strong>关系，<script type="math/tex">f:(S, ·) \rightarrow (T, *)\leftrightarrow \left\{\begin{aligned}&保持乘法，即\forall x,y \in S, f(x · y) = f(x) * f(y)\\&保持单位元，即f(e) = e'\end{aligned}\right.</script>直观理解如下图：<img src="img/Wondershare%20PDFelement%202024-11-04%2012.17.01.png" alt>人话，两个元素作运算能映射到另一个集合，另一个集合中的元素作运算也能映射回原集合</p></blockquote><h1 id="Isomorphism-同构"><a href="#Isomorphism-同构" class="headerlink" title="Isomorphism 同构"></a><em>Isomorphism 同构</em></h1><blockquote><p><strong><em>Defination:</em></strong> 人话，双射，保持运算，保持特殊元素。<br>直观理解如下图：<img src="img/Wondershare%20PDFelement%202024-11-04%2012.14.53.png" alt><br><strong><em>&amp;0</em></strong> 如果$S$和$T$的满足<strong><em>幺半群同构</em></strong>关系，<script type="math/tex">f:(S, ·) \rightarrow (T, *)\leftrightarrow \left\{\begin{aligned}&满足双射，即\forall x,y \in S,x \leftrightarrow f(x),y \leftrightarrow f(y), x · y \leftrightarrow f(x) * f(y)\\&保持乘法，即\forall x,y \in S, f(x * y) = f(x) · f(y)\\&保持单位元，即f(e) = e'\end{aligned}\right.</script><strong><em>&amp;1 恒等映射</em></strong>，即$S$是自己的同构。<br><strong><em>&amp;2</em></strong> 如果 $f$ 是从 $S\rightarrow T$ 的同构，即 $f$ 是从 $S\rightarrow T$ 的<strong>一一对应</strong>的函数，那么 $f^{−1}$ 必定存在，并且 $f^{−1}$ 是从 $S\rightarrow T$ 的一一对应的函数, 且一定是同构。<br><strong><em>&amp;3</em></strong> 显然，如果$(S,∗)$有独异点，但$(T,∗)$没有独异点，那么必定不存在从 $S\rightarrow T$ 的同构 <strong>(常用于证明不存在同构)</strong><br><strong><em>$4</em></strong> 显然，同态和同构均满足像点的乘积等于乘积的像点，区别是，同构需要一一对应。</p></blockquote><h1 id="满同态"><a href="#满同态" class="headerlink" title="满同态"></a><em>满同态</em></h1><blockquote><p><strong>定理1</strong> 如果$S$和$T$是幺半群，且幺元分别为$e,e’$，$S\rightarrow T$为满同态映射，那么有$f(e) = e’$。<br><strong><em>Prove:</em></strong> 由同态定义，$\forall a \in S,f(e · a) = f(a) <em> f(e) = f(a)$，但是首先需要保证$f(a) \in T$，即满射，才能成立，此时$f(e) = e’$。<br><em>*定理2</em></em> 如果$S$和$T$是幺半群，且$S$为可交换半群，$S\rightarrow T$为满同态映射，那么$T$也是可交换半群。</p></blockquote><h1 id="解题法"><a href="#解题法" class="headerlink" title="解题法"></a><em>解题法</em></h1><ul><li><p><strong><em>Example:</em></strong> $(S, *)$是幺半群吗？</p><blockquote><p><strong><em>Prove Step:</em></strong></p><ol><li>有没有封闭性？</li><li>结合律？</li><li>有没有单位元？</li></ol></blockquote></li><li><p><strong><em>Example:</em></strong> 构造同构/证明是否为同构？</p><blockquote><p><strong><em>Prove Step:</em></strong></p><ol><li>(构造或直接给出)构造一个函数 $f: S\rightarrow T$ , 使得 $f$ 的定义域 $Dom (f) = S$;</li><li>证明 $f$ 是单射 (one-to-one)的，可用反证法</li><li>证明 $f$ 是满射 (onto)的 $\rightarrow$ 故而是双射的</li><li>证明 $f(a · b)=f(a)∗f(b)$<br>同态无需证明$Step2,Step3$</li></ol></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 群论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 群论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.1 群论Intro</title>
      <link href="/blog/2024/11/03/9.1%20%E7%BE%A4%E8%AE%BAIntro/"/>
      <url>/blog/2024/11/03/9.1%20%E7%BE%A4%E8%AE%BAIntro/</url>
      
        <content type="html"><![CDATA[<h1 id="Binary-operation"><a href="#Binary-operation" class="headerlink" title="Binary operation"></a><em>Binary operation</em></h1><blockquote><p><strong>Defination:</strong> 对两个对象进行操作的运算称为二元运算。一般在《离散数学》这门课中只研究离散结构，e.g. 集合。</p></blockquote><h1 id="Some-Properties-of-Binary-Operations"><a href="#Some-Properties-of-Binary-Operations" class="headerlink" title="Some Properties of Binary Operations"></a><em>Some Properties of Binary Operations</em></h1><h2 id="Closure"><a href="#Closure" class="headerlink" title="Closure"></a><em>Closure</em></h2><blockquote><p><strong>Defination:</strong> 设集合 S 有二元运算∗, 若对 S 中的任意两个元素 $a_1$、$a_2$, 都有: $a_1∗a_2∈S$, 则称运算∗对集合 S 封闭。</p></blockquote><h2 id="Commutative"><a href="#Commutative" class="headerlink" title="Commutative"></a><em>Commutative</em></h2><blockquote><p><strong>Defination:</strong>   交换律也称为Abel 律，设有代数 $(S,∗)$，若对任意 $a_1,a_2∈S$,都符合等式: $a_1∗a_2=a_2∗a_1$,那么称代数 $(S,∗)$ 运算符合交换律。<br><strong>推广:</strong> 如果 $(S,∗)$ 运算符合交换律，那么对于运算序列 $a_1∗a_2∗…∗a_n$，设 $θ(12…n)$ 为任意重排列，那么有:  $a_θ(1)∗a_θ(2)∗…∗a_θ(n)=a_1∗a_2∗…∗a_n$。</p></blockquote><h2 id="Associative"><a href="#Associative" class="headerlink" title="Associative"></a><em>Associative</em></h2><blockquote><p><strong>Defination:</strong> if <em> is a binary operation, then </em> is associative or has the associative property:$(x <em> y) </em> z = x <em> (y </em> z)$，在运算过程中不需要再考虑括号了！</p></blockquote><h2 id="Distributive"><a href="#Distributive" class="headerlink" title="Distributive"></a><em>Distributive</em></h2><blockquote><p>略。</p></blockquote><h2 id="De-Morgan‘s-laws"><a href="#De-Morgan‘s-laws" class="headerlink" title="De Morgan‘s laws"></a><em>De Morgan‘s laws</em></h2><blockquote><p>扔个PPT在这。<img src="imgs/Wondershare%20PDFelement%202024-11-03%2017.07.25.png" alt></p></blockquote><h2 id="Idempotent"><a href="#Idempotent" class="headerlink" title="Idempotent"></a><em>Idempotent</em></h2><blockquote><p><strong>Defination:</strong> $a * a = a$</p></blockquote><h2 id="Note！"><a href="#Note！" class="headerlink" title="Note！"></a><em>Note！</em></h2><blockquote><p>An operation has a property means the statement of the property is true when the operation is used with any objects in the structure.</p></blockquote><h1 id="A-binary-operation-on-a-set"><a href="#A-binary-operation-on-a-set" class="headerlink" title="A binary operation on a set"></a><em>A binary operation on a set</em></h1><blockquote><p><strong>Defination:</strong> Everywhere defined $f:A×A\rightarrow A$，同时需要满足封闭性和运算结果唯一，即双射性质。</p></blockquote><h1 id="Tables-运算表"><a href="#Tables-运算表" class="headerlink" title="Tables(运算表)"></a><em>Tables(运算表)</em></h1><blockquote><p><strong>Defination:</strong> If A is a finite set, we can define a binary operation on A by means of a table.<img src="img/Wondershare%20PDFelement%202024-11-03%2017.15.57.png" alt></p></blockquote><h1 id="Some-Special-Elements"><a href="#Some-Special-Elements" class="headerlink" title="Some Special Elements"></a><em>Some Special Elements</em></h1><h2 id="Identity-中性元"><a href="#Identity-中性元" class="headerlink" title="Identity(中性元)"></a><em>Identity(中性元)</em></h2><blockquote><p><strong>Defination:</strong> $e∗x=x∗e=x$</p></blockquote><h2 id="Zero-零元"><a href="#Zero-零元" class="headerlink" title="Zero(零元)"></a><em>Zero(零元)</em></h2><blockquote><p><strong>Defination:</strong> $\theta ∗ x=x ∗ \theta= \theta$</p></blockquote><h2 id="Inverse-逆元"><a href="#Inverse-逆元" class="headerlink" title="Inverse(逆元)"></a><em>Inverse(逆元)</em></h2><blockquote><p><strong>Defination:</strong> $x <em> y = y </em> x = e$，两者互为逆元</p></blockquote><h2 id="Note"><a href="#Note" class="headerlink" title="Note!"></a><em>Note!</em></h2><blockquote><ol><li>单位元以及零元的唯一性</li><li>如果$\left| A \right| &gt; 1, \theta \neq e$</li><li>可结合的运算逆元唯一性</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 群论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 群论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卡尔曼滤波</title>
      <link href="/blog/2024/10/26/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/"/>
      <url>/blog/2024/10/26/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-简述"><a href="#1-简述" class="headerlink" title="1. 简述"></a>1. 简述</h2><p>在目标轨迹追踪领域，传统均值/中值滤波器仅能处理位置信息且存在滞后问题。R.E.Kalman于1960年提出的卡尔曼滤波，通过融合物理动力学模型与传感器观测数据，实现状态向量（位置、速度等）的最优估计。其核心优势在于：</p><ul><li>利用先验知识降低测量噪声影响</li><li>无延迟的实时递推计算</li><li>提供估计结果的置信度评价（协方差矩阵）</li></ul><hr><h2 id="2-推导"><a href="#2-推导" class="headerlink" title="2. 推导"></a>2. 推导</h2><h3 id="2-1-系统模型框架"><a href="#2-1-系统模型框架" class="headerlink" title="2.1 系统模型框架"></a>2.1 系统模型框架</h3><p>设系统状态向量为$x_i \in \mathbb{R}^n$，包含位置、速度等多维变量。卡尔曼滤波建立两套数学模型：</p><p><strong>动态模型</strong>（状态转移方程）:</p><script type="math/tex; mode=display">x_i = F_ix_{i-1} + w_i,\quad w_i \sim \mathcal{N}(0,Q_i)</script><p>其中$F_i$为状态转移矩阵，$w_i$为过程噪声</p><p><strong>观测模型</strong>（测量方程）:</p><script type="math/tex; mode=display">z_i = H_ix_i + v_i,\quad v_i \sim \mathcal{N}(0,R_i)</script><p>$H_i$为观测矩阵，$v_i$为测量噪声</p><h3 id="2-2-递推算法推导"><a href="#2-2-递推算法推导" class="headerlink" title="2.2 递推算法推导"></a>2.2 递推算法推导</h3><p>滤波过程分为预测与更新两阶段：</p><p><strong>(1) 先验估计预测</strong></p><script type="math/tex; mode=display">\hat{x}_i^{(-)} = F_i\hat{x}_{i-1}^{(+)}</script><script type="math/tex; mode=display">P_i^{(-)} = F_iP_{i-1}^{(+)}F_i^T + Q_i</script><p>其中$P_i$为状态协方差矩阵，表征估计不确定性</p><p><strong>(2) 后验估计更新</strong><br>计算卡尔曼增益：</p><script type="math/tex; mode=display">K_i = P_i^{(-)}H_i^T(H_iP_i^{(-)}H_i^T + R_i)^{-1}</script><p>融合观测值：</p><script type="math/tex; mode=display">\hat{x}_i^{(+)} = \hat{x}_i^{(-)} + K_i(z_i - H_i\hat{x}_i^{(-)})</script><p>更新协方差：</p><script type="math/tex; mode=display">P_i^{(+)} = (I - K_iH_i)P_i^{(-)}</script><hr><h2 id="3-应用与参数调优"><a href="#3-应用与参数调优" class="headerlink" title="3. 应用与参数调优"></a>3. 应用与参数调优</h2><h3 id="3-1-过程噪声影响"><a href="#3-1-过程噪声影响" class="headerlink" title="3.1 过程噪声影响"></a>3.1 过程噪声影响</h3><p>以行人轨迹跟踪为例，过程噪声协方差$Q$中的$\sigma_s$参数调节动力学模型信任度：</p><ul><li>大$\sigma_s$值：优先响应观测数据，轨迹更接近原始测量</li><li>小$\sigma_s$值：强化物理约束，输出更平滑轨迹</li></ul><h3 id="3-2-Python实现示例"><a href="#3-2-Python实现示例" class="headerlink" title="3.2 Python实现示例"></a>3.2 Python实现示例</h3><pre><code class="lang-python">import numpy as np# 状态向量 [位置, 速度]x = np.array([[0.0], [0.0]])F = np.array([[1, 1], [0, 1]])  # 状态转移矩阵H = np.array([[1, 0]])          # 观测矩阵Q = np.diag([0.1, 0.01])       # 过程噪声协方差 R = np.array([[10.0]])         # 测量噪声方差for measurement in measurements:    # 预测步骤    x = F @ x    P = F @ P @ F.T + Q    # 更新步骤    K = P @ H.T @ np.linalg.inv(H @ P @ H.T + R)    x += K @ (measurement - H @ x)    P = (np.eye(2) - K @ H) @ P</code></pre><hr><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><h3 id="4-1-优势"><a href="#4-1-优势" class="headerlink" title="4.1 优势"></a>4.1 优势</h3><ul><li>线性高斯系统下的最优估计</li><li>计算复杂度仅与状态维度立方相关</li><li>提供实时置信度评分</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据挖掘与分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据挖掘与分析 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
